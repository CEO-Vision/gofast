class Optional{static from(t){return t&&Some.of(t)||None}map(t){return this}flatMap(t){return this}fold({none:t}){return t&&t()}}class Some extends Optional{constructor(t){super(),this.value=t}map(t){return Some.of(t(this.value))}flatMap(t){return t(this.value)}fold({some:t}){return t&&t(this.value)}static of(t){return new Some(t)}}const None=new Optional;class FetchStatus{constructor(t={}){this.opt={at:Date.now(),...t}}map(t){return this}flatMap(t){return this}}class Success extends FetchStatus{static of(t){return new Success(t)}constructor(t,e){super(e),this.value=t}map(t){return new Success(t(this.value),this.opt)}flatMap(t){return t(this.value,this.opt)}fold({success:t}){return t instanceof Function?t(this.value,this.opt):void 0}}class Pending extends FetchStatus{static of(t){return new Pending(t)}constructor(t){super(t)}fold({pending:t}){return t instanceof Function?t(this.opt):void 0}}class FetchError extends FetchStatus{static of(t,e){return new FetchError(t,e)}constructor(t,e){super(e),this.reason=t}fold({error:t}){return t instanceof Function?t(this.reason,this.opt):void 0}}