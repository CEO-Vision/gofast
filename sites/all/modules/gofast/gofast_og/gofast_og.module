<?php

/**
 * Define field names for space memberships. This field is attached to Gofast'
 * OG node bundles except the user's private space. It stores parent space
 * ids of a given space (space <=> parent cardinality is 0:1).
 */
define('GOFAST_OG_PARENT_GROUP_FIELD', 'og_group_ref');

/**
 * Define field names for content memberships. This field is attached to Gofast'
 * content node bundles. It stores parent OG ids of a node.
 * (content <=> parent cardinality is 0:n)
 */
define('GOFAST_OG_CONTENT_MEMBERSHIP_FIELD', 'og_group_content_ref');

/**
 * Define field name for user's space memberships. This field is attached to
 * user bundle and store OG node ids (references Gofast spaces bundles).
 */
define('GOFAST_OG_USER_MEMBERSHIP_FIELD', 'og_user_node');

/**
 * Define field name for og content access policy (whether a content is public
 * or private).
 */
define('GOFAST_OG_CONTENT_VISIBILITY', 'content_visibility');

/**
 * Define access policy : content visibility values for GOFAST_OG_CONTENT_VISIBILITY.
 */
define('GOFAST_OG_CONTENT_ACCESS_PUBLIC', 1);
define('GOFAST_OG_CONTENT_ACCESS_PRIVATE', 1);
define('GOFAST_OG_CONTENT_ACCESS_DEFAULT', GOFAST_OG_CONTENT_ACCESS_PRIVATE);

/**
 * Define field name for the user's private space. This field is attached to
 * user bundle and store the OG node id (references private_space bundle).
 */
define('GOFAST_OG_USER_PRIVATE_SPACE', 'og_private');

/**
 * Define access policy : space visibility values for OG_ACCESS_FIELD.
 */
define('GOFAST_OG_GROUP_ACCESS_PUBLIC', 0);
define('GOFAST_OG_GROUP_ACCESS_PRIVATE', 1);
define('GOFAST_OG_GROUP_ACCESS_DEFAULT', GOFAST_OG_GROUP_ACCESS_PRIVATE);

/**
 * Gofast spaces roles.
 *
 * Space members are at least read-only. This role is automatically granted when
 * users are registered (i.e. og_membership is created/updated and active).
 */
define('GOFAST_OG_ROLE_ADMIN', OG_ADMINISTRATOR_ROLE);
define('GOFAST_OG_ROLE_STANDARD', 'group contributor');
define('GOFAST_OG_ROLE_READ_ONLY', 'read only member');

/**
 * The field name for user inheritance. OG Subgroups claimed to be able to
 * propagate user membership as in the 6.x version but it doesn't, and even
 * allowed values definition for this field no longer exist. We define it here
 * (keeping the same name for now so that we can rely on the original field
 * definition instead of creating a new one) to handle OG member inheritance.
 */
define('OG_USER_INHERITANCE_FIELD', 'og_user_inheritance');

/**
 * Define values for user inheritance field (user membership propagation from
 * one space to others).
 */
define('OG_USER_INHERITANCE_SUBGROUP', 0);
define('OG_USER_INHERITANCE_PARENT', 1);
define('OG_USER_INHERITANCE_NONE', 2);
define('OG_USER_INHERITANCE_DEFAULT', OG_USER_INHERITANCE_PARENT);

/**
 * Name the default inherited role to grant to inherited member when suscribed
 * into a space (when this space inherits this user by membership propagation).
 */
define('OG_USER_INHERITANCE_ROLE', GOFAST_OG_ROLE_READ_ONLY);

/**
 * Possible values for space visibility :
 *  - OFF : Default behavior (relies on core/OG/GofastOG permissions).
 *  - ON  : User cannot see spaces they are not member of.
 */
define('GOFAST_OG_PARTITIONING_OFF', 0);
define('GOFAST_OG_PARTITIONING_ON', 2);
define('GOFAST_OG_PARTITIONING_ON_ONLY_EXTRANET', 1);

/**
 * Default value for user visibility.
 */
define('GOFAST_OG_PARTITIONING_DEFAULT', GOFAST_OG_PARTITIONING_OFF);

/**
 * Possible values for admin visibility :
 *  - OFF : Admin canot see others spaces.
 *  - ON  : Admin can see other spaces.
 */
define('GOFAST_ADMIN_VISIBILITY_OFF', 0);
define('GOFAST_ADMIN_VISIBILITY_ON', 1);

/**
 * Default value for Admin visibility.
 */
define('GOFAST_ADMIN_VISIBILITY_DEFAULT', GOFAST_OG_PARTITIONING_OFF);


/*
 * Max items that can be processed in one cron for membership rebuild
 */
define('GOFAST_OG_MEMBERSHIP_QUEUE_MAX_VALUE', 4);

/*
 * String value of Extranet root space
 */
define('GOFAST_CMIS_LOCATIONS_FIELD_EXTRANET_VALUE', '_Extranet');

/**
 * Include gofast_og.delete.inc that contains some hook implementations.
 */
include_once __DIR__ . '/gofast_og.delete.inc';



function gofast_og_init(){
   global $must_propagate;
   $must_propagate = true;
   module_load_include('inc', 'gofast_og', 'gofast_og_excel');
}

/**
 * Helper function, returns Gofast 'Spaces' (OG node bundles).
 *
 * @param boolean $prevent_translation [optional]
 *  Whether to translate the bundle labels or preserve the original system
 *  strings. Set it to FALSE if you want to display labelized space types.
 *  Defaults to TRUE (prevent any wrong key intersection when arrays are loaded
 *  with bundle labels as keys).
 */
function gofast_og_node_types($prevent_translation = TRUE) {
    if($prevent_translation){
         return array(
        'group' => 'Group',
        'organisation' => 'Organisation',
        'private_space' =>'Personal Space',
        'extranet' => 'Extranet',
        'public' => 'Public'
         );
    }else{
        $lang = $GLOBALS['user']->language;
         return array(
        'group' => t('Group', array(), array('langcode' => $lang, 'context' => 'gofast')),
        'organisation' => t('Organisation', array('langcode' => $lang, 'context' => 'gofast')),
        'private_space' => t('Personal Space', array('langcode' => $lang, 'context' => 'gofast')),
        'extranet' => t('Extranet', array('langcode' => $lang, 'context' => 'gofast')),
        'public' => t('Public', array('langcode' => $lang, 'context' => 'gofast'))
         );
    }
}

/**
 * Helper function, returns Gofast OG's content bundles (i.e Gofast OG contents
 * types that are not OG node.
 */
function gofast_og_content_bundles() {
  return array(
    'article',
    'alfresco_item',
    'forum',
    'webform',
    'conference'
  );
}

function gofast_og_permission() {
  return array(
    'administer spaces' => array(
      'title' => t('Administer spaces', array(), array('context' => 'gofast')),
      'description' => t('Allow to perform restricted administration task on any spaces (including managing members).'
      . ' Note: This is not a real permission as it gives privileges to a user only when combined with other permissions:'
      . ' to perform adminstration tasks in a given space, user should have default permissions of "administrator member"'
      . ' in such space. To subscribe a user into a space from profile forms, the permission "administer users" is required.', array(), array('context' => 'gofast:gofast_og')),
      'restrict access' => TRUE,
    ),

     'archive space' => array(
      'title' => t('Archive space', array(), array('context' => 'gofast')),
      'description' => "archve space",
      'roles' => array(OG_AUTHENTICATED_ROLE),
      'default role' => array(OG_ADMINISTRATOR_ROLE),
    ),

    'contact administrators' => array(
      'title' => t('Contact space administrators', array(), array('context' => 'gofast')),
      'description' => "Allow to contact space administrators using contact form",
    ),
    'pre add members' => array(
      'title' => t('Pre add members', array(), array('context' => 'gofast')),
      'description' => "Add members to space even if we are not administrator, with status 'Pending' ",
    ),
    'access space info not member' => array(
      'title' => t('Access space info not members', array(), array('context' => 'gofast')),
      'description' => "Access some Spaces informations even if we are not member of",
    ),


  );
}

/**
 * Implements hook_node_access().
 */
function gofast_og_node_access($node, $op, $account) {

  //Check if we already cached the user spaces
  if(!empty($_POST['gofast_og_cache_spaces_by_user_'.$account->uid])){
      $user_spaces = $_POST['gofast_og_cache_spaces_by_user_'.$account->uid];
  }else{
    $user_spaces = gofast_og_get_spaces_by_user($account, TRUE, FALSE);
    $_POST['gofast_og_cache_spaces_by_user_'.$account->uid] = $user_spaces;
  }

  $type = is_string($node) ? $node : (is_array($node) ? $node['type'] : $node->type);

  $is_space = array_key_exists($type, gofast_og_node_types());
  $is_space_content = !$is_space && in_array($type, gofast_og_content_bundles());
  $is_adm = gofast_user_is_adm($account);

  if($account->uid == 1){
    return NODE_ACCESS_ALLOW;
  }
  if(!is_string($node)){
     $nid = $node->nid;
  }else{
     $nid = $node;
  }
  switch ($type) {
    case $is_space:
      //Override space creation permission in GOFAST-5605
      if($op == "create" && !isset($node->nid)){
        //Check if we need to overide space creation permissions
        $spaces_defaults = gofast_admin_get_space_defaults();

        if($spaces_defaults['create_sub_space'] && in_array($type, array('group', 'extranet'), TRUE)){
            return NODE_ACCESS_ALLOW;
        }
      }

      if ($op !== 'view') {

        //Restrict access in edition for all non-members
        $gids = $user_spaces;
        if(! in_array($nid, $gids, true) && !is_string($node)){
           return NODE_ACCESS_DENY;
        }
        // Deny access if the user haven't the global permission to administer
        // spaces, or if the node is a root space.
        // EDIT : Allow user to modify their own private space
        if (!user_access('administer spaces', $account) || isset($node->nid) &&
            ( gofast_og_is_root_space($node) && !($node->nid == gofast_og_get_user_private_space($account, FALSE)) ) ) {
          return NODE_ACCESS_DENY;
        }elseif(user_access('administer spaces', $account) && !in_array('administrator member', gofast_og_get_user_final_roles_for_space('node', $node->nid, $account->uid), true)){
          return NODE_ACCESS_DENY;
        }
        // For now, delete operation is reserved to adms and space creator only.
        if ($op === 'delete' && (!gofast_og_can_delete_space($account, $node))) {
          return NODE_ACCESS_DENY;
        }
        // Otherwise let other modules take care of it.
        return NODE_ACCESS_IGNORE;
      }
      // View op.
      // If node is unpublished, only author & adms can eventually access it.
      if (isset($node->nid) && ($node->status || $node->uid == $account->uid || $is_adm)) {
        // Partitioning OFF: all spaces are viewable.
        $partitioning = variable_get('gofast_og_partitioning', GOFAST_OG_PARTITIONING_DEFAULT);
        // Admin ON : allow to see spaces for admin's
        $admin_visibility = variable_get('gofast_admin_visibility', GOFAST_ADMIN_VISIBILITY_DEFAULT);
        if (gofast_user_is_business_admin($account) || $partitioning == GOFAST_OG_PARTITIONING_OFF || (!gofast_user_is_extranet($account) && $partitioning == GOFAST_OG_PARTITIONING_ON_ONLY_EXTRANET) || ($admin_visibility == GOFAST_ADMIN_VISIBILITY_ON && gofast_user_is_adm($account))) {
            return NODE_ACCESS_ALLOW;
        }

        if((gofast_user_is_extranet($account) && $partitioning == GOFAST_OG_PARTITIONING_ON_ONLY_EXTRANET) || ($partitioning == GOFAST_OG_PARTITIONING_ON) || ($admin_visibility == GOFAST_ADMIN_VISIBILITY_ON && gofast_user_is_adm($account))){
           $gids = $user_spaces;
           return in_array($node->nid, $gids) ? NODE_ACCESS_ALLOW : NODE_ACCESS_DENY;
        }

        // Otherwise user must be a member of a space to see it, depending if partitionning is enabled only for extranet users or not
        $gids = $user_spaces;
         if($node->type !== 'private_space' ){
           return in_array($node->nid, $gids) ? NODE_ACCESS_ALLOW : NODE_ACCESS_IGNORE; //NODE_ACCESS_DENY;
        }else{
           return in_array($node->nid, $gids) ? NODE_ACCESS_ALLOW : NODE_ACCESS_DENY;
        }
      }
      return NODE_ACCESS_IGNORE;
    break;
    case $is_space_content:
      if($op == 'update' && $node->field_is_homepage[LANGUAGE_NONE][0]['value']){
        //Check if I'm admin of this document's space
        $gid = $node->og_group_content_ref[LANGUAGE_NONE][0]['target_id'];
        if(!node_access("update", node_load($gid))){
          return NODE_ACCESS_DENY;
        }
      }
      // OG access policy is correctly implemented via admin settings. However,
      // view operation access check needs to be overriden as OG always returns
      // NODE_ACCESS_IGNORE in this case.
      if ($op === 'view' && isset($node->nid)) {
        // User must be granted access to at least one parent space to obtain
        // the node access, deny otherwise.
        $user_gids = $user_spaces;
        $node_gids = _gofast_og_content_get_parents($node, FALSE);

        //Allow some modules to manage nodes without any og parent
        if(count($node_gids) == 0){
            $gofast_og_allow_orphan_docs = false;
            foreach (module_implements('gofast_og_allow_orphan_docs') as $module) {
                $process_og_callback = $module . '_gofast_og_allow_orphan_docs';
                $allow = $process_og_callback();
                //at least one module allow it
                if($allow == true){
                    $gofast_og_allow_orphan_docs = true;
                }
              }

            // let modules manage those oprhaned node
            if($gofast_og_allow_orphan_docs == true){
              return NODE_ACCESS_IGNORE;
            }
        }

        $intersect = array_intersect_key($user_gids, $node_gids);
        if (empty($intersect)) {
          if(empty($node_gids) && $node->status == 0 && $node->uid == $account->uid){
              //GOFAST-5242 This is a special case where a node is deleted and is not in any space anymore
              //This may occur when spaces are deleted
              //So we give an access to the initial document author to allow them to restore it
              return NODE_ACCESS_ALLOW;
          }

          if($node->type == "alfresco_item" || $node->type == "article"){
            //We are about to deny the access to the document because no matching og permission has been found
            //After GOFAST-6796 just before doing that, we try to find out if og is aware of all locations of the document

            //Get document locations
            $alfresco_parents = gofast_cmis_webservice_get_node_parents($node->reference);
            foreach($alfresco_parents as $alfresco_parent){
              $alfresco_location = $alfresco_parent;
              $gid = gofast_og_get_group_id_from_title_without_cmis($alfresco_location, TRUE, TRUE);
              $alfresco_gids[$gid] = "";
            }

            $integrity_intersect = array_intersect_key($user_gids, $alfresco_gids);

            if(!empty($integrity_intersect)){
                //INTEGRITY WARNING : User has access to view the document based on Alfresco locations
                global $user;
                watchdog('gofast_integrity', "INTEGRITY_WARNING : User " . $user->uid . " has access to view " . $node->nid . " based on Alfresco locations but has not based on OG.", array(), WATCHDOG_CRITICAL);

                //Save the node with fixed gid
                entity_get_controller('node')->resetCache([$node->nid]);
                $node_integrity = node_load($node->nid, NULL, TRUE);

                $_POST['technically_save'] = TRUE;
                $node_integrity->technically_save = TRUE;
                $node_integrity->technically_changed = $node_integrity->changed;

                unset($node_integrity->og_group_content_ref['und']);

                foreach($alfresco_gids as $alfresco_gid => $v){
                    $node_integrity->og_group_content_ref['und'][]['target_id'] = $alfresco_gid;
                }

                field_attach_update('node', $node_integrity); // no hook_field_update()
                entity_get_controller('node')->resetCache([$node_integrity->nid]);

                return NODE_ACCESS_ALLOW;
            }
          }

          return NODE_ACCESS_DENY;
        }else{
          return NODE_ACCESS_ALLOW;
        }
      }

      //Check perms of all node's spaces as we need to be able to administer all
      //location of the node to delete/update it
      if($op == "delete" && isset($node->nid)){
        if ($groups = og_get_entity_groups('node', $node)) {
          foreach ($groups as $group_type => $gids) {
            foreach ($gids as $gid) {
               $role = gofast_og_get_user_final_roles_for_space('node', $gid, $account->uid);
               $role_name = array_shift(array_values($role));
               if ($role_name == "read only member") {
                    return NODE_ACCESS_DENY;
               }else if($role_name == "group contributor" && $account->uid !== $node->uid){
                   return NODE_ACCESS_DENY;
               }
            }
          }
          return NODE_ACCESS_IGNORE;
        }
      }
      break;
    case 'blog':
	if($node->uid == $account->uid){
	    return NODE_ACCESS_ALLOW;
	}else{
	    return NODE_ACCESS_DENY;
	}
    break;
    default:
      // Authorize authors & administrators to access unpublished nodes, except
      // private spaces (for which an access is already returned).
    if (isset($node->nid) && !$node->status && $account->uid != 0 && ($is_adm || $node->uid == $account->uid)) {
        return NODE_ACCESS_ALLOW;
      } else if (isset($node->nid) && !$node->status && $account->uid != 0 && (!$is_adm || $node->uid != $account->uid)) {
        return NODE_ACCESS_ALLOW;
      }
      return NODE_ACCESS_IGNORE;
  }

  return NODE_ACCESS_IGNORE;
}

/**
 * Helper function that returns TRUE if the given $node is a Gofast space, FALSE
 * otherwise. Use og_is_group() to know if an entity is acting as a space.
 *
 * @param $node
 *  A drupal node object.
 * @param boolean $include_private
 *  If FALSE, user's private space won't be included along with other spaces.
 *  Defaults to TRUE.
 * @return boolean
 */
function gofast_og_is_space($node, $include_private = TRUE) {
  $og_types = gofast_og_node_types();
  if (!$include_private) {
    unset($og_types['private_space']);
  }
  return isset($node->type) && isset($og_types[$node->type]);
}

/**
 * Return whether the space is private or not (accessibility).
 * Do not confuse with @gofast_og_is_user_private_space().
 * @param type $node
 * @return boolean
 */
function gofast_og_is_private($node) {
  /*$wrapper = entity_metadata_wrapper('node', $node);
  if (!isset($wrapper->{OG_ACCESS_FIELD})) {
    watchdog('Gofast OG', 'Field :field is not attached to the node :nid', array(':field' => OG_ACCESS_FIELD, ':nid' => $node->nid));
    return GOFAST_OG_GROUP_ACCESS_DEFAULT === GOFAST_OG_GROUP_ACCESS_PRIVATE;
  }
  return (int) $wrapper->{OG_ACCESS_FIELD}->value() === GOFAST_OG_GROUP_ACCESS_PRIVATE;*/

  //See GOFAST-2800 and gofast_og_is_public()
  return true;
}

/**
 * Return whether the space is public or not.
 */
function gofast_og_is_public($node) {
  /*$wrapper = entity_metadata_wrapper('node', $node);
  if (!isset($wrapper->{OG_ACCESS_FIELD})) {
    watchdog('Gofast OG', 'Field :field is not attached to the node :nid', array(':field' => OG_ACCESS_FIELD, ':nid' => $node->nid));
    return GOFAST_OG_GROUP_ACCESS_DEFAULT === GOFAST_OG_GROUP_ACCESS_PUBLIC;
  }
  return (int) $wrapper->{OG_ACCESS_FIELD}->value() === GOFAST_OG_GROUP_ACCESS_PUBLIC;*/


  //We consider public spaces like every others spaces
  //See GOFAST-2800
  return false;
}

/**
 * Returns whether the space is a user private space or not.
 */
function gofast_og_is_user_private_space($node) {
  if (is_scalar($node)) {
    $node = node_load($node);
  }
  return isset($node->type) && $node->type === 'private_space';
}

/**
 * Helper, returns whether a space content is public or not.
 */
function gofast_og_content_is_public($node) {
  /*$wrapper = entity_metadata_wrapper('node', $node);
  if (!isset($wrapper->{GOFAST_OG_CONTENT_VISIBILITY})) {
    watchdog('Gofast OG', 'Field :field is not attached to the node :nid', array(':field' => GOFAST_OG_CONTENT_VISIBILITY, ':nid' => $node->nid));
    return GOFAST_OG_CONTENT_ACCESS_DEFAULT === GOFAST_OG_CONTENT_ACCESS_PUBLIC;
  }
  return (int) $wrapper->{GOFAST_OG_CONTENT_VISIBILITY}->value() === GOFAST_OG_CONTENT_ACCESS_PUBLIC;*/

  //We consider public spaces like every others spaces
  //See GOFAST-2800
  return false;
}

/**
 * Builds up an ancestors tree (OG nodes/nid) of the given node.
 *
 * @param $node
 *  A drupal node object.
 * @param boolean $full
 *  If true, loads the full node objects for each parent space, nid otherwise.
 *  Note : 1st-level parent(s) will always be loaded.
 * @param boolean $flat
 *  Whether to return a flat list or a hierachical list. Defaults to FALSE.
 * @return
 *  An array of ancestors with following key/values : <pre>
 *    array(
 * &nbsp; parent_nid => array(parent_nid => parent_object, 'ancestors' => array(ancestor_level => node/nid)),
 * &nbsp; parent_nid2 => array(parent_nid2 => ...
 *    );</pre>
 */
function gofast_og_get_ancestors($node, $full = FALSE, $flat = FALSE) {
  $tree = array();

  // Get the parent(s) one level up. If $node is a space, it can have only one
  // single parent space, but a content may have several parent spaces.
  $parents = gofast_og_get_parent($node, $full);

  if (!$parents)
    return array();

  if (!is_array($parents)) {
    // The given $node is an OG node, so $parents is either a single object,
    // or a single nid.
    $gid = $full ? $parents->nid : $parents;
    $parents = array($gid => $parents);
  }

  foreach ($parents as $gid => &$parent) {
    // Walk through each first level parents, get its corresponding ldap entry
    // and build up its ancestors tree.
    $ancestors = array();
    if (!$full) {
      // Close parents must be loaded so we can extract ids from the dn field.
      $parent = node_load($parent);
    }
    $dn = gofast_ldap_space_dn($parent);
    // Retrieve ancestors.
    $ids = gofast_ldap_get_ancestors($dn);
    $ids && $ancestors = $full ? node_load_multiple($ids) : array_combine($ids, $ids);
    if ($flat) {
      $tree[$gid] = $parent;
      $tree += $ancestors;
    }
    else {
      $tree[$gid] = array($gid => $parent, 'ancestors' => $ancestors);
    }
  }

  return $tree;
}

/**
 * Returns the parent space(s) of a space or a space content. This function only
 * travels a single level up the spaces tree, to get the ancestors tree of a
 * given $node use gofast_og_get_ancestors().
 *
 * @param object $node
 *  The node object from which the parents are requested.
 * @param boolean $full
 *  Whether to return fully loaded node objects or simple nids.
 *
 * @return mixed :
 *  - $node is a space : the parent node object or the parent nid, depending on
 *  $full, FALSE if no parent was found.
 *  - $node is a space content : an array of node objects or an array of nids,
 *  depending on $full, or an empty array if no parent was found.
 */
function gofast_og_get_parent($node, $full = FALSE) {
  return gofast_og_is_space($node) ?
          _gofast_og_space_get_parent($node, $full) :
          _gofast_og_content_get_parents($node, $full);
}

/**
 * Returns the unique parent space of the given space.
 *
 * @param object $node
 *  The node object from which the parent space is requested.
 * @param boolean $full
 *  Whether to return a fully loaded node object or node ID.
 * @param boolean $ignore_last_event
 *  If TRUE, will not take the last OG membership event into account (e.g. the
 *  node was just subscribed into a space during the same page load), meaning
 *  the returned value could be an "old" value. Defaults to FALSE.
 *
 * @return
 *  The parent node object or nid, depending on $full, FALSE if no parent was
 *  found.
 */
function _gofast_og_space_get_parent($node, $full = FALSE, $ignore_last_event = FALSE) {
  // Read from the $node attached field.
  $wrapper = entity_metadata_wrapper('node', $node);
  $parent = isset($wrapper->{GOFAST_OG_PARENT_GROUP_FIELD}) ? $wrapper->{GOFAST_OG_PARENT_GROUP_FIELD}->getIdentifier() : NULL;

  if (!$ignore_last_event && isset ($node->nid)) {
    _gofast_og_membership_check_last_event($node, $parent);
  }

  return $parent ? ($full === TRUE ? node_load($parent) : $parent) : FALSE;
}

/**
 * Returns the parent space(s) of a space content.
 *
 * @param object $node
 *  The node object from which the parents are requested.
 * @param boolean $full
 *  Whether to return fully loaded node objects or simple nids.
 *
 * @return Array
 *  An array of node objects keyed by nid or an array of nids depending on $full,
 *  an empty array if no paretns was found.
 */
function _gofast_og_content_get_parents($node, $full = FALSE) {
  if ($parents = field_get_items('node', $node, GOFAST_OG_CONTENT_MEMBERSHIP_FIELD)) {
    $nids = array();
    foreach ($parents as $parent) {
      $nids[$parent['target_id']] = $parent['target_id'];
    }
    return $full === TRUE ? node_load_multiple($nids) : $nids;
  }
  return array();
}

function _gofast_og_membership_check_last_event($node, &$parent) {
  // A membership registration may have occured after $node object was loaded,
  // we have to check for race condition and override $parent if needed.
  $_events = _gofast_ldap_entity_last_events();
  if (isset($_events["og_membership|node|{$node->nid}"])) {
    list ($action, $_parent) = explode('|', $_events["og_membership|node|{$node->nid}"]);
    // A given membership deletion could or should not occur right after being
    // created/updated during a single page load, so we consider the membership
    // field has to be overriden in case of insert/update only.
    if ($action !== 'delete' && $_parent) {
      $parent = $_parent;
    }
  }
}

/**
 * Returns TRUE if a given OG node (space) acts as a parent of other OG node.
 */
function gofast_og_has_space_child($node) {
  return gofast_ldap_entry_has_child($node);
}

/**
 * Returns all children spaces (OG nodes) of a given OG node (Gofast OG bundle).
 * @param mixed $gid
 *  The gid of the parent OG node.
 * @param boolean $recursive [optional]
 *  Whether to retrieve direct children (one level down) or all descendants.
 *  Defaults to FALSE.
 * @param boolean $full [optional]
 *  If TRUE, loads OG node object. Defaults to FALSE.
 * @param boolean $flat [optional]
 *  If TRUE, does not preserve node hierarchy. Defaults to FALSE.
 * @return
 *  An array keyed by children gid's, the structure depends on the parameters.
 *  If $recursive and $full are TRUE and $flat is FALSE, array values are arrays
 *  keyed with 'node' and 'children'.
 */
function gofast_og_get_children($gid, $recursive = FALSE, $full = FALSE, $flat = FALSE) {
  $sub_gids = array();

  $query = db_select('og_membership', 'o');
  $query->fields('o', array('etid'))
          ->condition('o.gid', $gid, '=')
          ->condition('o.field_name', GOFAST_OG_PARENT_GROUP_FIELD, '=');

  $results = $query->execute()->fetchAll();

  foreach ($results as $key => $value) {
    $sub_gids[$value->etid] = $value->etid;
  }

  if ($recursive === TRUE) {
    // Prevent testing inside loop.
    if ($flat === TRUE) {
      foreach ($sub_gids as $gid) {
        // Never recursively load children entities, they will be loaded all at
        // once if it is needed.
        $sub_gids += gofast_og_get_children($gid, $recursive, FALSE, $flat);
      }
    }
    elseif ($full === TRUE) {
      foreach ($sub_gids as $gid) {
        $sub_gids[$gid] = array(
          'node' => node_load($gid),
          'children' => gofast_og_get_children($gid, $recursive, $full, $flat)
        );
      }
    }
    else {
      foreach ($sub_gids as $gid) {
        $sub_gids[$gid] = gofast_og_get_children($gid, $recursive, $full, $flat);
      }
    }
  }

  if ($full === TRUE && ($recursive === FALSE || $flat === TRUE)) {
    return entity_load('node', $sub_gids);
  }

  return $sub_gids;
}

/**
 * Returns an array of OG content nodes of a given space (given its node ID).
 *
 * @param int $gid
 *  The node iD from which to fetch content memberships.
 *
 * @param boolean $full
 *  Whether or not to load full njde object or simple node id as value.
 *
 * @return Array
 *  An array of OG content keyed by node ID.
 */
function gofast_og_get_content($gid, $full = FALSE, $statusFilter = FALSE) {
  $nids = array();

  $query = db_select('og_membership', 'o');
  if($statusFilter){
    $query->join('node', 'n', 'o.etid=n.nid');
  }
  $query->fields('o', array('etid'))
          ->condition('o.gid', $gid, '=')
          ->condition('o.field_name', GOFAST_OG_CONTENT_MEMBERSHIP_FIELD, '=');
  if($statusFilter){
    $query->condition('n.status', "1");
  }

  $results = $query->execute()->fetchAll();
  foreach ($results as $key => $value) {
    $nids[$value->etid] = $value->etid;
  }

  return $full ? entity_load('node', $nids) : $nids;
}

/**
 * Returns all existing 'spaces' of an entity type, filtered or grouped by a
 * specific bundle (e.g: group, organisation, extranet...)
 *
 * @param $bundles
 *  An array of OG node bundle machine_name. (e.g. for node as $entity_type, a
 *  content type that is an OG node). Leave empty to bypass bundle filtering.
 * @param $entity_type  [optional]
 *  The entity type. Defaults to 'node'
 * @return
 *  An array of OG node objects from a specific bundle keyed by its OG node id,
 *  or if $bundle is multivalued, an array with the bundle machine_name as the
 *  key and an array of OG objects as value.
 */
function gofast_og_get_spaces_by_bundle($bundles = array(), $entity_type = 'node') {
  // @todo : do static caching

  if (!is_array($bundles))
    $bundles = array($bundles);

  // Get all bundles that are a OG node type
  $_og_bundles = og_get_all_group_bundle();

  if (!is_array($_og_bundles[$entity_type]))
    return array();

  $_og_bundles = array_keys($_og_bundles[$entity_type]);
  $_bundles = (empty($bundles)) ? $_og_bundles : array_intersect($bundles, $_og_bundles);

  if (empty($_bundles))
    return array();

  $spaces = array();

  switch ($entity_type) {
    // other types not used for now
    case 'node' :
    default :
      foreach ($_bundles as $bundle) {
        $spaces[$bundle] = db_select($entity_type)
                ->fields($entity_type)
                ->condition('type', $bundle)
                ->execute()
                ->fetchAllAssoc('nid');
      }
  }

  return count($bundles) === 1 ? $spaces[reset($bundles)] : $spaces;
}

/**
 * Get the spaces a user is an approved member of. This is a wrapper function
 * that assumes the entity type of the spaces to fetch is always 'node'.
 *
 * @param $account [optional]
 *  The user object to fetch space memberships for. Defaults to current user.
 * @param boolean $include_public [optional]
 *  Whether to include public nodes or not (technically theres is no user
 *  membership but all users can access public spaces, contribution rights
 *  depends on their roles). Default to FALSE.
 * @param boolean $full [optional]
 *  Whether to return full node objects or not. Defaults to FALSE.
 * @param boolean fromAPI [optional]
 * @param boolean include_from_userlist [optional] included spaces coming from userlist membership
 * @return
 *  An array keyed by OG node IDs or an empty array.
 */
function gofast_og_get_spaces_by_user($account = NULL, $include_public = TRUE, $full = FALSE, $fromApi = FALSE, $include_from_userlist = TRUE) {
  if(is_numeric($account)){
    $account = user_load($account);
  }
  $user_gids = og_get_groups_by_user($account, 'node');
   if(! isset($user_gids)){
    $user_gids = array();
  }


  $userlist_gids = array();
  if($include_from_userlist){
    $userlist_gids = gofast_userlist_og_get_groups_by_user($account, 'node');
    $user_gids = $user_gids + $userlist_gids;
  }

  if (empty($user_gids)) {
    return array();
  }

  if (!$include_public) {
    $public_gids = gofast_og_get_spaces_by_bundle('public');
    $user_gids = array_diff_key($user_gids, $public_gids);
  }

  //Exclude userlist node (as og_get_group only filter by bundle)
  $spaces_type = gofast_og_node_types();
  foreach($user_gids as $key => $gid){
    if(! in_array(gofast_get_node_type($gid), $spaces_type)){
      unset($user_gids[$key]);
    }
  }


  //Usually, if this is set to true, gofast_chat module is requesting this fonction in ajax
  if($fromApi){
    //We format and encode in JSON as title_#id
    $excluded_spaces = gofast_og_get_root_spaces();
    foreach($user_gids as $key => $value){
      if(in_array($value, $excluded_spaces, true)){
        //We exclude root spaces and private spaces
        unset($user_gids[$key]);
        continue;
      }
      $user_gids[$key] = '_#'.$value;
    }
    print json_encode($user_gids);
    drupal_add_http_header('Status', '200 OK');
    exit;
  }
  return $full ? node_load_multiple($user_gids) : $user_gids;
}


/**
 * Get the sub-spaces of a given space, for a given (or current) user.
 *
 * @param type $parent_nid
 *    The nid of the parent node to fetch children from
 *
 * @param type $account [optional]
 *    The user object to fetch space memberships for. Defaults to current user.
 *
 * @param type $full
 *    Whether to return full node objects or not. Defaults to FALSE.
 *
 * @return
 *    An array keyed by OG node IDs or an empty array.
 */
function gofast_og_get_space_children_by_user($parent_nid, $account = NULL, $full = FALSE) {

  $subspaces_for_user = array();

  $spaces_for_user = gofast_og_get_spaces_by_user($account);
  $sub_spaces = gofast_og_get_children($parent_nid);

  $subspaces_for_user = array_intersect($sub_spaces, $spaces_for_user);

  return $full ? node_load_multiple( $subspaces_for_user ) :  $subspaces_for_user ;
}


/**
 * Returns spaces a given user has administer access to (checking OG permissions
 * in each space). It is recommended to check in the first place if the user has
 * 'administer spaces' permissions in order to avoid unneccessary checks.
 * Note: user's private space is excluded from the list.
 *
 * @param object $account [optional]
 *  A user object. Defaults to current user.
 *
 * @param boolean $full [optional]
 *  Whether to return full node objects or not. Defaults to FALSE.
 *
 * @return array
 *  An array keyed by OG node IDs or an empty array.
 */
function gofast_og_get_managed_spaces($account = NULL, $full = FALSE) {
  $managed_spaces = array();

  if (!$account) {
    $account = $GLOBALS['user'];
  }

  $spaces = gofast_og_get_spaces_by_user($account, TRUE, $full);
  $private_gid = gofast_og_get_user_private_space($account, FALSE);

  //Retrieve saved spaces configuration
  $spaces_defaults = gofast_admin_get_space_defaults();

  if($spaces_defaults['create_sub_space']){
    $first_level_spaces = array_merge(
            gofast_og_get_children(4, FALSE, FALSE, TRUE),
            gofast_og_get_children(6, FALSE, FALSE, TRUE)
    );
  }
  unset ($spaces[$private_gid]);

  foreach ($spaces as $gid => $og) {

    //Required to override og default perms that give full access to the space creator
    $user_roles_for_space = reset(gofast_og_get_user_final_roles_for_space('node', $gid, $account->uid));

    if ( $user_roles_for_space == 'administrator member' && og_user_access('node', $gid, 'administer group', $account)) {
      $managed_spaces[$gid] = $og;
    }else if($spaces_defaults['create_sub_space'] && in_array($gid, $first_level_spaces)){ //Override 1st level permission in GOFAST-5605
       $managed_spaces[$gid] = $og;
    }
  }

  return $managed_spaces;
}

/**
 * Get members of a given space, optionally filtered by a membership state.
 *
 * @param object $node
 *  A OG node entity.
 * @param string $state (optional)
 *  Filter members' list by specifying one of the following membership state :
 *  'active', 'pending' or 'blocked' (if wrong or not set, returns all members).
 * @return
 *  An array of members uid.
 */
function gofast_og_get_members($node, $state = NULL) {
  if (isset($state)) {
    $states = array(
      OG_STATE_ACTIVE => 'active',
      OG_STATE_PENDING => 'pending',
      OG_STATE_BLOCKED => 'blocked'
    );
    if (!in_array($state, $states)) {
      $state = NULL; // default (all states)
    }
    else {
      $states = array_flip($states);
      $state = "__{$states[$state]}";
    }
  }
  return og_get_group_members_properties($node, array(), $state, 'node');
}

/**
 * Return all users (uid) members of a space (included those for userlist membership)
 * @param type $node
 * @param type $state
 * @param type $flag_user_list -  If TRUE set special array key [$ulid.'_'.$uid] to know this member come from userlist
 * @return type array(uid)
 */
function gofast_og_get_members_userlist_included($node, $state = NULL, $flag_user_list=FALSE){

  $all_members = gofast_og_get_members($node, $state);

  if (isset($state)) {
    $states = array(
      OG_STATE_ACTIVE => 'active',
      OG_STATE_PENDING => 'pending',
      OG_STATE_BLOCKED => 'blocked'
    );
    if (!in_array($state, $states)) {
      $state = NULL; // default (all states)
    }
    else {
      $states = array_flip($states);
      $state = "__{$states[$state]}";
    }
  }

  //add members from userlist
  $userlists_ulid = array();
  $userlists_ulid = gofast_userlist_og_get_group_members_properties($node, array(), $state, 'node', array('userlist'));
  foreach($userlists_ulid['userlist'] as $key => $ulid ){
     $m=array_keys(gofast_userlist_get_members($ulid));
     if($flag_user_list){
         foreach($m as $uid){
              $all_members[$ulid.'_'.$uid] = $uid;
         }
      }
      else{
          $all_members = array_merge($all_members,  $m);
      }
  }

  return array_unique($all_members, SORT_NUMERIC);
}

/**
 * Get actives nodes in the given space.
 *
 * @param object $node
 *  A OG node entity.
 * @return
 *  An array of nodes nid.
 */
function gofast_og_get_nodes($node) {
  return db_select('og_membership', 'ogm')
          ->fields('ogm', array('etid'))
          ->condition('entity_type', 'node')
          ->condition('gid', $node->nid)
          ->condition('group_type', 'node')
          ->condition('state', 0, '>')
          ->condition('field_name', 'og_group_content_ref')
          ->execute()
          ->fetchAll();
}

/**
 * Get actives nodes in the given space.
 *
 * @param object $node
 *  A OG node entity.
 * @return
 *  An array of nodes nid.
 */
function gofast_og_get_nodes_from_gids($nids) {
  return db_select('og_membership', 'ogm')
          ->fields('ogm', array('etid'))
          ->condition('entity_type', 'node')
          ->condition('gid', $nids, "IN")
          ->condition('group_type', 'node')
          ->condition('state', 0, '>')
          ->condition('field_name', 'og_group_content_ref')
          ->execute()
          ->fetchAll();
}

/**
 * Get unpublished nodes in the given space.
 *
 * @param object $node
 *  A OG node entity.
 * @return
 *  An array of nodes nid.
 */
function gofast_og_get_nodes_unpublished($nids) {
  $query =  db_select('og_membership', 'ogm');
  $query->join('node', 'n', 'n.nid = ogm.etid');
  $all_nids =  $query->fields('ogm', array('etid'))
          ->condition('entity_type', 'node')
          ->condition('gid', $nids, "IN")
          ->condition('group_type', 'node')
           ->condition('state', 0, '>')
          ->condition('field_name', 'og_group_content_ref')
          ->condition('n.status', 0, "=")
         ->condition('n.type', 'alfresco_item')
          ->execute()
          ->fetchAll();

  return $all_nids;
}

/**
 * Returns Gofast default organisation node object, handling node creation in
 * case no such object exists.
 */
function gofast_og_get_default_organisation() {
  $org_id = variable_get('gofast_og_default_organisation', FALSE);
  if (!$org_id) {
    // Default organisation gid is not set or not valid. Register a new one.
    $org_id = gofast_og_set_default_organisation();
  }
  return $org_id ? node_load($org_id) : FALSE;
}

/**
 * Creates organisation (OG node, type 'organisation') and set it as the
 * default main organisation.
 *
 * @return $gid
 *  The OG id of the newly created organisation, or false otherwise.
 */
function gofast_og_create_default_organisation() {
  $org = gofast_og_get_spaces_by_bundle('organisation');
  if (!empty($org))
    return gofast_og_set_default_organisation();

  // Generate title using 2nd level domain name. @todo: or use site-name?
  global $base_url;
  list(, $title) = array_reverse(explode('.', $base_url));

  // Create node.
  $errors = gofast_og_create(strtoupper($title), 'organisation');

  if (!empty($errors)) {
    $message = '';
    foreach ($errors as $key => $value) {
      $message .= "$key : $value <br />";
    }
    drupal_set_message($message, 'error');
    return FALSE;
  }

  // Get newly created organisation's gid.
  $query = db_select('node');
  $query->addExpression('MAX(nid)');
  $gid = $query->condition('type', 'organisation')->execute()->fetchField();

  // Set as default.
  variable_set('gofast_og_default_organisation', $gid);
  return $gid;
}

/**
 * Implements hook_entity_insert()
 *
 *  Note: OG roles are checked, created or updated in hook_og_membership_OP().
 *
 */
function gofast_og_entity_insert($entity, $entity_type) {
 /* // Auto-subscribe administrators if not already author/manager of the space,
  // excluding private space.
  if ($entity_type === 'node' && gofast_og_is_space($entity, FALSE)) {
    $adms = gofast_user_load_multiple_by_roles(GOFAST_ROLE_ADMIN);
    //unset ($adms[$entity->uid]);
    foreach ($adms as $account) {
      gofast_og_subscribe_user($entity, $account);
    }
  }*/
}

/**
 * Implements hook_entity_update()
 */
function gofast_og_entity_update($entity, $entity_type) {
  if (gofast_og_is_space($entity)) {
    $original = $entity->original;
    $original_group_ref = $original->og_group_ref[LANGUAGE_NONE][0]["target_id"];
    $new_group_ref = $entity->og_group_ref[LANGUAGE_NONE][0]["target_id"];
    if ($new_group_ref != $original_group_ref) {
      //if the space was moved into hierarchy, propagate memberships of current member
      $members = gofast_og_get_members($entity, 'active');
      if (count($members) > 0) {
        foreach ($members as $member_uid) {
          $membership = og_get_membership('node', $entity->nid, 'user', $member_uid);
          gofast_og_membership_propagate($membership);
        }
      }
      //if the space was moved into hierarchy, propagate memberships of current member (userlist)
      $members = gofast_userlist_og_get_node_members($entity->nid, array('userlist'), 'active');
      if (count($members) > 0) {
        foreach ($members as $member_ulid) {
          $membership = og_get_membership('node', $entity->nid, 'userlist', $member_ulid->etid);
          gofast_og_membership_propagate($membership);
        }
      }
    }
  }
}

/**
 * Hook node view
 */
function gofast_og_node_view($entity, $view_mode, $langcode) {
  if (gofast_og_is_space($entity) && $view_mode === 'full') {
    drupal_add_js(drupal_get_path('module', 'gofast_og') . "/gofast_og.js");
    drupal_add_js(drupal_get_path('module', 'gofast_og') . "/js/gofastSpaceMembers.js");
  }
}

/**
 * Implements hook_node_delete()
 */
function gofast_og_node_delete($node) {
  if (!gofast_og_is_space($node)) {
    return;
  }

  // If the node being deleted is a Gofast 'organisation' set as "default
  // organisation", delete this reference as well.
  if ($node->type === 'organisation' && $node->nid === variable_get('gofast_og_default_organisation', FALSE)) {
    variable_set('gofast_og_default_organisation', FALSE);
  }
  /** @todo : unref deleted organisation that is set as a main organisation somewhere (user account) */

  //GOFAST-6661 Emptying cache when deleting space node to fix login issue
  $bins = field_flush_caches();
  foreach($bins as $bin) {
      cache_clear_all('*', $bin, TRUE);
  }

}

/**
 * Implements hook_og_membership_insert()
 */
function gofast_og_og_membership_insert(OgMembership $og_membership) {
  $node = node_load($og_membership->gid);
  //We prevent the following code to be executed on public spaces and root spaces as their
  //membership behavior is different as the other spaces
  if((gofast_og_is_root_space($node) && !gofast_og_is_user_private_space($node)) || $node->type == 'public'){
    return;
  }
  // Role grant / user inheritance (@see gofast_ldap_og_role_grant() for role
  // replication in LDAP directory).
  watchdog(' OG MEMBERSHIP_INSERT ', $og_membership->gid . ' - ' . $og_membership->entity_type . ' - ' . $og_membership->etid);

  if (!($og_membership->entity_type === 'user' && $og_membership->field_name === GOFAST_OG_USER_MEMBERSHIP_FIELD)) {
    return;
  }

  // Load the account associated with the member.
  $account = user_load($og_membership->etid);
  global $must_propagate;

  // Retrieve the OG node bundle name.
  $wrapper = entity_metadata_wrapper($og_membership->group_type, $og_membership->gid);
  $bundle = $wrapper->getBundle();
  if(gofast_og_is_user_private_space($node)){
      return;
  }
   if (og_is_group_default_access($og_membership->group_type, $og_membership->gid)) {
    // Get global OG roles.
    $roles = og_roles($og_membership->group_type, $bundle, 0, FALSE, TRUE);
  }
  else {
    // Get this specific roles, as the permission set may have been overriden.
    $roles = og_roles($og_membership->group_type, $bundle, $og_membership->gid, TRUE, TRUE);
  }

  //if the user is the creator and the space have not yet any user registered in, make it admin
  $members = gofast_og_get_members_userlist_included($node);
  $count_members = count($members);
  if($node->uid == $account->uid && $count_members <= 1){
        $roles = array_intersect($roles, array(GOFAST_OG_ROLE_ADMIN));
        foreach ($roles as $rid => $role) {
          og_role_grant($og_membership->group_type, $og_membership->gid, $og_membership->etid, $rid);
        }
  }else{
       if($must_propagate == true){
            $default_role_name = gofast_og_get_user_default_role($account);

            $default_role_rid = array_search($default_role_name, $roles);
            if ($default_role_rid !== FALSE) {
                og_role_grant($og_membership->group_type, $og_membership->gid, $og_membership->etid, $default_role_rid);
            }

            //Check if the user just created is admin at least of one space. if yes give him the MANAGER role
            //Insert ignore needed to prevent errors at account creation
            if($default_role_name == OG_ADMINISTRATOR_ROLE){
               $role = user_role_load_by_name(GOFAST_ROLE_MANAGER);
               db_query("INSERT IGNORE INTO {users_roles} (rid, uid) VALUES ('".$role->rid."','".$account->uid."')");
            }
       }
  }

    $membership_data = array(
        'membership_action' => 'NMEM', // add Member
        'membership_type' => 'user',
        'membership_id' => $og_membership->etid,
        'membership_name' => gofast_user_get_display_name_sql($og_membership->etid)
    );

    gofast_message_ext_create_og_membership_entity($node, $membership_data);
    //Log into audit
    gofast_audit_add_members($node, $membership_data);


  if($must_propagate == true){
    gofast_og_membership_propagate($og_membership);
  }
}


/**
 * Set owner of space as admin in alfresco if user isn't member of this space and he's owner
 * Avoid displaying spaces in GFB - GOFAST-5976
 * @param type $og_membership_gid identifiant of node ( space )
 * @param type $og_membership_etid id of the user who is no longer a member
 */
function gofast_og_set_admin_as_owner( $og_membership_gid , $og_membership_etid ){

  $id_member = $og_membership_etid;
  $info_member = user_load($id_member);

  $node = node_load($og_membership_gid);
  $ref = $node->field_folder_reference[LANGUAGE_NONE][0]['value'];
  $cmisdetail = gofast_cmis_item_get($ref);

  if( $cmisdetail->properties['cm:owner'] ){

      if( $cmisdetail->properties['cm:owner']!=='admin' && $cmisdetail->properties['cm:owner'] == $info_member->name ){

         $username = "admin";
         $password = gofast_get_admin_pwd();
         $url = 'http://localhost:8080/alfresco/service/set/owner/?reference=' . rawurlencode($ref) . '&user=admin';

         $ch = curl_init();
         curl_setopt($ch, CURLOPT_URL, $url);
         curl_setopt($ch, CURLOPT_RETURNTRANSFER, true);
         curl_setopt($ch, CURLOPT_SSL_VERIFYHOST, FALSE);
         curl_setopt($ch, CURLOPT_SSL_VERIFYPEER, FALSE);
         curl_setopt($ch, CURLOPT_HEADER, 0);
         curl_setopt($ch, CURLOPT_USERPWD, $username . ":" . $password);

         $buffer = curl_exec($ch);
         $buf = strip_tags($buffer);
         $result = trim($buf);
         $result_json = json_decode($result);

       }
  }else{
      // see whether to add the owner field in the list of node properties
  }
}


/**
 * Implements hook_og_membership_insert()
 */
function gofast_og_og_membership_delete( OgMembership $og_membership ) {

  if($og_membership->entity_type != 'user'){
    return;
  }

  //GOFAST-5287 Wheck if the user is still member of the space via userlist
  $userlist_spaces = gofast_userlist_og_get_groups_by_user(user_load($og_membership->etid))['node'];
  if(in_array($og_membership->gid, $userlist_spaces, TRUE)){
      return;
  }

  watchdog(' OG MEMBERSHIP_DELETE ', $og_membership->gid . ' - ' . $og_membership->entity_type . ' - ' . $og_membership->etid);

  if(!module_exists('gofast_community')){
      //Let gofast_chat know that we need to remove the user from space rooms
      //gofast_chat_remove_user_from_room($og_membership->etid, $og_membership->gid);
  }

 // the user has just been removed from a group. We must check if he is member of children. if yes, we have to remove him from it
  $children = gofast_og_get_children($og_membership->gid, true, false, true);
  if(count($children) > 0){
      foreach ($children as $key => $nid) {
            // Check if user is owner of sub_space and set admin as new owner
            gofast_og_set_admin_as_owner($nid, $og_membership->etid);

            $membership = og_get_membership('node', $nid, 'user', $og_membership->etid);
            if($membership !== FALSE){
                og_membership_delete($membership->id);
            }
      }
  }
  // Check if user is owner of space and set admin as new owner
  gofast_og_set_admin_as_owner($og_membership->gid , $og_membership->etid);
}

/**
 * Handles OG membership propagation according to user inheritance settings.
 */
function gofast_og_membership_propagate(OgMembership $og_membership) {
  if($og_membership->state == '2'){
    return;
  }
  // Membership propagation (user inheritance).
  if (!gofast_og_membership_is_inherited($og_membership)) {
    // Get all spaces that should inherit member (OG ancestors, recursively).
    $all_inherited = gofast_og_get_inherited_spaces($og_membership->gid, TRUE);
    if (!empty($all_inherited)) {
      // Register a membership propagation event so that we can check on it
      // later when granting user roles.
      $eid = "og_membership|{$og_membership->entity_type}|{$og_membership->etid}";
      $info = array(
        'action' => 'insert',
        'gid' => $og_membership->gid,
        'inherited' => array_keys($all_inherited)
      );
      _gofast_entity_last_events(array($eid, array($og_membership->id => $info)));
    }
  }

  /**
   * @todo
   *  Check what happens when user is explicitly subscribed into a space and its
   *  parent space(s): in this case a membership gid could be matched with an
   *  inherited space even though such a space has been explicitly subcribed a
   *  user...
   */

  // Propagate membership to the closer (one level up/down) inherited space(s).
  $inherited = gofast_og_get_inherited_spaces($og_membership->gid, FALSE);
  foreach ($inherited as $space) {
    if($og_membership->entity_type == 'user'){
      gofast_og_subscribe_user($space->nid, $og_membership->etid);
    }else if($og_membership->entity_type == 'userlist'){
      gofast_og_subscribe($space->nid, $og_membership->etid, 'userlist', 'og_userlist_node', OG_STATE_ACTIVE);
    }
  }
}

/**
 * Check whether an OG membership BEING SAVED is inherited from another or not.
 * If not, and if user inheritance is set for the corresponding space, then the
 * membership should be propagated to the parent/sub spaces.
 *
 * @param OgMembership $og_membership
 *  An OgMembership object to check.
 *
 * @return boolean
 *  TRUE if the given OgMembership is inherited from another, FALSE otherwise.
 */
function gofast_og_membership_is_inherited(OgMembership $og_membership) {
  $inherited = FALSE;
  $_events = _gofast_entity_last_events();
  $eid = "og_membership|{$og_membership->entity_type}|{$og_membership->etid}";
  if (isset($_events[$eid])) {
    // One or more OG membership have been created for this user within the
    // same page request, we must compare them with the current one and check
    // if it is related to user inheritance or regular OG subscription.
    foreach ((array)$_events[$eid] as $ogm_id => $event) {
      if ($event['action'] === 'insert' && in_array($og_membership->gid, $event['inherited'])) {
        $inherited = TRUE;
        break;
      }
    }
  }
  return $inherited;
}

/**
 * Returns spaces that should inherit members of the space given by $gid,
 * according to the value of OG_USER_INHERITANCE_FIELD.
 *
 * @param int $gid
 *  An organic group node id.
 *
 * @param boolean $recursive [optional]
 *  Whether to fetch only one level up/down or the entire hierarchy. Defaults
 *  to FALSE.
 *
 * @param boolean $flat [optional]
 *  Whether to return a flat list or a hierachical list. Defaults to TRUE.
 *
 * @return Array
 *  An array of OG nodes keyed by node id, or an empty array.
 */
function gofast_og_get_inherited_spaces($gid, $recursive = FALSE, $flat = TRUE) {
  $inherited = array();
  $wrapper = entity_metadata_wrapper('node', $gid);
  $inheritance = empty($wrapper->{OG_USER_INHERITANCE_FIELD}) ? OG_USER_INHERITANCE_DEFAULT : $wrapper->{OG_USER_INHERITANCE_FIELD}->value();

  switch ($inheritance) {
    case OG_USER_INHERITANCE_PARENT:
      if ($recursive === TRUE) {
        $inherited = gofast_og_get_ancestors($wrapper->value(), TRUE, $flat);
      }
      else {
        $og_parent = _gofast_og_space_get_parent($wrapper->value(), TRUE);
        if (isset($og_parent->nid)) {
          $inherited[$og_parent->nid] = $og_parent;
        }
      }
      break;

    case OG_USER_INHERITANCE_SUBGROUP:
      $inherited = gofast_og_get_children($wrapper->getIdentifier(), $recursive, TRUE, $flat);
      break;

    case OG_USER_INHERITANCE_NONE:
    default: // Nothing to do.
  }

  return $inherited;
}

/**
 * Returns the default value that should be used for the field
 * GOFAST_OG_CONTENT_VISIBILITY on an entity.
 *
 * @param $node
 *   The node object for the operation.
 */
function _gofast_og_content_visibility($node) {
  $visibility = GOFAST_OG_CONTENT_ACCESS_DEFAULT;

  /*
  If the content access policy comes to vary according to bundle field
  instance settings, we should load from field_api:

    list ($id, $vid, $bundle_name) = entity_extract_ids('node', $entity);

    // Default visibility according to the current state of the entity.
    $field = field_info_field(GOFAST_OG_CONTENT_VISIBILITY);
    $instance = field_info_instance('node', GOFAST_OG_CONTENT_VISIBILITY, $bundle_name);
    $visibility = field_get_default_value('node', $entity, $field, $instance)[0]['value'];
  */

  //Commented out, see GOFAST-2800
  /*if (isset($node->nid)) {
    // Load entity's parents space
    $parents = _gofast_og_content_get_parents($node, TRUE);
    if (!$parents) {
      watchdog('Gofast OG', 'The given entity has no reference to OG node, set content access field to default.', NULL, WATCHDOG_ERROR);
    }
    else {
      foreach ($parents as $nid => $_node) {
        // We consider a content as public if any of its parent space is public.
        if (gofast_og_is_public($_node)) {
          $visibility = GOFAST_OG_CONTENT_ACCESS_PUBLIC;
          break;
        }
      }
    }
  }*/

  $items = array(
    array('value' => $visibility)
  );

  return $items;
}

/**
 * Implements hook_field_access().
 */
function gofast_og_field_access($op, $field, $entity_type, $entity, $account) {
  if (empty($entity)) {
    // We are in field settings page.
    return;
  }

  // OG Technical fields that should not be accessible to users.
  $og_fields = array(
    OG_USER_INHERITANCE_FIELD,
    OG_DEFAULT_ACCESS_FIELD,
    OG_ACCESS_FIELD
  );

  if (in_array($field['field_name'], $og_fields)) {
    return FALSE;
  }

  if ($op != 'edit') {
    return;
  }

  // A user should not be able to edit space membership field on an entity if
  // he has no permission to edit this entity (handled by core/og modules). We
  // also deny access if the user has no administer permissions in any other
  // referenceable spaces.
  if ($field['field_name'] === GOFAST_OG_PARENT_GROUP_FIELD && $entity_type === 'node') {
        $referenceable = gofast_og_get_referenceable_spaces($entity, $account);
        if (empty($referenceable)) {
          return FALSE;
        }
    }

  if ($field['field_name'] === GOFAST_OG_CONTENT_VISIBILITY) {
    list ($id, $vid, $bundle_name) = entity_extract_ids($entity_type, $entity);
    $instance = field_info_instance($entity_type, $field['field_name'], $bundle_name);
    if (!empty($instance['widget']['settings']['gofast_hide'])) {
      return FALSE;
    }
  }
}

/**
 * Implements hook_form_BASE_FORM_ID_alter().
 */
function gofast_og_form_node_form_alter(&$form, &$form_state, $form_id) {
  global $user;
  if ($user->uid == 1) {

    return;
  }
  $node = $form['#node'];
  $space_types = gofast_og_node_types();

  $form_type = in_array($node->type, gofast_og_content_bundles($space_types)) ? 'space content' :
          (in_array($node->type, array_keys($space_types)) ? 'space' : NULL);

  switch ($form_type) {
    case 'space content':
      $wrapper = entity_metadata_wrapper('node', $node);
      // Content visibility.
      $value = $wrapper->{GOFAST_OG_CONTENT_VISIBILITY}->value();
      array_unshift($form['#submit'], 'gofast_og_content_visibility_submit');

      gofast_userlist_og_node_form_alter($form, $form_state, $form_id);

      // OG membership.
      $og_field = &$form[GOFAST_OG_CONTENT_MEMBERSHIP_FIELD];
      if (!empty($og_field[LANGUAGE_NONE][0]['default']['#options'])) {
        $og_options = &$og_field[LANGUAGE_NONE][0]['default']['#options'];
        // Parent spaces #options are aready filtered via OG field access.
        // However we have to exclude root spaces except private spaces because
        // they can't contain content but only child spaces.
        $root_spaces = gofast_og_get_root_spaces(FALSE, TRUE);
        foreach ($og_options as $space_type => &$item) {
          if ($space_type === '_none')
            continue;
          if (!is_array($item)) {
            if (in_array($space_type, $root_spaces)) {
              unset($og_options[$space_type]);
            }
            continue;
          }
          foreach ($item as $nid => $label) {
            if (in_array($nid, $root_spaces)) {
              unset($og_options[$space_type][$nid]);
            }
          }
          if (empty($item)) {
            unset($og_options[$space_type]);
          }
        }
      }

      break;

    case 'space':
      $space_type = $node->type;
      $space_type_l = $space_types[$space_type];

      // Flag the form to tell ZTree that root spaces can be selected.
      $form['root_space_selection'] = array(
        '#type' => 'hidden',
        '#value' => TRUE
      );

      $form['space_logo'] = array(
        '#type' => 'file',
        '#title' => t('Import a custom space logo', array(), array('context' => 'gofast:gofast_og')),
        '#description' => t('Maximum size : !filesize', array('!filesize' => '2M'), array('context' => 'gofast')),
        '#default_value' => isset($form['#node']->space_logo) ? $form['#node']->space_logo : '',
        '#required' => FALSE,
        '#size' => 20,
      );

      //add translation function
      $form['body'][LANGUAGE_NONE][0]['#title'] = t('Home page', array(), array('context' => 'gofast:gofast_og'));
      $form['field_description'][LANGUAGE_NONE][0]['value']['#title'] = t('Description', array(), array('context' => 'gofast:gofast_og'));
      $form['field_description'][LANGUAGE_NONE][0]['#title'] = t('Description', array(), array('context' => 'gofast:gofast_og'));
      // Summary text description.
      $form['body'][LANGUAGE_NONE][0]['#description'] = t('Content of this field will be displayed on the home page of this space.', array(), array('context' => 'gofast:gofast_og'));

      if (!gofast_og_is_user_private_space($node)) {
        // Adds a validate handler to limit children depth.
        array_unshift($form['#validate'], 'gofast_og_form_validate_child_depth');

        // Adds a submit handler to maintain menu item. Private spaces are not
        // concerned, router item will resolve the node id but the link config
        // remains static.
        array_unshift($form['#submit'], 'gofast_og_form_submit_menu_item');
      }

      $og_field = &$form[GOFAST_OG_PARENT_GROUP_FIELD];
      if ($og_field['#access'] && !empty($og_field[LANGUAGE_NONE][0]['default']['#options'])) {
        // Parent spaces #options are aready filtered via OG field access.
        // However we also need to filter some values according to the current
        // space type, so that users can't register a Group in a Private Space.
        $og_options = &$og_field[LANGUAGE_NONE][0]['default']['#options'];

        // Root space cannot have a parent.
        if (gofast_og_is_root_space($node)) {
          $og_options = array('_none' => $og_options['_none']);
          $og_field['#description'] = t('This space is a root space, it cannot have parent.', array(), array('context' => 'gofast:gofast_og'));
          $og_field['#disabled'] = TRUE;
        } else {
          // Narrow the #options array so that only a referenceable space can be
          // selected (not the node we're editing nor one of its descendants).
          // We know $referenceables is not empty at this stage otherwise #access
          // would be denied.
          $account = $GLOBALS['user'];
          $referenceables = gofast_og_get_referenceable_spaces($node, $account);
          array_walk($referenceables, function(&$v) {
            $v = $v->title;
          });
          $og_options = array($space_type_l => $referenceables);

          if (!isset($node->nid) || $node->nid == "new") {

            $from_parent = isset($_GET["parent"]) ? TRUE : FALSE;
            $parent_nid = null;
            if ($from_parent) {
              $parent_nid = $_GET["parent"];
              $default = $parent_nid;
              $og_field[LANGUAGE_NONE][0]['default']['#default_value'] = array($default);
            } else {
              // Creating a new space : if user is an adm set the root space as
              // default, otherwise set the first referenceable space.
              $default = gofast_user_is_adm($account) ? gofast_og_get_root_space($node) : key($referenceables);
              $og_field[LANGUAGE_NONE][0]['default']['#default_value'] = array($default);
            }
          } else {
            if (isset($_POST['allow_display_locations'])) {
              $og_field['#description'] = t('Note: Some nodes are hidden because you cannot set the parent of this group to be the group itself or one of its children.'
                  , array(), array('context' => 'gofast:gofast_og'));
              if ($node->og_group_ref[LANGUAGE_NONE][0]["target_id"]) {
                $root_node = node_load($node->og_group_ref[LANGUAGE_NONE][0]["target_id"]);
                $og_field[LANGUAGE_NONE][0]['default']["#default_value"] = $root_node->nid;
              }
            } else {
              $og_field['#attributes']['class'][] = "gofast_display_none";
            }
          }
        }
      } else {
        // User has no access to OG field so we have to explicitly set the value
        // to either reference the current parent space or the bundle root space
        // on creation to prevent validation error on form submission "You must
        // select one or more groups for this content".
        $value = isset($node->nid) ? _gofast_og_space_get_parent($node) : gofast_og_get_root_space($node);
        $og_field[LANGUAGE_NONE][0]['default']['#value'] = array($value);

        if(node_access("update", $node)){
          $command[] = gofast_command_toast_message(t("You can not move this space, because you do not administer other space of the same kind (%space_kind) where you can move it on.", array('%space_kind'=> $node->type), array("context" => "gofast")), 'error');
          print ajax_render($command);
          exit;

        }else{
          if($_SERVER['HTTP_X_REQUESTED_WITH'] === 'XMLHttpRequest'){
            $command[] = gofast_command_toast_message(t("You are not allowed to perform this operation.", array(), array("context" => "gofast")), 'error');
            print ajax_render($command);
          }else{
            header('Location: /');
          }
          exit;
        }
      }
      //Set the content visibility
      //See GOFAST-2800
      $form[GOFAST_OG_CONTENT_VISIBILITY][LANGUAGE_NONE]['#default_value'] = (string) GOFAST_OG_CONTENT_ACCESS_DEFAULT;
      // Adds a submit handler for the parent space membership.
      array_unshift($form['#validate'], 'gofast_og_form_validate_membership');
  }

  // Override display properties.
  $og_field['#type'] = 'fieldset';
  if ($form_type === 'space content') {
    $og_field['#title'] = t('File Location/Sharing', array(), array('context' => 'gofast'));
  } else if ($form_type === 'space') {
    $og_field['#title'] = t('Location/Sharing', array(), array('context' => 'gofast'));

    ## create template folder ztree
    $form['og_ztree_templates_folder'] = array(
      '#type' => 'fieldset',
      '#title' => t('Add folder(s) template(s)'),
      '#collapsible' => TRUE,
      '#collapsed' => TRUE,
      '#weight' => 50,
      '#keen-accordion' => TRUE,
    );

     $form['og_ztree_templates_folder']['description'] = array(
	  '#markup' => '<h5>'
	  . t('Choose the folder template you want to implement in the selected space: ')
	  . '</h5>'
	  . '<span>'
	  . t('(Unfold the tree to discover the pattern of the template)')
	  . '</span>'
    );


    $from_template = isset($_GET["template"]) ? TRUE : FALSE;
    $param_path = parse_url($_SERVER['HTTP_REFERER']);
    parse_str($param_path['query'], $drupal_path);
    $template_nid = null;
    if ($from_template) {
      $template_nid = $_GET["template"];
    }
    if (!empty($drupal_path['path'])) {
      $form['og_ztree_templates_folder']['#path'] = $drupal_path['path'];
    }
    // This is for the user defined templates
      $form['og_ztree_templates_folder']['ztree_templates'] = array();
      $form['og_ztree_templates_folder']['ztree_templates']['#attributes'] = array(
	'class' => array('ztree_template_folder_class')
      );
      $templates_options = gofast_cmis_get_folder_templates_option();

      ## check alfresco status
      if (gofast_cmis_check_alfresco_status()) {

	  $available_templates = $templates_options;
	  $list_templates = array();
	  $selected = array();
	  foreach ($available_templates as $value) {
        $path = $value['path'];
        $key = $value['id'];
        $list_templates[$path] = urldecode(str_replace('/webdav', '', $path));
        if (!empty($value['descendants'])) {
          $list_templates = array_merge($list_templates, $value['descendants']);
        }
        if ($from_template && $value->nid == $template_nid) {
          $selected['name'] = array_shift(explode('.', $value['name']));
        }
      }


	  ## store all folders templates in the form
	  $form['og_ztree_templates_folder']['templates'] = array(
	    '#type' => 'select',
	    '#multiple' => TRUE,
	    '#name' => 'templates',
	    '#options' => gofast_ztree_get_drupal_path_from_webdav_path($list_templates),
	    '#attributes' => array(
	      'class' => array('gofast_display_none')
	    )
	  );

	  if (empty($list_templates)) {
	    $form['og_ztree_templates_folder']['empty_ztree_templates'] = array(
	      '#markup' => t('There is no templates available yet.', array(), array('context' => 'gofast:gofast_cmis')),
	    );
	    $form['og_ztree_templates_folder']['empty_ztree_templates']['#group'] = 'group_template_file';
	    $form['og_ztree_templates_folder']['#groups']['group_template_file']->children[] = 'empty_ztree_templates';
	    $form['og_ztree_templates_folder']['#group_children']['empty_ztree_templates'] = 'group_template_file';
	  }

	  $form['og_ztree_templates_folder']['ztree_templates']['#group'] = 'group_template_file';
	  $form['og_ztree_templates_folder']['#groups']['group_template_file']->children[] = 'ztree_templates';
	  $form['og_ztree_templates_folder']['#group_children']['ztree_templates'] = 'group_template_file';

	  $form['og_ztree_templates_folder']['templates']['#group'] = 'group_template_file';
	  $form['og_ztree_templates_folder']['#groups']['group_template_file']->children[] = 'templates';
	  $form['og_ztree_templates_folder']['#group_children']['templates'] = 'group_template_file';
      }

      // This is for vertical tab reorganization
      $form['og_ztree_templates_folder']['empty_template']['#group'] = 'group_empty_file';
      $form['og_ztree_templates_folder']['#groups']['group_empty_file']->children[] = 'empty_template';
      $form['og_ztree_templates_folder']['#group_children']['empty_template'] = 'group_empty_file';

    $form['og_ztree_templates_folder']['#after_build'][] = 'gofast_ztree_after_build';
    $form['og_ztree_templates_folder']['#weight'] = 9;
    $form['og_ztree_templates_folder']['#after_build'][] = 'gofast_ztree_folders_templates_after_build';
  } else {
    $og_field['#title'] = t('Location/Sharing', array(), array('context' => 'gofast'));
  }
  unset($og_field[LANGUAGE_NONE]['#title'], $og_field[LANGUAGE_NONE][0]['default']['#title']);
  //remove the field_archive from forms
  $form["field_archive"]["#access"] = false;
  $form["field_mail_ulid"]["#access"]=false;
  $form["field_mail_subspace_nid"]["#access"]=false;

  $form['#attributes']['class'][] = 'GofastForm';
  $form['#validate'][] = 'gofast_og_form_node_form_validate';

}

function gofast_og_form_node_form_validate(&$form, &$form_state) {
    $errors = form_get_errors();
    if ($errors) {
      // Clear errors.
      form_clear_error();

      foreach ($errors as $name => $error_message) {
        $commands[] = gofast_command_toast_message($error_message, "error");
      }
      print ajax_render($commands);exit;
    }
}

/**
 *
 * @param type $node
 * @return full path of an og
 */
function gofast_og_get_ancestors_path($node) {
    $prefix = '_';
    $suffix = '/';

    if(gofast_og_is_user_private_space($node)) {
        return('/Sites/' . $prefix .$node->name);
    }

    if(gofast_og_is_root_space($node)) {
        return('/Sites/' . $prefix .$node->title);
    }

    $path = $prefix . $node->{title};

    $parent = node_load(gofast_og_get_parent($node));
    if(isset($parent)) {
        $path = $prefix . $parent->{title} . $suffix . $path;
        $ancestors = gofast_og_get_ancestors($node)[$parent->{nid}]['ancestors'];
        foreach($ancestors as $ancestor) {
            $path = $prefix . node_load($ancestor)->{title} . $suffix . $path;
        }
    }

    return('/Sites/' . $path);
}



/**
 *
 * @param type $form
 * @param type $form_state
 */
function gofast_og_add_article_homepage($node){

    $content = isset($node->{body}[LANGUAGE_NONE][0]['value']) ? $node->{body}[LANGUAGE_NONE][0]['value'] : " ";
    $content = gofast_cmis_ckeditor_classes_to_style($content);
    $article_content = gofast_cmis_ckeditor_smiley_path_update($content);
    $article_title =  $node->title.".html" ;
    $mimetype = "text/html";
    $path = gofast_og_get_ancestors_path($node) . '/Wikis';
    $emplacement = gofast_cmis_item_get_by_path($path)->{id};

    $inserted_article = gofast_cmis_item_content_insert($emplacement, $article_title, $article_content, $mimetype, array(), TRUE);

    if (!isset($inserted_article->id)) {
        //Print something if needed
        return;
    }
    $article_reference = $inserted_article->properties['alfcmis:nodeRef'];
    //Cancel replication
    variable_set("cmis_creating_" . $article_reference, "true");

    $size_brute = $inserted_article->properties["cmis:contentStreamLength"];
    $size = $size_brute / 1024 / 1024;
    if ($size > 50) { //File is too large to autodetect language
        $language = LANGUAGE_NONE;
    }else{
        $language = gofast_cmis_item_detect_document_language($article_reference, user_load_by_name($person));
    }
    $person = $node->uid;
    $created = strtotime($inserted_article->properties['cmis:creationDate']);
    $status = 1;
    $private = 0;

    $query = db_select('node');
    $query->addExpression('MAX(nid)');
    $gid = $query->condition('type', $node->type)->execute()->fetchField();

    $node_article = gofast_cmis_create_article_node_programmatically($article_reference, $article_content, $person, $article_title, $status, $language, $private, $gid, $emplacement, $created);
    if($node_article == null || $node_article == false){
        $msg = "Insertion failed";
    }else $msg = "Insertion success";
    //watchdog("article_prog_creation", $msg);
    
    //Apply special permissions, only allow the space administrators to edit this document
    gofast_cmis_webservice_item_assign_homepage_permissions($article_reference, [$node->nid]);
}


/** @deprecated, use gofast_og_get_article_homepage_from_og instead */
function gofast_og_get_article_homepage($node) {
    // force use of gofast_og_get_article_homepage_from_og
    return node_load(gofast_og_get_article_homepage_from_og($node->nid));
    $query = db_select('node', 'n')->fields('n');
    $article_id = $query->condition('title', $node->title.".html")->execute()->fetchAssoc();

    $article_node = isset($article_id['nid']) ? node_load($article_id['nid']) : null;
    return $article_node;
}


function gofast_og_move_space_form($form, &$form_state){
  $node = isset($form_state['build_info']['args'][0]->nid) ? $form_state['build_info']['args'][0] : FALSE;
  $form_state['node'] = $node;

  //We need to load the og_group_ref field from this node's edit form to give it to ztree
  $node_edit_form = drupal_get_form($node->type . "_node_form", $node);
  $field = $node_edit_form['og_group_ref'];
  $form['og_group_ref'] = $field;

  gofast_ztree_form_alter($form, $form_state);
  $form['#after_build'][] = 'gofast_ztree_after_build';

  $form['submit'] = array(
      '#type' => 'submit',
      '#value' => t('Move this space', array(), array('context' => 'gofast')),
      '#prefix' => "<div style='clear:both;'></div>",
      '#suffix' => "<p style='display: inline; margin-left:10px;'>"
                    . "<strong style='color:red;'>". t("Warning", array(), array('context' => 'gofast:gofast_og')) ."</strong> : ". t("You are going to move this space with all it's content, memberships and sub spaces to another location. This operation may take a long time and cannot be cancelled.", array(), array('context' => 'gofast:gofast_og')) .""
                 . "</p>",
      '#attributes' => array('class' => array("btn-success")),
      '#weight' => 10
  );

  return $form;
}

function gofast_og_move_space_form_submit($form, &$form_state){
  $new_parent_id = $form_state['input']['og_group_ref'][LANGUAGE_NONE][0]['default'];
  $space_node = $form['og_group_ref'][LANGUAGE_NONE][0]['#entity'];
  $old_parent_id = $space_node->og_group_ref[LANGUAGE_NONE][0]['target_id'];

  //Compare old parent and selected parent, return condition
  if(!is_numeric($old_parent_id) || !is_numeric($new_parent_id) || $new_parent_id == $old_parent_id){
      return;
  }

  //Retrieve the old and new parent nodes
  $new_parent_node = node_load($new_parent_id);
  $old_parent_node = node_load($old_parent_id);

  //Create an operation variable to store in drupal variables
  $operation_state = array(
      'space_node' => $space_node,
      'old_parent_node' => $old_parent_node,
      'new_parent_node' => $new_parent_node,
      'step' => "1_1"
  );
  variable_set("moving_space_" . $space_node->nid, $operation_state);

  //Prepare the commands to send to the browser
  $commands = array();
  $commands[] = ctools_modal_command_display(t("Moving your space", array(), array('context' => 'gofast:gofast_og')), theme("gofast_og_moving_space", $operation_state));

  print ajax_render($commands);

  //Kill the apache session and release the loading page to the user
  fastcgi_finish_request();

  //Process the operation
  set_time_limit(0);
  gofast_og_move_space($space_node, $old_parent_node, $new_parent_node);
}

function gofast_og_move_space($space_node, $old_parent_node, $new_parent_node){
    //Retrieve the operation variable
    $operation_state = variable_get("moving_space_" . $space_node->nid, array());

    if(empty($operation_state)){
        //Something is wrong, we should not move this space
        watchdog("og_move_space", "We should not move " . $space_node->nid, array(), WATCHDOG_ERROR);
        return;
    }

    watchdog("MOVING SPACE", "$space_node->nid from $old_parent_node->nid to $new_parent_node->nid");

    //Step 1_1 : Check parents, move folder, check parents again
    $space_item_id = gofast_cmis_get_raw_item_id(gofast_cmis_node_get_item_id($space_node));
    $cached_item = &gofast_cmis_static_cache($space_item_id . '_parents');
    $cached_item = null;
    $space_item = gofast_cmis_item_get_object_parent($space_item_id);
    $current_parent = array_keys($space_item->objectsById)[0];

    //Exit condition : unable to retrieve current parent
    if(empty($current_parent) || $current_parent != gofast_cmis_get_raw_item_id(gofast_cmis_node_get_item_id($old_parent_node))){
        watchdog("MOVING SPACE ROLLBACK", "$space_node->nid from $old_parent_node->nid to $new_parent_node->nid");
        $operation_state['step'] = "error";
        variable_set("moving_space_" . $space_node->nid, $operation_state);

        //Let the front end knows there was an error
        sleep(10);

        //Delete the Drupal variable to inform that the process is finished
        variable_del("moving_space_" . $space_node->nid);
        return;
    }

    gofast_cmis_node_edit_item_move($space_node, $old_parent_node, $new_parent_node, TRUE);

    $cached_item = &gofast_cmis_static_cache($space_item_id . '_parents');
    $cached_item = null;
    $space_item = gofast_cmis_item_get_object_parent($space_item_id);
    $current_parent = array_keys($space_item->objectsById)[0];

    //Exit condition : Unsuccessfull move, rollback transaction
    if(empty($current_parent) || $current_parent != gofast_cmis_get_raw_item_id(gofast_cmis_node_get_item_id($new_parent_node))){
        watchdog("MOVING SPACE ROLLBACK 2", "$space_node->nid from $old_parent_node->nid to $new_parent_node->nid");

        //Rollback the transaction
        gofast_cmis_node_edit_item_move($space_node, $new_parent_node, $old_parent_node, TRUE);

        $operation_state['step'] = "error";
        variable_set("moving_space_" . $space_node->nid, $operation_state);

        //Let the front end knows there was an error
        sleep(10);

        //Delete the Drupal variable to inform that the process is finished
        variable_del("moving_space_" . $space_node->nid);
        return;
    }

    $cached_item = &gofast_cmis_static_cache($space_item_id . '_parents');
    $cached_item = null;
    $space_item = gofast_cmis_item_get_object_parent($space_item_id);
    $new_parent = array_keys($space_item->objectsById)[0];

    $operation_state['step'] = "1_2";
    variable_set("moving_space_" . $space_node->nid, $operation_state);

    //Step 1_2 Move space drupal node
    $space_node->og_group_ref[LANGUAGE_NONE][0]['target_id'] = $new_parent_node->nid;
    node_save($space_node);

    sleep(5);

    $new_space_node = node_load($space_node->nid);

    //Exit condition : Parent change has failed, rollback
    if($space_node->og_group_ref['und'][0]['target_id'] != $new_parent_node->nid){
        watchdog("MOVING SPACE ROLLBACK 3", "$space_node->nid from $old_parent_node->nid to $new_parent_node->nid");

        //Rollback the transaction
        $space_node->og_group_ref[LANGUAGE_NONE][0]['target_id'] = $old_parent_node->nid;
        node_save($space_node);
        gofast_cmis_node_edit_item_move($space_node, $new_parent_node, $old_parent_node, TRUE);

        $operation_state['step'] = "error";
        variable_set("moving_space_" . $space_node->nid, $operation_state);

        //Let the front end knows there was an error
        sleep(10);

        //Delete the Drupal variable to inform that the process is finished
        variable_del("moving_space_" . $space_node->nid);
        return;
    }

    $operation_state['step'] = "2_1";
    variable_set("moving_space_" . $space_node->nid, $operation_state);

    //Step 2_1 Change documents locations
    $previous_path = gofast_cmis_space_get_webdav_path($old_parent_node->nid)."/_".$space_node->title;
    $new_path = gofast_cmis_space_get_webdav_path($new_parent_node->nid)."/_".$space_node->title;
    gofast_cmis_node_update_emplacements($previous_path, $new_path);

    //Delete the Drupal variable to inform that the process is finished
    variable_del("moving_space_" . $space_node->nid);
}

function gofast_og_print_move_status($nid){
    print variable_get("moving_space_" . $nid, array())["step"];
    exit;
}

function gofast_og_print_archive_status($nid){
    print variable_get("archiving_space_" . $nid, array())["step"];
    exit;
}

function gofast_og_print_unarchive_status($nid){
    print variable_get("unarchiving_space_" . $nid, array())["step"];
    exit;
}

/**
 * Validate handler.
 *
 *  Throws an error if a space is created as a child of a space that has reached
 *  the maximum depth in the space tree (9 items allowed under "Spaces").
 */
function gofast_og_form_validate_child_depth(&$form, &$form_state) {
  if (!isset($form_state['values'][GOFAST_OG_PARENT_GROUP_FIELD][LANGUAGE_NONE][0]['target_id'])) {
    return;
  }

  $pgid = $form_state['values'][GOFAST_OG_PARENT_GROUP_FIELD][LANGUAGE_NONE][0]['target_id'];
  $plid = gofast_get_mlid_by_path('node' . $pgid);
  $p_menu = menu_link_load($plid);

  if ($p_menu['p9'] === $plid) {
    // Parent space has already reached the maximum space depth.
    $error = t('You cannot add a child space in the selected target space because it would be out of '
              .'the maximum space depth (9 levels under "Spaces").', array(), array('context' => 'gofast:gofast_og')).
    form_set_error(GOFAST_OG_PARENT_GROUP_FIELD, $error);
  }
}

/**
 * Space form validate handler.
 */
function gofast_og_form_validate_membership(&$form, &$form_state) {
  if (!isset($form_state['values'][GOFAST_OG_PARENT_GROUP_FIELD][LANGUAGE_NONE][0]['target_id'])) {
    return;
  }

  $node = $form['#node'];
  $og_field = &$form_state['values'][GOFAST_OG_PARENT_GROUP_FIELD][LANGUAGE_NONE][0];
  $parent_gid = _gofast_og_space_get_parent($node);

  // User permissions on the selected space node.
  $update_perm = og_user_access('node', $og_field['target_id'], "update any {$node->type} content");
  if (!$update_perm && $og_field['target_id'] === $parent_gid) {
    // User has 'edit' access on the $node but not on the parent target. In such
    // cases, OgBehaviorHandler::validate() invalidates the form. But since the
    // selected target stay the same as the current parent space, we do not
    // consider this scenario as an update for the target node. This hack will
    // prevent OgBehaviorHandler from raising an error (GOFAST-2212).
    $og_field['field_mode'] = 'admin';
  }
}

/**
 * Space form submit handler that maintains "Spaces" menu tree.
 */
function gofast_og_form_submit_menu_item(&$form, &$form_state) {
  $menu = &$form_state['values']['menu'];

  // Always reflect title updates in the corresponding menu item.
  $menu['link_title'] = $form_state['values']['title'];

  if (!isset($form_state['values'][GOFAST_OG_PARENT_GROUP_FIELD][LANGUAGE_NONE][0]['target_id'])) {
    // gofast_og_create() has already set the menu config, or there is no parent
    // space to set as a menu link.
    return;
  }

  // Retrieve the plid from the parent gid path.
  $pgid = $form_state['values'][GOFAST_OG_PARENT_GROUP_FIELD][LANGUAGE_NONE][0]['target_id'];
  $plid = gofast_get_mlid_by_path('node/' . $pgid);

  // Set menu config and let core module handle database updates.
  //menu system has changed, it is dynamically constructed
  //https://srv01.ceo-vision.com/jira_new/browse/GOFAST-2961
  $menu['enabled'] = 0;
  $menu['parent'] = 'main-menu:' . $plid;

  // Menu link expansion.
  $p_menu = menu_link_load($plid);
 // if ($p_menu['p8'] !== $plid) {
    // Always set these settings as long as the parent item has a room for a
    // possible space child.
    $menu['has_children'] = 1;
    $menu['expanded'] = 1;
 // }
  //menu system has changed, it is dynamically constructed
  //https://srv01.ceo-vision.com/jira_new/browse/GOFAST-2961
    unset($form_state['values']['menu']);

  $destination = 'public://space_logos/';
  file_prepare_directory($destination, FILE_CREATE_DIRECTORY);

  if (isset($_FILES["files"]["size"])) {
    $parts = pathinfo($_FILES['files']['name']['space_logo']);
    // a predictable filename facilitates direct retrieve of file info from db
    $_FILES['files']['name']['space_logo'] = $form_state['values']['title'] . '.' . $parts['extension'];
  
    $validators['file_validate_extensions'] = array('png jpg jpeg webp');
    // actual upload
    if ($file = file_save_upload('space_logo', $validators, $destination, FILE_EXISTS_REPLACE)) {
      $file->status = FILE_STATUS_PERMANENT;
      file_save($file);
      $form_state['values']['field_logo_uri'][LANGUAGE_NONE][0]['value'] = $file->uri;
    }
  }
}

/**
 * Implements hook_menu()
 */
function gofast_og_menu() {
   $items = array();

  // Autocomplete path to find users members of a group
  $items['gofast_og_user_autocomplete'] = array(
    'page callback' => 'gofast_og_user_autocomplete',
    'access arguments' => array('access content'),
    'access callback' => 'user_access',
    'type' => MENU_CALLBACK,
  );

  $items['gofast_og_space_user_userlist_preadd_autocomplete'] = array(
    'page callback' => 'gofast_og_space_user_userlist_preadd_autocomplete',
    'access arguments' => array('access content'),
    'access callback' => 'user_access',
    'type' => MENU_CALLBACK,
  );

  // OG members listing pages.
  $items['spaces/%ctools_js/%/%/admin/people'] = array(
    'title callback' => 'og_ui_menu_title_callback',
    'title arguments' => array('People in space @group', 2, 3),
    'description' => 'Find and manage group members.',
    'page callback' => 'gofast_og_admin_account',
    'page arguments' => array(1, 2, 3),
    'access callback' => 'og_ui_user_access_group',
    'access arguments' => array('manage members', 2, 3),
    'type' => MENU_CALLBACK,
    'file' => 'gofast_og.admin.inc',
  );

  // Edit a single membership.
  $items['spaces/%ctools_js/%/%/admin/people/edit-membership/%og_membership'] = array(
    'title callback' => 'og_ui_menu_title_callback',
    'title arguments' => array('Edit membership in space @group', 2, 3),
    'type' => MENU_CALLBACK,
    'page callback' => 'gofast_og_edit_membership',
    'page arguments' => array(1, 2, 3, 7),
    'access callback' => 'og_ui_user_access_group',
    'access arguments' => array('manage members', 2, 3),
    'file' => 'gofast_og.admin.inc',
  );

  // Instant edit a single membership.
  $items['spaces/%ctools_js/%/%/admin/%/instant-edit-membership/%og_membership/%'] = array(
    'title callback' => 'og_ui_menu_title_callback',
    'title arguments' => array('Instant edit membership in space @group', 2, 3),
    'type' => MENU_CALLBACK,
    'page callback' => 'gofast_og_instant_edit_membership',
    'page arguments' => array(1, 2, 3, 5, 7, 8),
    'access callback' => 'og_ui_user_access_group',
    'access arguments' => array('manage members', 2, 3),
    'file' => 'gofast_og.admin.inc',
  );

  // Delete a single membership.
  $items['spaces/%ctools_js/%/%/admin/people/delete-membership/%og_membership'] = array(
    'title callback' => 'og_ui_menu_title_callback',
    'title arguments' => array('Remove member from space @group', 2, 3),
    'type' => MENU_CALLBACK,
    'page callback' => 'gofast_og_delete_membership',
    'page arguments' => array(1, 2, 3, 7),
    'access callback' => 'og_ui_user_access_group',
    'access arguments' => array('manage members', 2, 3),
    'file' => 'gofast_og.admin.inc',
  );


  // Accept a membership request.
  $items['spaces/%ctools_js/%/%/admin/people/grant-membership/%og_membership'] = array(
    'title callback' => 'og_ui_menu_title_callback',
    'title arguments' => array('Grant access to @group', 2, 3),
    'type' => MENU_CALLBACK,
    'page callback' => 'gofast_og_grant_membership',
    'page arguments' => array(1, 2, 3, 7),
    'access callback' => 'og_ui_user_access_group',
    'access arguments' => array('manage members', 2, 3),
    'file' => 'gofast_og.admin.inc',
  );

  // Deny a membership request.
  $items['spaces/%ctools_js/%/%/admin/people/deny-membership/%og_membership'] = array(
    'title callback' => 'og_ui_menu_title_callback',
    'title arguments' => array('Deny access to @group', 2, 3),
    'type' => MENU_CALLBACK,
    'page callback' => 'gofast_og_deny_membership',
    'page arguments' => array(1, 2, 3, 7),
    'access callback' => 'og_ui_user_access_group',
    'access arguments' => array('manage members', 2, 3),
    'file' => 'gofast_og.admin.inc',
  );

  // Autocomplete path to filter members of a space.
  $items['gofast/og-member-autocomplete'] = array(
    'page callback' => 'gofast_og_autocomplete_members',
    'access arguments' => array('access content'),
    'access callback' => 'user_access',
    'type' => MENU_CALLBACK,
  );

  /* dreprecated since 3.6.1 */
  $items['space/user_create'] = array(
    'title' => 'Add User Account',
    'access arguments' => array('access content'),
    'access callback' => 'user_access',
    'page callback' => 'gofast_og_user_registration',
    'type' => MENU_LOCAL_TASK,
  );

  $items['space/admin/members'] = array(
    'title' => t('Manage members for spaces', array(), array('context' => array('gofast'))),
    'page callback' => 'gofast_og_admin_members_page',
    'page arguments' => array(TRUE, 'add'),
    'access callback' => 'can_manage_spaces_members',
    'type' => MENU_NORMAL_ITEM,
    'file' => 'gofast_og.admin.inc',
  );

  $items['space/admin/members/%'] = array(
    'title' => t('Manage members for spaces', array(), array('context' => array('gofast'))),
    'page callback' => 'gofast_og_admin_members_page',
    'page arguments' => array(FALSE, 3),
    'access arguments' => array('access content'),
    'access callback' => 'user_access',
    'type' => MENU_NORMAL_ITEM,
    'file' => 'gofast_og.admin.inc',
    'menu_name' => 'navigation',
  );

  $items['space/%ctools_js/admin/members/%'] = array(
    'title' => t('Manage members for spaces', array(), array('context' => array('gofast'))),
    'page callback' => 'gofast_og_admin_members_page',
    'page arguments' => array(1,4),
    'access arguments' => array('access content'),
    'access callback' => 'user_access',
    'type' => MENU_NORMAL_ITEM,
    'file' => 'gofast_og.admin.inc'
  );

  $items['og/list_grid/%'] = array(
    'title' => t('Spaces', array(), array('context' => array('gofast'))),
    'page callback' => 'gofast_og_spaces_view',
    'page arguments' => array(2),
    'access arguments' => array('access content'),
    'access callback' => 'user_access',
    'type' => MENU_NORMAL_ITEM
  );

  $items['og/list_grid'] = array(
    'title' => t('Spaces', array(), array('context' => array('gofast'))),
    'page callback' => 'gofast_og_spaces_view',
    'access arguments' => array('access content'),
    'access callback' => 'user_access',
    'access arguments' => array('access content'),
    'type' => MENU_NORMAL_ITEM
  );

  $items['og/list_grid/ajax/%'] = array(
    'title' => t('Spaces', array(), array('context' => array('gofast'))),
    'page callback' => 'gofast_og_spaces_view_theme_descendants',
    'page arguments' => array(3),
    'access arguments' => array('access content'),
    'access callback' => 'user_access',
    'delivery callback' => 'gofast_og_spaces_view_ajax_theme_descendants',
    'type' => MENU_NORMAL_ITEM
  );

  $items['og/list_grid/ajax/%/%'] = array(
    'title' => t('Spaces', array(), array('context' => array('gofast'))),
    'page callback' => 'gofast_og_spaces_request_action',
    'page arguments' => array(3,4),
    'access arguments' => array('access content'),
    'access callback' => 'user_access',
    'delivery callback' => 'gofast_og_spaces_ajax_request_action',
    'type' => MENU_NORMAL_ITEM
  );

    $items['og/preadd/process'] = array(
    'page callback' => 'gofast_og_preadd_ajax_validation',
    'access arguments' => array('access content'),
    'access callback' => 'user_access',
    'type' => MENU_CALLBACK,
  );

  $items['og/membership/request/%/%'] = array(
    'page callback' => 'gofast_og_membership_request',
    'page arguments' => array(4,3),
    'access arguments' => array('access content'),
    'access callback' => 'user_access',
    'type' => MENU_CALLBACK
  );

  $items['og/api/get/spaces/user/%'] = array(
    'page callback' => 'gofast_og_get_spaces_by_user',
    'page arguments' => array(5, FALSE, TRUE, TRUE),
    'access arguments' => array('access content'),
    'access callback' => 'user_access',
    'type' => MENU_CALLBACK
  );


  $items['og/excel/manage'] = array(
    'title' => t("Mass manage users with Excel file"),
    'page callback' => 'gofast_og_mass_users_import_interface',
    'access callback' => 'user_access',
    'access arguments' => array('administer site configuration'),
    'weight' => 0,
    'type' => MENU_CALLBACK,
  );

  $items['modal/%ctools_js/gofast_og/delete_space/%'] = array(
    'title' => t("Delete this space"),
    'page callback' => 'gofast_og_delete_space',
    'page arguments' => array(4),
    'access callback' => 'gofast_og_can_delete_space',
    'access arguments' => array(NULL, 4),
  );

  $items['gofast_og/delete_space/%/%'] = array(
    'title' => t("Delete this space"),
    'page callback' => 'gofast_og_delete_space_process',
    'page arguments' => array(2,3),
    'access callback' => 'gofast_og_can_delete_space',
    'access arguments' => array(NULL, 2),
    'type' => MENU_CALLBACK,
  );

  $items['space/%/move/status'] = array(
    'title' => "Status",
    'page callback' => 'gofast_og_print_move_status',
    'page arguments' => array(1),
    'access callback' => 'user_access',
    'access arguments' => array('access content'),
    'type' => MENU_CALLBACK,
  );

  $items['space/%/archive/status'] = array(
    'title' => "Status",
    'page callback' => 'gofast_og_print_archive_status',
    'page arguments' => array(1),
    'access callback' => 'user_access',
    'access arguments' => array('access content'),
    'type' => MENU_CALLBACK,
  );

  $items['space/%/unarchive/status'] = array(
    'title' => "Status",
    'page callback' => 'gofast_og_print_unarchive_status',
    'page arguments' => array(1),
    'access callback' => 'user_access',
    'access arguments' => array('access content'),
    'type' => MENU_CALLBACK,
  );

   $items['gofast_og/space_members_async/%'] = array(
    'page callback' => 'gofast_og_space_members_async',
    'type' => MENU_CALLBACK,
    'page arguments' => array(2),
    'access callback' => 'user_access',
    'access arguments' => array('access content'),
  );

   $items['gofast_og/home_async/%'] = array(
    'page callback' => 'gofast_og_home_async',
    'type' => MENU_CALLBACK,
    'page arguments' => array(2),
    'access callback' => 'user_access',
    'access arguments' => array('access content'),
  );


   $items['gofast_og/space_activity_async/%'] = array(
    'page callback' => 'gofast_og_space_activity_async',
    'type' => MENU_CALLBACK,
    'page arguments' => array(2),
    'access callback' => 'user_access',
    'access arguments' => array('access content'),
  );


  $items['gofast_og/%/get_parents'] = array(
    'page callback' => 'gofast_og_get_parents_gids',
    'page arguments' => array(1),
    'access callback' => 'user_access',
    'access arguments' => array('access content'),
    'type' => MENU_CALLBACK,
  );

   $items['gofast_og/%/get_parent_space_path'] = array(
    'page callback' => 'gofast_og_get_parent_space_path',
    'page arguments' => array(1),
    'access callback' => 'user_access',
    'access arguments' => array('access content'),
    'type' => MENU_CALLBACK,
  );

   $items['gofast_og/space/popup/%'] = array(
       'page callback' => 'gofast_og_get_space_popup',
       'page arguments' => array(3),
       'access arguments' => array('access content'),
       'access callback' => 'user_access',
       'delivery callback' => 'gofast_ajax_delivery',
       'type' => MENU_CALLBACK
   );

   $items['modal/%ctools_js/og/%node/contact/admins'] = array(
    'title' => 'Contact administrators',
    'page callback' => 'gofast_og_modal_og_contact_admins',
    'page arguments' => array(1, 3),
    'access callback' => 'user_access',
    'access arguments' => array('contact administrators'),
    'type' => MENU_CALLBACK,
  );

  $items['og/%node/contact/admins'] = array(
    'title' => 'Contact administrators',
    'page callback' => 'gofast_og_contact_admins',
    'page arguments' => array(1),
    'access callback' => 'user_access',
    'access arguments' => array('contact administrators'),
    'type' => MENU_CALLBACK,
  );

  $items['og/is/%/instore'] = array(
    'page callback' => 'gofast_og_is_in_store',
    'page arguments' => array(2),
    'access callback' => 'user_access',
    'access arguments' => array('access content'),
  );

  $items['og/%node/space_logo'] = array(
    'page callback' => 'gofast_og_edit_space_logo',
    'page arguments' => array(1),
    'access callback' => 'user_access',
    'access arguments' => array('access content'),
  );

  $spaces_kind = ["group", "organisation", "public", "extranet"];
  foreach ($spaces_kind as $space_kind) {
    $items["node/add/$space_kind"] = array(
      "page callback" => "gofast_og_node_add_$space_kind",
      "access callback" => "user_access",
      "access arguments" => array("create $space_kind content"),
    );
  }
  return $items;
}

function gofast_og_is_in_store($nid) {
  $node = node_load($nid);
  $cmis_object = gofast_cmis_item_get(gofast_cmis_node_get_item_id($node));
  drupal_json_output($cmis_object->properties["cmis:path"]);
  exit();
}

function gofast_og_node_add_group() { //GOFAST-6992

    $node = new stdClass();
    $node->type = "group";
    $group_node_form = drupal_get_form('group_node_form', $node);
    $content = theme('page_group_node_form', ['form' => $group_node_form]);
    $pageContent = gofast_create_page_content($content);

    return $pageContent;
}

function gofast_og_node_add_organisation() { //GOFAST-7010

    $node = new stdClass();
    $node->type = "organisation";
    $organisation_node_form = drupal_get_form('organisation_node_form', $node);
    $content = theme('page_organisation_node_form', ['form' => $organisation_node_form]);
    $pageContent = gofast_create_page_content($content);

    return $pageContent;
}

function gofast_og_node_add_public() { //GOFAST-7012

    $node = new stdClass();
    $node->type = "public";
    $organisation_node_form = drupal_get_form('public_node_form', $node);
    $content = theme('page_public_node_form', ['form' => $organisation_node_form]);
    $pageContent = gofast_create_page_content($content);

    return $pageContent;
}

function gofast_og_node_add_extranet() { //GOFAST-7013

    $node = new stdClass();
    $node->type = "extranet";
    $group_node_form = drupal_get_form('extranet_node_form', $node);
    $content = theme('page_extranet_node_form', ['form' => $group_node_form]);
    $pageContent = gofast_create_page_content($content);

    return $pageContent;
}

/*
 * Restrict acces to ADM adn ADMIN only
 */
function can_manage_spaces_members(){
  //if($user->name == 'adm' || $user->uid == 1){
  global $user;
  if(gofast_user_is_adm() || gofast_user_is_manager() || $user->uid == 1){
    return TRUE;
  }else{
    return FALSE;
  }
}

/**
 * @Implement HOOK_theme()
 * @return type
 */
function gofast_og_theme(){

  return array(
      'gofast_og_space_admin' => array(
          'template' => 'tpl/gofast_og-admin',
          'variables' => array(
            'action' => 'add'
          )
      ),
    'gofast_og_space_admin_add_members' => array(
      // 'arguments' => array(),
       'render element' => 'form',
       'template' => 'tpl/gofast_og-add-member-form',
     ),
    'gofast_og_space_admin_edit_members' => array(
      // 'arguments' => array(),
      'render element' => 'form',
      'template' => 'tpl/gofast_og-edit-member-form',
    ),
    'gofast_og_preadd_validation' => array(
      'template' => 'tpl/gofast_og-preadd-validation',
    ),
    'gofast_og_spaces_view' => array(
      'template' => 'tpl/gofast_og-spaces-view',
    ),
    'gofast_og_delete_space' => array(
      'template' => 'tpl/gofast_og-delete-space',
    ),
    'gofast_og_mail_add_user_space' => array(
      'template' => 'tpl/gofast_og_add_user_space-mail',
    ),
    'gofast_og_mail_removed_user_space' => array(
      'template' => 'tpl/gofast_og_removed_user_space-mail',
    ),
    'gofast_og_notif_to_admin_when_new_subscription' => array(
      'template' => 'tpl/gofast_og_notif_to_admin_when_new_subscription',
    ),
    'gofast_og_notify_pending' => array(
      'template' => 'tpl/gofast_og_notify_pending',
    ),
    'gofast_og_mail_reject_user_space' => array(
      'template' => 'tpl/gofast_og_reject_user_space-mail',
    ),
    'gofast_og_moving_space' => array(
      'template' => 'tpl/gofast_og-moving-space'
    ),
    'gofast_og_archiving_space' => array(
      'template' => 'tpl/gofast_og-archiving-space'
    ),
    'gofast_og_unarchiving_space' => array(
      'template' => 'tpl/gofast_og-unarchiving-space'
    ),
    'gofast_og_space_members' => array(
      'template' => 'tpl/space_members',
      'variables' => array('nid' => NULL),
    ),
    'gofast_og_space_activity_async' => array(
      'template' => 'tpl/space_activity',
      'variables' => array('nid' => NULL),
    ),
    'page_group_node_form' => array(
      'template' => 'tpl/gofast-og-group-node-form-page',
      'variables' => array('form' => NULL)
    ),
    'group_node_form' => array(
      'render element' => 'form',
      'path' => drupal_get_path('theme', 'bootstrap_keen') . '/templates',
      'template' => 'group_node_form'
    ),
    'page_organisation_node_form' => array(
      'template' => 'tpl/gofast-og-organisation-node-form-page',
      'variables' => array('form' => NULL)
    ),
    'organisation_node_form' => array(
      'render element' => 'form',
      'path' => drupal_get_path('theme', 'bootstrap_keen') . '/templates',
      'template' => 'group_node_form'
    ),
    'page_public_node_form' => array(
      'template' => 'tpl/gofast-og-public-node-form-page',
      'variables' => array('form' => NULL)
    ),
    'public_node_form' => array(
      'render element' => 'form',
      'path' => drupal_get_path('theme', 'bootstrap_keen') . '/templates',
      'template' => 'group_node_form'
    ),
    'page_extranet_node_form' => array(
      'template' => 'tpl/gofast-og-extranet-node-form-page',
      'variables' => array('form' => NULL)
    ),
    'extranet_node_form' => array(
      'render element' => 'form',
      'path' => drupal_get_path('theme', 'bootstrap_keen') . '/templates',
      'template' => 'group_node_form'
    ),
    'gofast_og_popup' => array(
        'template' => 'tpl/gofast-og-popup',
        'variables' => array('node' => NULL)
    ),
    'gofast_og_notify_admins_contactform' => array(
      'template' => 'tpl/gofast_og_notify_admins_contactform',
    ),
    'gofast_og_home' => array(
      'template' => 'tpl/gofast-og-home',
      'variables' => array('content' => NULL, 'custom_logo' => NULL)
    ),
  );
}

/**
 * @deprecated since version 3.6.1
 * @global type $user
 * @return type
 */
function gofast_og_user_registration() {
  global $user;
  // Retrieve the user permissions from drupal_static()
  $permissions = &drupal_static('user_access');

  // Keep a record of the state of this permission before we mess with it
  if (!isset($permissions[$user->uid]['administer users'])) {
    $cleanup = 'unset';
  }
  else {
    $cleanup = $permissions[$user->uid]['administer users'];
  }

  // Add the 'administer users' permission to the logged-in user
  $permissions[$user->uid]['administer users'] = TRUE;

  // Generate the form HTML normally
  $form = drupal_get_form('user_register_form');

  // Restore the user permissions to their default state
  if ($cleanup === 'unset') {
    unset($permissions[$user->uid]['administer users']);
  }
  else {
    $permissions[$user->uid]['administer users'] = $cleanup;
  }

  // Return the rendered HTML
  return $form;
}

function gofast_og_ac_format_key($entity_type, $entity, $key, $value, $options) {
  if ($entity_type === 'user') {
    $item = $entity->name;
  }
  else {
    $item = ' no display handler ';
  }
  return $item;
}

function gofast_og_ac_format_value($entity_type, $entity, $key, $value, $options) {
  if ($entity_type === 'user') {
    $metadata = '<span class="labelize-metadata gofast_display_none" '
            . 'data-type="' . $entity_type . '" '
            . 'data-name="' . $entity->name . '" '
            . 'data-address="' . $entity->mail . '" '
            . 'data-id="' . $entity->uid . '"/></span>';
    $item = $metadata . theme('username', array('link' => FALSE, 'account' => $entity, 'popup' => FALSE));
  }
  else {
    $item = ' no display handler ';
  }
  return $item;
}

function gofast_og_user_autocomplete($str) {
  $str = trim($str);

  if (empty($str) || strlen($str) < 2) {
    // This prevents returning irrelevant results, though it should be handled
    // clientside in order to avoid useless requests.
    drupal_json_output(array());
    exit;
  }

  $options_ac_user = array(
    'format_key_callback' => 'gofast_og_ac_format_key',
    'format_value_callback' => 'gofast_og_ac_format_value'
  );

  $matches = gofast_ac_query($str, 'user', $options_ac_user);

  // Highlighting string matches.
  foreach ($matches as $key => &$value) {
    $value = preg_replace(array('/[\n\r]+/', '/(<[^<>]*>)([^<>]*?)(' . preg_quote($str, '/') . ')/i'), array('', '$1$2<b>$3</b>'), $value);
  }

  drupal_json_output($matches);
  exit;
}

/**
 * Autocomplete callback for user pre add user/userlist.
 */
function gofast_og_space_user_userlist_preadd_autocomplete($str)
{
  $str = trim($str);

  if (empty($str) || strlen($str) < 2) {
    // This prevents returning irrelevant results, though it should be handled
    // clientside in order to avoid useless requests.
    drupal_json_output(array());
    exit;
  }

  $options_ac_user = array(
    'format_key_callback' => 'gofast_og_ac_format_key',
    'format_value_callback' => 'gofast_og_ac_format_value'
  );

  // $matches return only users autocomplete, if we want to return also userlist add this ligne in the array_merge and decomment $options_ac_userlist :
  /*  $options_ac_userlist = array(
    'format_value_callback' => 'gofast_userlist_og_format_ac_value'
  ); */
  // gofast_ac_query($str, 'userlist', $options_ac_userlist)

  $matches = gofast_ac_query($str, 'user', $options_ac_user);


  // Highlighting string matches.
  foreach ($matches as $key => &$value) {
    $value = preg_replace(array('/[\n\r]+/', '/(<[^<>]*>)([^<>]*?)(' . preg_quote($str, '/') . ')/i'), array('', '$1$2<b>$3</b>'), $value);
  }

  drupal_json_output($matches);
  exit;
}


/**
 * Impements hook_menu_link_alter().
 *  Alter the data being saved to the {menu_links} table.
 *
 * @param Array $item
 *  Associative array defining a menu link as passed into menu_link_save().
 */
function gofast_og_menu_link_alter(&$item) {
  if (isset($item['options']['node_type']) && array_key_exists($item['options']['node_type'], gofast_og_node_types())) {
    // Tell Drupal to invoke hook_translated_menu_link_alter() for that link in
    // order to keep a hand on accessibility when building the menu tree.
    $item['options']['alter'] = TRUE;
  }
}

/**
 * Impements hook_translated_menu_link_alter().
 *  Alter a menu link after it has been translated and before it is rendered.
 *
 * @param Array $item
 *  Associative array defining a menu link after _menu_link_translate()
 *
 * @param Array $map
 *  Associative array containing the menu $map (path parts and/or objects).
 */
function gofast_og_translated_menu_link_alter(&$item, $map) {
  if (isset($item['options']['node_type']) && array_key_exists($item['options']['node_type'], gofast_og_node_types())) {
    $gids = gofast_og_get_spaces_by_user();
    global $user;
    if($user->uid != 1){
      list ($entity_type, $entity_id) = $map;
      if($entity_type === 'node' && in_array($entity_id, $gids)){
        $item['access'] = 1;
        $item["expanded"] = 1;
      }else{
        $item['access'] = 0;
      }
    }
  }

}

/**
 * Maintains the content visibility field according to space membership updates.
 * This submit handler is not needed anymore, the content visibility comes now
 * as a preset defined right in the bundle field settings.
 */
function gofast_og_content_visibility_submit(&$form, &$form_state) {
//  $entity = $form[GOFAST_OG_CONTENT_MEMBERSHIP_FIELD][LANGUAGE_NONE][0]['#entity'];
//  $visibility = _gofast_og_content_visibility($entity);
//
//  $tids = array_map(function ($item) {
//    return $item['target_id'];
//  }, $form_state['values'][GOFAST_OG_CONTENT_MEMBERSHIP_FIELD][LANGUAGE_NONE]);
//
//  foreach (gofast_get_field_values(OG_ACCESS_FIELD, 'node', NULL, $tids) as $eid => $access_policy) {
//    // We consider a content as public if any of its parent space is public.
//    if ((int) $access_policy === GOFAST_OG_GROUP_ACCESS_PUBLIC) {
//      $visibility = array(0 => array('value' => GOFAST_OG_CONTENT_ACCESS_PUBLIC));
//      break;
//    }
//  }
//
//  $form_state['values'][GOFAST_OG_CONTENT_VISIBILITY][LANGUAGE_NONE] = $visibility;
}

/**
 * Filters out form options from OG field ref (handle grouped/ungrouped options).
 */
function gofast_og_form_field_filter_by_id(&$form, $field_name, $ids, $exclude = FALSE, $regroup = TRUE) {
  if (is_array($field_name)) {
    $field = &$form;
    foreach ($field_name as $_parent) {
      $field = &$field[$_parent];
    }
  }
  else {
    $field = &$form[$field_name];
  }

  if (!isset($field[LANGUAGE_NONE][0]['default']['#options'])) {
    if (!isset($field['#options'])) {
      // abort;
      return;
    }
    $options = &$field['#options'];
  }
  else {
    $options = &$field[LANGUAGE_NONE][0]['default']['#options'];
  }

  $ids = array_flip($ids);
  $function = $exclude ? 'array_diff_key' : 'array_intersect_key';

  $optgrps = FALSE;
  foreach ($options as $key => &$spaces) {
    if ($optgrps = is_array($spaces)) {
      $spaces = $function($spaces, $ids);
      if (empty($spaces)) {
        unset ($options[$key]);
      }
    }
    else {
      if ($exclude && in_array($key, $ids)) {
        unset ($options[$key]);
      }
    }
  }

  if (!$optgrps && $regroup) {
    // Regroup options so that we can deal with a known array structure.
    end($options) & $nid = key($options);
    if (isset($nid) && $nid !== '_none') {
      $node = node_load($nid);
      $space_types = gofast_og_node_types();
      $optgrp_name = $space_types[$node->type];
      unset ($options['_none']);
      $options = array('_none' => t('- None -', array(), array('context' => 'gofast'))) + array($optgrp_name => $options);
    }
  }
}

/**
 * Implements hook_views_api().
 */
function gofast_og_views_api() {
  return array(
    'api' => 3,
    'path' => drupal_get_path('module', 'gofast_og') . '/views',
  );
}

/**
 * Implements hook_form_alter()
 *
 *  Gofast OG member admin views form alter (VBO).
 */
function gofast_og_form_views_form_gofast_og_members_admin_block_alter(&$form, &$form_state) {
  $view = $form_state['build_info']['args'][0];
  list($group_type, $gid) = $view->args;
  $space = entity_load_single($group_type, $gid);

  if (isset($form['add_roles']))
    gofast_og_vbo_action_user_roles_alter($form, $form_state, array($group_type, $gid, $space));

  if (isset($form['confirm']))
    gofast_og_vbo_action_membership_delete_confirm_alter($form, $form_state, array($group_type, $gid, $space));
}

/**
 * Implements hook_views_bulk_operations_form_alter().
 */
/*
function gofast_og_views_bulk_operations_form_alter(&$form, &$form_state, $vbo) {
  $view = $vbo->view;

  if ($view->name == 'gofast_og_members_admin' && $view->current_display == 'block') {
    // Alter the first step of the VBO form (the selection page).
    if ($form_state['step'] === 'views_form_views_form') {
      // Disable main administrator row's checkbox to prevent any operation on
      // this user.
      list($group_type, $gid) = $view->args;
      $og_membership = og_get_membership($group_type, $gid, 'user', GOFAST_USER_ADMINISTRATOR_ID);
      if ($og_membership && isset($form['views_bulk_operations'])) {
        foreach ($form['views_bulk_operations'] as $key => &$element)
          isset($element['#return_value']) && $element['#return_value'] === $og_membership->id
            && $element['#access'] = FALSE;
      }
    }
  }

  $form['#attached']['js'][] = drupal_get_path('module', 'gofast') . '/js/vbo.js';
}
 */


/**
 * Implements hook_form_alter()
 *
 *  Alter Gofast OG views exposed form.
 */
function gofast_og_form_views_exposed_form_alter(&$form, &$form_state, $form_id) {
  $view = $form_state['view'];

  if ($view->name == 'gofast_og_members_admin' && $view->current_display == 'block') {
    // Alter autocomplete element to filter user names.
    $form['uid']['#autocomplete_path'] = 'gofast/og-member-autocomplete';
    $form['uid']['#xac'] = array('multiple' => TRUE);

    // Align submit button.
    $form['submit']['#attributes']['style'] = array('margin-top:2.2em');
  }
}

/**
 * Implements hook_og_context_negotiation_info().
 */
function gofast_og_og_context_negotiation_info() {
  $providers = array();

  $providers['gofast_og_views'] = array(
    'name' => t('GoFAST OG Views', array(), array('context' => 'gofast:gofast_og')),
    'description' => t('Determine context based on views argument by checking if a node is a group or a group content.', array(), array('context' => 'gofast:gofast_og')),
    'callback' => 'gofast_og_context_handler_views',
    'menu path' => array('spaces/%/%/%/admin/people') // append here other menu paths matching OG related views.
  );

  return $providers;
}

/**
 * OG Context handler.
 */
function gofast_og_context_handler_views() {
  if ($node = menu_get_object('node', 3)) {
    return _group_context_handler_entity('node', $node);
  }

  $item = menu_get_item();

  if (empty($item['map'])) {
    return;
  }

  $key = array_search('node', $item['map'], TRUE);

  if ($key !== FALSE && isset($item['map'][++$key]) && is_numeric($item['map'][$key])) {
    if ($node = node_load($item['map'][$key])) {
      return _group_context_handler_entity('node', $node);
    }
  }
}

/**
 * Autocomplete callback for Gofast OG admin view (manage members)
 */
function gofast_og_autocomplete_members($str) {
  $matches = array();

  // Since the user might enter a comma-separated list of user name, we only
  // autocomplete the last string.
  $array = drupal_explode_tags($str);
  $last_str = trim(array_pop($array));

  if ($last_str != '') {
    $prefix = count($array) ? implode(', ', $array) . ', ' : '';
    $matches = gofast_ac_query($last_str, 'user', array(
      'format_key_callback' => function($type, $entity) use ($prefix){
        return $prefix . $entity->name;
      }
    ));
  }

  drupal_json_output($matches);
  exit;
}

/**
 * Implements hook_form_FORM_ID_alter()
 */
function gofast_og_form_og_ui_edit_membership_alter(&$form, &$form_state) {
  if (!isset($form['membership_fields']['#entity'])) {
    return;
  }

  $og_membership = $form['membership_fields']['#entity'];

  if ($og_membership->entity_type === 'user' && $og_membership->field_name === GOFAST_OG_USER_MEMBERSHIP_FIELD) {
    $account = user_load($og_membership->etid);

    $form['membership_fields']['#access'] = FALSE;
    $form['og_user']['state']['#access'] = FALSE;

    $form['og_user']['name'] = array(
      '#type' => 'markup',
      '#title' => t('User name', array(), array('context' => 'gofast')),
      '#markup' => theme('username', array('account' => $account)),
      '#suffix' => '<br/><br/>'
    );

      // Prevent from assigning more than one role to a member (same logic as
      // gofast_user_account_form_alter().
      $form['og_user']['roles']['#attributes'] = array('class' => array('og-roles-force-single'));
      $form['og_user']['roles']['#attached']['js'] = array(array(
        'data' => drupal_get_path('module', 'gofast_og') . '/gofast_og.js',
        'type' => 'file',
        'scope' => 'footer',
        'weight' => 5
      ));

      if(count($form['og_user']['roles']["#options"]) > 0){
          foreach($form['og_user']['roles']["#options"] as $rid=>$role_string){
              $form['og_user']['roles']["#options"][$rid] = t($role_string, array(), array("context" => "gofast"));
          }
      }


    if(!isset($form['actions']['delete'])){
      $form['actions']['delete'] = array(
        '#type' => 'markup',
        '#markup' => l(t('Remove'), 'group/node/' . $gid . '/admin/people/delete-membership/' . $og_membership->id),
      );
    }

    if (isset($form['actions']['delete']['#markup'])) {
      $path = "spaces/nojs/node/{$og_membership->gid}/admin/people/delete-membership/{$og_membership->id}";
      $form['actions']['delete']['#markup'] = gofast_button(t('Remove'), $path, 'btn-danger', 'glyphicon-trash', array('class' => array('ctools-use-modal')));
    }
    $form['#submit'] = array("gofast_og_modal_edit_member_submit");
    $form['actions']['submit']['#attributes'] = array('class' => array('btn-success'));
  }

  $form['#validate'][] = 'gofast_og_ui_delete_membership_validate';
}

/**
 * Register an organisation as the default organisation.
 *
 * @param $gid
 *  The OG node ID of the organisation to register. If not set or not a valid
 *  node id, an arbitrary organisation will be used as default. If there is no
 *  such organisation at all, create it.
 */
function gofast_og_set_default_organisation($gid = NULL) {
  // If no organisation is found, automatically create it and set it as default.
  $org = gofast_og_get_spaces_by_bundle('organisation');
  if (empty($org)) {
    return gofast_og_create_default_organisation();
  }

  // If the specified parameter is not a valid OG node id, use the first created
  // organisation's gid.
  if (!isset($org[$gid])) {
    $query = db_select('node');
    $query->addExpression('MIN(nid)');
    $gid = $query->condition('type', 'organisation')->execute()->fetchField();
  }

  variable_set('gofast_og_default_organisation', $gid);
  return $gid;
}

/**
 * Creates an Organic Group $bundle (based on the 'node' entity type).
 *
 * @param String $title
 *  The title of the OG node to create.
 *
 * @param String $bundle
 *  The bundle machine name of the OG node being created.
 *
 * @param Array $options (optional)
 *  An associative array of options :
 *  - 'author' => Author of the OG node (user id or object), default to admin
 *  - 'access' => OG access policy, default is GOFAST_OG_GROUP_ACCESS_DEFAULT
 *  - 'parent' => Parent OG node ID, default is NULL (no parent)
 *  - 'description' => String describing the OG (this is a required field, an
 *   empty string will throw an error).
 *  - 'body' => Content of the body in HTML format (no filtered), default is an
 *   empty string.
 *
 * @return boolean
 *  TRUE on success, or an associative array of errors.
 */
function gofast_og_create($title, $bundle, $options = array()) {
  module_load_include('inc', 'node', 'node.pages');

  $form_state = array();
  $access_default = GOFAST_OG_GROUP_ACCESS_DEFAULT;

  if (GOFAST_USER_ADMINISTRATOR_ID == NULL)
  {
    $author = variable_get('gofast_user_administrator_id');
  }
  else{
    $author = GOFAST_USER_ADMINISTRATOR_ID;
  }
  // Merge in default options :
  $options += array(
    'author' => $author,
    'access' => $access_default,
    'description' => t('~ created automatically ~', array(), array('context' => 'gofast')), // this field is required
    'body' => '',
    'parent' => NULL,
  );

  // Check author.
  if (!(is_object($options['author']) && $options['author']->uid)) {
    $options['author'] = $options['author'] && ($options['author'] = user_load($options['author'])) ? $options['author'] : user_load(GOFAST_USER_ADMINISTRATOR_ID);
    if ($options['author'] === FALSE) {
      watchdog('gofast_og', 'Cannot create og node, no author provided', NULL, WATCHDOG_ERROR);
      return;
    }
  }

  // Check membership and set plid (parent menu link id).
  $plid = 0;
  $menu_enabled = 0;
  $menu_parent = NULL;

  if ($bundle !== 'private_space') {
    //menu system has changed, it is dynamically constructed
    //https://srv01.ceo-vision.com/jira_new/browse/GOFAST-2961
    $menu_enabled = 0;
    $pgid = FALSE;
    if (isset($options['parent'][0]['target_id'])) {
      $pgid = $options['parent'][0]['target_id'];
    }
    elseif (is_numeric($options['parent'])) {
      $pgid = $options['parent'];
      $options['parent'] = array(0 => array('target_id' => $options['parent'], 'field_mode' => 'default'));
    }
    $plid = $pgid ? gofast_get_mlid_by_path('node/' . $pgid) : gofast_get_mlid_by_title('Spaces');
    $menu_parent = 'main-menu:' . $plid;
  }

  // Populate the fields shared by OG node bundles in node form. Fields that
  // are not populated here will take their default values.
  $form_state['values'] = array(
    'nid' => NULL,
    'vid' => NULL,
    'uid' => $options['author']->uid,
    'created' => time(),
    'type' => $bundle,
    'language' => LANGUAGE_NONE,
    'changed' => '',
    'title' => $title,
    'revision' => 0,
    'log' => '',
    'name' => $options['author']->name,
    'date' => '',
    'status' => NODE_PUBLISHED,
    'promote' => NODE_NOT_PROMOTED,
    'sticky' => NODE_NOT_STICKY,
    'body' => array(
      LANGUAGE_NONE => array(
        0 => array(
          'summary' => '',
          'value' => $options['body'],
          'format' => 'full_html'
        )
      )
    ),
    OG_GROUP_FIELD => array(
      LANGUAGE_NONE => array(
        0 => array(
          'value' => 1
        )
      )
    ),
    OG_USER_INHERITANCE_FIELD => array(
      LANGUAGE_NONE => array(
        // cardinality: 0 => array('value' => ...)
        // 'value' => '2' OG_USER_INHERITANCE_DEFAULT
      )
    ),
    GOFAST_CMIS_FOLDER_REFERENCE_FIELD => array(
      LANGUAGE_NONE => array(
        0 => array(
          'value' => ''
        )
      )
    ),
    'field_description' => array(
      LANGUAGE_NONE => array(
        0 => array(
          'value' => $options['description']
        )
      )
    ),
    OG_ACCESS_FIELD => array(
      LANGUAGE_NONE => array(
        $options['access']
      )
    ),
    'comment' => '1',
    /*'menu' => array(
      'enabled' => $menu_enabled,
      'mlid' => 0,
      'module' => 'menu',
      'hidden' => 0,
      'has_children' => 0,
      'customized' => 1,
      'options' => array(
        'alter' => TRUE
      ),
      'expanded' => 1,
      'parent_depth_limit' => 8,
      'link_title' => $title,
      'description' => '',
      'parent' => $menu_parent,
      'weight' => '0',
      'language' => LANGUAGE_NONE,
    ),*/
//    'path' => array(
//      'alias' => '',
//      'pid' => NULL,
//      'source' => NULL,
//      'language' => LANGUAGE_NONE,
//      'pathauto' => 0,
//    ),
    'op' => t('Save', array(), array('context' => 'gofast')),
  );

  if($bundle !== 'private_space') {
    $form_state['values'][GOFAST_OG_PARENT_GROUP_FIELD] = array(
      LANGUAGE_NONE => isset($options['parent']) ? $options['parent'] : array()
    );
  }

  // Construct og node object
  $node = new stdClass();
  $node->is_new = TRUE;
  $node->type = $bundle;
  $node->language = LANGUAGE_NONE;
  $node->options = array();
  $node->status = NODE_PUBLISHED;
  $node->promote = NODE_NOT_PROMOTED;
  $node->sticky = NODE_NOT_STICKY;
  $node->module = 'node';

  // Prepares the node object for being submitted (as a form argument). Add few
  // default values, and then invokes hook_prepare() on the node type module,
  // and hook_node_prepare() on all modules.
  node_object_prepare($node);

  // Since node_object_prepare() set the current global $user as the node author
  // we need to override this behavior to preserve the space manager preset.
  $node->uid = $options['author']->uid;
  $node->name = $options['author']->name;

  //Set parent space
  $node->og_group_ref[LANGUAGE_NONE] = $options['parent'];

  // Until GOFAST-2452 is fixed, workaround with the following code
  $node->title = $title;
  node_save($node);
  $_POST['new_space_nid'] = $node->nid;
  return TRUE;

  // Call the node_create form corresponding to $bundle (or content-type).
  drupal_form_submit("{$bundle}_node_form", $form_state, $node);

  return ($errors = form_get_errors()) ? $errors : TRUE;
}

/*
 * Hook node_insert
 */
function gofast_og_node_insert($node){

  //If the new node is a public space, we queue a membership rebuild for the next cron.
  if(( gofast_og_is_root_space($node) && !gofast_og_is_user_private_space($node) ) || $node->type == 'public'){
    drupal_set_message(t("The configuration of this space is still in progress, it will be completed in a few minutes."), array(), array('context' => 'gofast:og'), 'status');

    //Acquire membership_waiting_build lock
    lock_wait("membership_waiting_build", 10);
    if(!lock_acquire("membership_waiting_build", 10)){
        drupal_set_message("Unable to lock membership_waiting_build variable", "error");
        return;
    }

    $membership_queue = variable_get('membership_waiting_build', "");
    if($membership_queue != ""){
      $membership_queue = json_decode($membership_queue, TRUE);
      $membership_queue[] = $node->nid;
    }
    else{
      $membership_queue = array();
      $membership_queue[] = $node->nid;
    }
    $membership_queue = json_encode($membership_queue);
    variable_set('membership_waiting_build', $membership_queue);

    //Release membership_waiting_build lock
    lock_release("membership_waiting_build");
  }
  if(gofast_og_is_space($node) && !gofast_og_is_user_private_space($node)) {
      gofast_cmis_item_folder_insert("Wikis", gofast_cmis_get_raw_item_id($node->{GOFAST_CMIS_FOLDER_REFERENCE_FIELD}[LANGUAGE_NONE][0]['value']));
      gofast_og_add_article_homepage($node);
  }

}

/**
 * Returns the parent mlid of a given OG node.
 *
 * @param $node
 *  A Drupal node object.
 *
 * @return int
 *  The mlid of the parent OG if exist, otherwise the mlid of 'Spaces' root item.
 */
function gofast_og_get_menu_parent_id($node) {
  $parent_id = _gofast_og_space_get_parent($node);
  return $parent_id ? gofast_get_mlid_by_path('node/' . $parent_id) : gofast_get_mlid_by_title('Spaces');
}

/**
 * This method returns whether the parent are the same not between two nodes.
 *
 * @param type $node the first node to compare
 * @param type $old_node the second node to compare
 * @return boolean true if parents are same, false otherwise
 */
function gofast_og_parents_are_same($node, $old_node) {
  return _gofast_og_space_get_parent($node, FALSE, TRUE) === _gofast_og_space_get_parent($old_node, FALSE, TRUE);
}

/**
 * Register a node into a space (OG).
 *
 * @param $gid
 *  The OG entity or OG id.
 * @param $nid
 *  The nodeID or node object to be subscribed.
 * @return
 *  The corresponding og_membership entity or FALSE otherwise.
 */
function gofast_og_subscribe_node($gid, $nid) {
  $node = is_object($nid) ? $nid : node_load($nid);
  $field_name = gofast_og_is_space($node) ? GOFAST_OG_PARENT_GROUP_FIELD : GOFAST_OG_CONTENT_MEMBERSHIP_FIELD;
  return gofast_og_subscribe($gid, $nid, 'node', $field_name);
}

/**
 * Subscribe a user to a space.
 *
 * @param int $gid
 *  The OG entity or OG id.
 * @param int $uid
 *  The userID or user object to be subscribed.
 * @param int $subscription_state [optional]
 *  The value of the subscription state. See @og.module to get constant names.
 *  Defaults to OG_STATE_ACTIVE.
 * @param boolean $private_space [optional]
 *  Set it to TRUE when subscribing a user into its private space. Defaults to
 *  FALSE.
 * @return
 *  The corresponding og_membership entity or FALSE otherwise.
 */
function gofast_og_subscribe_user($gid, $uid, $subscription_state = OG_STATE_ACTIVE, $private_space = FALSE) {
  $membership = $private_space ? GOFAST_OG_USER_PRIVATE_SPACE : GOFAST_OG_USER_MEMBERSHIP_FIELD;
  return gofast_og_subscribe($gid, $uid, 'user', $membership, $subscription_state);
}

/**
 * Unsubscribe a user to a space.
 *
 * @param int $gid
 *  The OG entity or OG id.
 * @param int $uid
 *  The userID or user object to be unsubscribed.
 * @return
 *  The corresponding og_membership entity or FALSE otherwise.
 */
function gofast_og_unsubscribe_user($gid, $uid) {
  $membership = og_get_membership('node', $gid, 'user', $uid);
  $membership_id = $membership->id;
  return og_membership_delete($membership_id);
}

/**
 * Unsubscribe a node to a space.
 *
 * @param int $gid
 *  The OG entity or OG id.
 * @param int $nid
 *  The Node ID or node object to be unsubscribed.
 * @return
 *  The corresponding og_membership entity or FALSE otherwise.
 */
function gofast_og_unsubscribe_node($gid, $nid) {
  $membership = og_get_membership('node', $gid, 'node', $nid);
  $membership_id = $membership->id;
  return og_membership_delete($membership_id);
}

/**
 * Subscribe an entity to a OG node. Target OG type is assumed to be a node.
 *
 * @param $gid
 *  The OG entity or OG id.
 * @param $entity
 *  The entity ID or entity object to be subscribed.
 * @param $entity_type
 *  The entity type (e.g. 'node' or 'user').
 * @param $field_name
 *  The name of the field the membership should be registered in.
 * @param $subscription_state
 *  The value of the subscription state. See @og.module to get const names
 * @return
 *  The corresponding og_membership entity or FALSE otherwise.
 */
function gofast_og_subscribe($gid, $entity, $entity_type, $field_name, $subscription_state = OG_STATE_ACTIVE) {
  //Check integrity
  if(!is_numeric($gid) || !isset($entity) || !isset($entity_type) || !isset($field_name)){
    return;
  }
  $og_infos = array(
    'entity_type' => $entity_type,
    'entity' => $entity,
    'field_name' => $field_name,
    'state' => $subscription_state
  );
  // Add the entity to the OG and return the corresponding og_membership.
  return og_group('node', $gid, $og_infos);
}

/**
 * Implements hook_enable()
 */
function gofast_og_enable() {
  // Ensure this module hooks implementations are called after og module ones.
  _gofast_manage_hook_system_weight();

  // Creates specific role for Gofast space (OG node) bundles if they don't
  // (exist other roles are based on og module defaults with custom permissions).
  foreach (gofast_og_node_types() as $bundle => $label) {
    $roles = og_roles('node', $bundle, 0, FALSE, FALSE);
    foreach (gofast_og_og_default_roles() as $key => $role_name) {
      if (!array_search($role_name, $roles)) {
        $status = og_role_save(og_role_create($role_name, 'node', 0, $bundle));
        if (!in_array($status, array(SAVED_NEW, SAVED_UPDATED))) {
          watchdog('Gofast OG', 'Error while creating role "@role"', array('@role' => $role_name), WATCHDOG_ALERT);
        }
      }
    }
  }
}

/**
 * Implements hook_post_install()
 *
 *  Runs once the Gofast installation is done (via drush command).
 */
function gofast_og_post_install() {
  // Create site wide spaces for each space type except the private space. We
  // don't rely on gofast_og_node_types() so that actual space node title can
  // differ from the bundle label.
  $bundles = array(
    'group' => 'Groups',
    'organisation' => 'Organisations',
    'extranet' => 'Extranet',
    'public' => 'Public'
  );
  db_query("ALTER TABLE node AUTO_INCREMENT=4"); //Fix an issue for migration
  db_query("ALTER TABLE node_revision AUTO_INCREMENT=10"); //Fix an issue for migration
  $ret = array();
  foreach ($bundles as $bundle => $title) {
    $_ret = gofast_og_create($title, $bundle);
    if ($_ret === TRUE) {
      $ret[] = array(
        'severity' => 'success',
        'message' => "OG node bundle {$bundle} '$title' has been created successfully."
      );
    }
    else {
      $msg = '';
      foreach ((array) $_ret as $key => $value) {
        $msg .= "$key : $value <br />";
      }
      $ret[] = array(
        'severity' => 'error',
        'message' => $msg
      );
    }
  }

  return $ret;
}

/**
 * Implements hook_og_default_roles()
 *
 *  Declare global role for Gofast spaces (a global role is assigned by default
 *  to all new spaces).
 *
 *  already defaults :
 *  - OG role 'member' (locked).
 *  - GOFAST_OG_ROLE_ADMIN is equal to OG_ADMINISTRATOR_ROLE.
 */
function gofast_og_og_default_roles() {
    return array('gofast_og' => GOFAST_OG_ROLE_STANDARD, GOFAST_OG_ROLE_READ_ONLY);
}

/*
 * Get the default rôle configured for the given user
 * if no user supplied, the current is set
 * the internal id are the following
 * 0 => administrator
 * 1 => contributor
 * 2 => read only
 */
function gofast_og_get_user_default_role($my_user = null){
  
    if($my_user == null){
        global $user;
        $my_user = $user;
    }
    if(isset($my_user->field_default_role[LANGUAGE_NONE])){
        $role_id = $my_user->field_default_role[LANGUAGE_NONE][0]["value"];
    }else{
        if(isset($_SESSION["default_role_creation_user"])){
            $role_id = $_SESSION["default_role_creation_user"];
        }else{
            $role_id = 2;
        }

    }

    if($role_id == 0){
        $role = GOFAST_OG_ROLE_ADMIN;
    }elseif($role_id == 2){
         $role = GOFAST_OG_ROLE_READ_ONLY;
    }else{
         $role = GOFAST_OG_ROLE_STANDARD;
    }

    return $role;
}

/**
 * Wrapper function that returns user roles in a specific space.
 *
 * @param int|string $gid
 *  A valid OG node ID.
 * @param int|string $uid [optional]
 *  A valid user ID. Defaults to ID of current logged in user.
 * @return Array
 *  An array of role name keyed by user role IDs.
 */
function gofast_og_get_user_roles($gid, $uid = NULL, $check_active = TRUE) {
  $group_node = node_load($gid);
  if(isset($group_node->nid)){
        return og_get_user_roles('node', $gid, $uid, FALSE, $check_active);
  }
}

/**
 * Helper function that returns user inheritance value for a given OG entity.
 * OG type is assumed to be 'node'.
 *
 * @param type $node
 *  The OG object or OG ID.
 * @return int
 *  OG_USER_INHERITANCE_SUBGROUP or OG_USER_INHERITANCE_PARENT.
 */
function gofast_og_get_user_inheritance($node) {
  if (is_numeric($node)) {
    $og_node = node_load($node);
  }
  else {
    $og_node = $node;
  }
  $items = field_get_items('node', $og_node, OG_USER_INHERITANCE_FIELD, $og_node->language);
  return isset($items[0]) ? intval($items[0]['value']) : null;

  if (!isset($node->{OG_USER_INHERITANCE_FIELD}[LANGUAGE_NONE][0]['value'])) {
    if (!is_numeric($node))
      return FALSE;
    // Load field value assuming $node is an OG id.
    return reset(gofast_get_field_value(OG_USER_INHERITANCE_FIELD, 'node', NULL, array($node)));
  }
  return $node->{OG_USER_INHERITANCE_FIELD}[LANGUAGE_NONE][0]['value'];
}

/**
 * Implements hook_event_node_diff_alter()
 */
function gofast_og_event_node_diff_alter($diff, $node, $original) {
  $diff['test'] = 'test event_node_diff_alter';
  return $diff;
}

/**
 * @deprecated
 */
function gofast_og_is_subspace_from_form_name($space) {
  if (strpos($space, "-- ") !== false) {
    return true;
  }
  elseif (strpos($space, "---- ") !== false) {
    return true;
  }
  else {
    return false;
  }
}

/**
 * @deprecated
 * @todo
 */
function gofast_og_has_nomenclature_subspace_title($title) {
  $last = $title[0];
  if ($last == "_") {
    $return = true;
  }
  else {
    $return = false;
  }

  return $return;
}

//fonction qui retourne l'id du spacee dont le titre est passé en parametre
//$path signifie que l'on a recu un chemin en parametre et non seulement un titre.Cela permet de ne pas se tromper si des sous spacees ont le meme nom
function gofast_og_get_group_id_from_title($title, $path = false, $recursion = false) {
  if ($path == false) {
    $result = db_query("SELECT nid FROM node n where title= :title AND n.type IN (:types)", array(":title" => $title, ":types" => array_keys(gofast_og_node_types())))->fetchObject()->nid;
  }
  else {
    //je separe le chemin selon les / pour avoir l'arborescence sous forme de tableau
    $path_parts = array_values(array_filter(explode("/", $path)));

    //We get the type of the bundle
    if (count($path_parts) === 2) {
      if ($path_parts[0] === "Sites") {
        $type = $path_parts[1];
        if ($type === "_Groups") {
          $type = "group";
        }
        elseif ($type === "_Organisations") {
          $type = "organisation";
        }
        elseif ($type === "_Extranet") {
          $type = "extranet";
        }
        elseif ($type === "_Public") {
          $type = "public";
        }
        else {
          $type = "private_space";
        }

        $webdav_title = $path_parts[1];
        $count = 1;
        $space_title = str_replace("_", "", $webdav_title, $count);

        if ($type === "private_space") {
          $user_id = user_load_by_name($space_title)->uid;
          $result = db_query("SELECT nid FROM node n where n.uid= :uid AND n.type= :type", array(":uid" => $user_id, ":type" => $type))->fetchObject()->nid;
        }
        else {
          $result = db_query("SELECT nid FROM node n where n.title= :title AND n.type= :type", array(":title" => $space_title, ":type" => $type))->fetchObject()->nid;
        }
      }
      else {
        $result = FALSE;
      }
    }
    else {
      //je recupere l'identifiant alfresco du chemin recu
      if ($title == "") {
        return FALSE;
      }
      $item = gofast_cmis_item_get_by_path($title);
      //return $title;
      if(isset($item->properties)) {
        $folderId = $item->properties['cmis:objectId'];
        //a partir de cet id je recupere le spacee dont le champs cck du dossier vaut cet id
        $result = gofast_og_get_nid_from_folder_reference($folderId);
        // If the result is null, it means that this is a folder and not an og
        if($result === NULL) {
          return FALSE;
        }

        if ($result == "" && $recursion == false) {

          //si on est sur un dossier qui n'est pas un sous-spacee, il faut determiner le parent de ce dossier qui correspond a un spacee ou sous-gorupe
          //je transforme son chemin en tableau en coupant selon les /
          $array_name = explode("/", rawurldecode($title));
          $is_subspace = false;
          $array_name = array_reverse($array_name);
          // j'inverse ce tableau puis je parcours chaque element jusqu'a tomber sur un sous spacee
          $sub = false;
          foreach ($array_name as $key3 => $subfoldername) {

            if (gofast_og_has_nomenclature_subspace_title($subfoldername)) {

              $sub = true;
              //je reconstruit le chemin de ce sousspacee
              $path_parent = "";
              for ($i = $key3; $i <= count($array_name) - 1; $i++) {
                //watchdog("debugi", $path_parent);
                if ($i == $key3) {
                  $path_parent = $array_name[$i];
                }
                else {
                  $path_parent = $array_name[$i] . "/" . $path_parent;
                }
              }

              $result = gofast_og_get_group_id_from_title($path_parent, true, true);

              return $result;
            }
          }
          //si en remontant l'arborescence on a pas trouvé de sous spacee, le dossier appartient a un spacee donc facile de le trouver (il est sous Groupes ou Organisation)
          if ($sub == false) {
            $array_name = array_reverse($array_name);

            $type = $array_name[2];
            if ($type === "Groupes") {
              $type = "space";
            }
            elseif ($type === "Organisations") {
              $type = "organisation";
            }
            else {
              $type = "private_space";
            }
            $result = db_query("SELECT nid FROM node n where title= :title AND n.type= :type", array(":title" => $array_name[3], ":type" => $type))->fetchObject()->nid;
          }
        }
      } else {
        return FALSE;
      }
    }
  }
  return $result;
}


//fonction qui retourne l'id du groupe dont le titre est passé en parametre
  //$path signifie que l'on a recu un chemin en parametre et non seulement un titre.Cela permet de ne pas se tromper si des sous groupes ont le meme nom
  function gofast_og_get_group_id_from_title_2($title, $path = false, $recursion = false){
    if($path == false){
      $result=db_query("SELECT nid FROM node n where title= :title AND (n.type= :type1 OR n.type= :type2)", array(':title' => $title, ':type1' => "group_node", ':type2' => "orga" ))->fetchObject()->nid;
    }
    else{
      //je separe le chemin selon les / pour avoir l'arborescence sous forme de tableau
      $emplacements_array = explode("/", $title);
      //si on est sur un dossier qui n'est pas un sous-groupe, il faut determiner le parent de ce dossier qui correspond a un groupe ou sous-gorupe
      //je transforme son chemin en tableau en coupant selon les /
      $array_name = explode("/",rawurldecode($title));
      $is_subgroup = false;
      $array_name = array_reverse($array_name);
      // j'inverse ce tableau puis je parcours chaque element jusqu'a tomber sur un sous groupe
      $sub = false;
      foreach($array_name as $key3=>$subfoldername){
          if(gofast_og_has_nomenclature_subspace_title($subfoldername)){
              $sub = true;
              //je reconstruit le chemin de ce sousgroupe
              $path_parent = "";
              for($i=$key3; $i <= count($array_name)-1;$i++){
                  //watchdog("debugi", $path_parent);
                  if($i== $key3){
                      $path_parent = $array_name[$i];
                  }else{
                      $path_parent = $array_name[$i]."/".$path_parent;
                  }
              }
                    $item = gofast_cmis_item_get_by_path($path_parent);
                    if(isset($item->properties)) {
                        $folderId = $item->properties['cmis:objectId'];
                        //a partir de cet id je recupere le spacee dont le champs cck du dossier vaut cet id
                        $result = gofast_og_get_nid_from_folder_reference($folderId);
                        // If the result is null, it means that this is a folder and not an og
                        if($result === NULL) {
                            continue;
                        }

                             return $result;
                    }else{
                        continue;
                    }

          }
      }
      //si en remontant l'arborescence on a pas trouvé de sous groupe, le dossier appartient a un groupe donc facile de le trouver (il est sous Groupes ou Organisation)
      if($sub == false){
          $array_name = array_reverse($array_name);
          $type = $array_name[2];
          if($type == "_Groups"){
              $type = "group";
          }else{
              $type = "organisation";
          }
              $result=db_query("SELECT nid FROM node n where title= :title AND n.type= :type", array(":title" => $array_name[3], ":type" => $type))->fetchObject()->nid;
      }
    }
    return $result;

  }

  //fonction qui retourne l'id du groupe dont le titre est passé en parametre
  //$path signifie que l'on a recu un chemin en parametre et non seulement un titre.Cela permet de ne pas se tromper si des sous groupes ont le meme nom
  function gofast_og_get_group_id_from_title_without_cmis($title, $path = false, $recursion = false){
    if($path == false){
      $result=db_query("SELECT nid FROM node n where title= :title AND (n.type= :type1 OR n.type= :type2)", array(':title' => $title, ':type1' => "group_node", ':type2' => "orga" ))->fetchObject()->nid;
    }
    else{
      //je separe le chemin selon les / pour avoir l'arborescence sous forme de tableau
      $emplacements_array = explode("/", $title);
      //si on est sur un dossier qui n'est pas un sous-groupe, il faut determiner le parent de ce dossier qui correspond a un groupe ou sous-gorupe
      //je transforme son chemin en tableau en coupant selon les /
      $array_name = explode("/",rawurldecode($title));
      $is_subgroup = false;
      $array_name = array_reverse($array_name);
      // j'inverse ce tableau puis je parcours chaque element jusqu'a tomber sur un sous groupe
      $sub = false;
      foreach($array_name as $key3=>$subfoldername){
          if(gofast_og_has_nomenclature_subspace_title($subfoldername)){
              $sub = true;
              //je reconstruit le chemin de ce sousgroupe
              $path_parent = "";
              for($i=$key3; $i <= count($array_name)-1;$i++){
                  //watchdog("debugi", $path_parent);
                  if($i== $key3){
                      $path_parent = $array_name[$i];
                  }else{
                      $path_parent = $array_name[$i]."/".$path_parent;
                  }
              }

              $gid = gofast_og_get_gid_from_webdav_path_without_cmis($path_parent);
              if($gid == null){
                    $item = gofast_cmis_item_get_by_path($path_parent);
                    if(isset($item->properties)) {
                        $folderId = $item->properties['cmis:objectId'];
                        //a partir de cet id je recupere le spacee dont le champs cck du dossier vaut cet id
                        $result = gofast_og_get_nid_from_folder_reference($folderId);
                        // If the result is null, it means that this is a folder and not an og
                        if($result === NULL) {
                            return FALSE;
                        }

                             return $result;
                    }
              }else{
                  return $gid;
              }

          }
      }
      //si en remontant l'arborescence on a pas trouvé de sous groupe, le dossier appartient a un groupe donc facile de le trouver (il est sous Groupes ou Organisation)
      if($sub == false){
          $array_name = array_reverse($array_name);
          $type = $array_name[2];
          if($type == "_Groups"){
              $type = "group";
          }else{
              $type = "organisation";
          }
              $result=db_query("SELECT nid FROM node n where title= :title AND n.type= :type", array(":title" => $array_name[3], ":type" => $type))->fetchObject()->nid;
      }
    }
    return $result;

  }

/*
 * function used to estimate the gid of node based on path, without making cmis query. Usefull for mass usage
 * Assuming we receive a path corresponding to a space ( function gofast_og_has_nomenclature_subspace_title)
 * we split the string with /, then we get the last and the one just before, and we make a sql query to find a space with this title and which the parent
 * has title corresponding to the one juste before
 */
function gofast_og_get_gid_from_webdav_path_without_cmis($path){
    if($path === TRUE){
        return null;
    }
    $path = str_replace("/Sites/", "/", $path);
    $path = str_replace("/_", "/", $path);
    $path_array =  explode("/",$path);
    $path_array = array_reverse($path_array);
    $space_title = $path_array[0];
    $parent_space_title = $path_array[1];

   if($parent_space_title == ""){
       $object = db_query("select nid from node n inner join og_membership o on n.nid = o.etid where n.title = :space_title", array(":space_title" => $space_title))->fetchAll();
   }else{
       //first, check if the subquery will return multiple results. If yes, return null because we are not able to know the right parent
        $subquery = db_query('select count(nid) as count from node where node.title = :parent_space_title and node.type IN (\'private_space\',\'group\',\'organisation\',\'extranet\',\'public\')', array(":parent_space_title" => $parent_space_title))->fetchObject();
        if($subquery->count != "1"){
            return null;
        }
        $object = db_query('select nid from node n inner join og_membership o on n.nid = o.etid where n.title = :space_title and (o.gid = (select nid from node where node.title = :parent_space_title and node.type IN (\'private_space\',\'group\',\'organisation\',\'extranet\',\'public\')))', array(":space_title" => $space_title, ":parent_space_title" => $parent_space_title))->fetchObject();
       // watchdog("debug pas encore trouvé nid", "select nid from node n inner join og_membership o on n.nid = o.etid where n.title = '".$space_title."' and (o.gid = (select nid from node where node.title = '".$parent_space_title."' and node.type IN ('private_space','group','organisation','extranet','public')))");
   }

    if(isset($object->nid)){
        watchdog("debug trouvé nid", $object->nid);
        return $object->nid;
    }else{
        return null;
    }
}

//fonction qui renvoi le nid du noeud donc le champs cck folder_reference est passé en parametre
function gofast_og_get_nid_from_folder_reference($folder_reference) {
  if (strpos($folder_reference, "workspace") === false) {
    $reference = "workspace://SpacesStore/" . $folder_reference;
  } else {
    $reference = $folder_reference;
  }
  $object = db_query("SELECT entity_id FROM field_data_field_folder_reference where field_folder_reference_value = :reference", array(":reference" => $reference))->fetchObject();
  $result = FALSE !== $object ? $object->entity_id : null;
  return $result;
}

/**
 * Implements_hook_user_insert()
 *
 * A user account was created. Module should save its custom additions to the
 * user object into the database.
 *
 * @see hook_user_presave() for params description
 */
function gofast_og_user_insert(&$edit, $account, $category) {
  $uid = $account->uid;
  // Create user's private space.
  $gid = gofast_og_create_private_space($account);
  if ($gid) {
    gofast_og_subscribe_user($gid, $account, OG_STATE_ACTIVE, TRUE);
    $roles_query = og_roles('node', "private_space", $gid, FALSE, FALSE);
    foreach($roles_query as $rkey => $roles){ //We get the role IDs associated to the space
      if($roles == GOFAST_OG_ROLE_ADMIN){
        $admin_rid = $rkey;
      }
      if($roles == GOFAST_OG_ROLE_READ_ONLY){
        $readonly_rid = $rkey;
      }
      if($roles == GOFAST_OG_ROLE_STANDARD){
        $contributor_rid = $rkey;
      }
    }
    og_role_grant('node', $gid, $uid, $admin_rid);
  }

  //Acquire user_membership_waiting_build lock
  lock_wait("user_membership_waiting_build", 10);
  if(!lock_acquire("user_membership_waiting_build", 10)){
      drupal_set_message("Unable to lock membership_waiting_build variable", "error");
      return;
  }

  //We queue the new user to rebuild it's memberships
  $user_queue = variable_get("user_membership_waiting_build", "");
  $user_queue = json_decode($user_queue, TRUE);
  $user_queue[] = $uid;
  $user_queue = json_encode($user_queue);
  variable_set("user_membership_waiting_build", $user_queue);

  //Release user_membership_waiting_build lock
  lock_release("user_membership_waiting_build");
}

/*
 * Implements hook user_update
 */

function gofast_og_user_update(&$edit, $account, $category){
  $uid = $account->uid;

  //Acquire user_membership_waiting_build lock
  lock_wait("user_membership_waiting_build", 10);
  if(!lock_acquire("user_membership_waiting_build", 10)){
      drupal_set_message("Unable to lock membership_waiting_build variable", "error");
      return;
  }

  //We queue the new user to rebuild it's memberships
  $user_queue = variable_get("user_membership_waiting_build", "");
  $user_queue = json_decode($user_queue, TRUE);
  $user_queue[] = $uid;
  $user_queue = json_encode($user_queue);
  variable_set("user_membership_waiting_build", $user_queue);

  //Release user_membership_waiting_build lock
  lock_release("user_membership_waiting_build");
}

function gofast_og_user_rebuild_base_memberships($account, $force = false){
  variable_set('reset_membership_processing', '1');
  //We will subscribe new users to root spaces and to public spaces according to
  //Their extranet flag and the plateform's configuration

  //First, we subscribe the user to the 4 root spaces as read only or admin,
  //Regarding if it's a plateform admin
  $uid = $account->uid;
  $root_spaces = gofast_og_get_root_spaces(FALSE, TRUE);

  foreach($root_spaces as $nid){ //We fetch into the root spaces (excluding private spaces)
     $isMember = (og_get_membership('node', $nid, 'user', $uid) != FALSE);
    if ($isMember){
        //check if the role is correctly set on the root space
        $current_role = gofast_og_get_user_final_roles_for_space('node',$nid , $uid);
        if(count($current_role) > 0 && $force == false){
            continue;
        }
    }
    $node = node_load($nid);
    $bundle = $node->type;

    if($bundle == 'public'){ //We save the public node to use it later.
      $public = $node;
    }

    $roles_query = og_roles('node', $bundle, $nid, FALSE, FALSE);
    foreach($roles_query as $rkey => $roles){ //We get the role IDs associated to the space
      if($roles == GOFAST_OG_ROLE_ADMIN){
        $admin_rid = $rkey;
      }
      if($roles == GOFAST_OG_ROLE_READ_ONLY){
        $readonly_rid = $rkey;
      }
      if($roles == GOFAST_OG_ROLE_STANDARD){
        $contributor_rid = $rkey;
      }
    }

    //The user is subscribed without any role
    gofast_og_subscribe_user($nid, $uid);
    og_role_revoke('node', $nid, $uid, $readonly_rid);
    og_role_revoke('node', $nid, $uid, $contributor_rid);
    og_role_revoke('node', $nid, $uid, $admin_rid);

    if(gofast_user_is_business_admin($account) && $bundle != "public"){
      //If user is a plateform administrator, we grant him the administrator role in the root space
      og_role_grant('node', $nid, $uid, $admin_rid);
    }
    else{
      //Either, we grant him RO role
      og_role_grant('node', $nid, $uid, $readonly_rid);
    }
  }

  //If user isn't an extranet user, we grant him access to public spaces, according to the current public config
  if(!gofast_user_is_extranet($account)){
     if(!$public->nid){
     $root_spaces = gofast_og_get_root_spaces(FALSE, TRUE);
      foreach($root_spaces as $nid){ //We fetch into the root spaces (excluding private spaces)
        $node = node_load($nid);
        $bundle = $node->type;
        if($bundle == 'public'){
          $public = $node;
        }
      }
    }

    //Retrieve saved spaces configuration
    $space_defaults = gofast_admin_get_space_defaults();

    $public_contributions = $spaces_defaults['public_contrib'];
    $public_ids = gofast_og_get_children($public->nid, TRUE, FALSE, TRUE);

    foreach($public_ids as $nid){ //Fetching into all public subspaces

      $roles_query = og_roles('node', 'public', $nid, FALSE, FALSE);
      foreach($roles_query as $rkey => $roles){ //We get the role IDs associated to the space
        if($roles == GOFAST_OG_ROLE_ADMIN){
          $admin_rid = $rkey;
        }
        if($roles == GOFAST_OG_ROLE_READ_ONLY){
          $readonly_rid = $rkey;
        }
        if($roles == GOFAST_OG_ROLE_STANDARD){
          $contributor_rid = $rkey;
        }
      }

      //The user is subscribed without any role
      gofast_og_subscribe_user($nid, $uid);
      og_role_revoke('node', $nid, $uid, $readonly_rid);
      og_role_revoke('node', $nid, $uid, $contributor_rid);
      og_role_revoke('node', $nid, $uid, $admin_rid);

      if($public_contributions){
        //We grant the user contributor role in the space
        og_role_grant('node', $nid, $uid, $contributor_rid);
      }
      else{
        //Either, we grant him RO role
        og_role_grant('node', $nid, $uid, $readonly_rid);
      }
    }
  }
  else{
    //We unsubscribe the user from public spaces
    if(!$public->nid){
     $root_spaces = gofast_og_get_root_spaces(FALSE, TRUE);
      foreach($root_spaces as $nid){ //We fetch into the root spaces (excluding private spaces)
        $node = node_load($nid);
        $bundle = $node->type;
        if($bundle == 'public'){
          $public = $node;
        }
      }
    }

    og_role_revoke('node', $public->nid, $uid, $readonly_rid);
    og_role_revoke('node', $public->nid, $uid, $contributor_rid);
    og_role_revoke('node', $public->nid, $uid, $admin_rid);
    gofast_og_unsubscribe_user($public->nid, $uid);

    $public_ids = gofast_og_get_children($public->nid, TRUE, FALSE, TRUE);
    $readonly_rid = "";
    $contributor_rid = "";
    $admin_rid  = "";
    foreach($public_ids as $nid){ //Fetching into all public subspaces

      $roles_query = og_roles('node', 'public', $nid, FALSE, FALSE);
      foreach($roles_query as $rkey => $roles){ //We get the role IDs associated to the space
        if($roles == GOFAST_OG_ROLE_ADMIN){
          $admin_rid = $rkey;
        }
        if($roles == GOFAST_OG_ROLE_READ_ONLY){
          $readonly_rid = $rkey;
        }
        if($roles == GOFAST_OG_ROLE_STANDARD){
          $contributor_rid = $rkey;
        }
      }
      og_role_revoke('node', $nid, $uid, $readonly_rid);
      og_role_revoke('node', $nid, $uid, $contributor_rid);
      og_role_revoke('node', $nid, $uid, $admin_rid);
      gofast_og_unsubscribe_user($nid, $uid);
    }

    //remove user from public userlist if any
     $pnid = variable_get("public_userlist", NULL);
      if($pnid){
            $userlist = node_load($pnid);
            $ulid = $userlist->field_userlist_ulid[LANGUAGE_NONE][0]['value'];
            gofast_og_unsubscribe_user($pnid, $uid);
            og_role_revoke('node', $pnid, $uid, $admin_rid);

            $userlist_entity = entity_load_single('userlist', $ulid);
            $members = $userlist_entity->field_userlist_members[LANGUAGE_NONE];

            foreach($members as $key=>$member){
               if($member["value"] == $uid){
                   unset($members[$key]);
                   $userlist_entity->field_userlist_members[LANGUAGE_NONE] = $members;
                   entity_save('userlist', $userlist_entity);
              }
            }


      }
  }
  variable_set('reset_membership_processing', '0');
}

/**
 * Creates a private space for a given user.
 *
 * @param $account
 *  The account object of the user.
 *
 * @return $gid
 *  The space id of the newly created organisation, or FALSE otherwise.
 */
function gofast_og_create_private_space($account) {
  if (!isset($account)) {
    watchdog('gofast_og', 'No account object, cannot create private space');
    return FALSE;
  }

  $title = t('My Personal Space', array(), array('langcode' => $account->language, 'context' => 'gofast'));
  $options = array(
    'access' => GOFAST_OG_GROUP_ACCESS_PRIVATE,
    'author' => $account,
    'description' => t('This is your personal space, only you can access and edit contents in this space.', array(), array('context' => 'gofast:gofast_og')) . ' ' .
      t('However, it is still quite possible for you to share a personal content in any other space you can access.', array(), array('context' => 'gofast:gofast_og'))
  );

  $ret = gofast_og_create($title, 'private_space', $options);

  if ($ret !== TRUE) {
    $message = '';
    foreach ((array) $ret as $key => $value) {
      $message .= "$key : $value <br />";
    }
    drupal_set_message($message, 'error');
    return FALSE;
  }

  // Get newly created organisation's gid.
  $query = db_select('node');
  $query->addExpression('MAX(nid)');
  $gid = $query->condition('type', 'private_space')->execute()->fetchField();

  return $gid;
}

/**
 * Returns user's private space.
 *
 * @param object|null $account [optional]
 *   A user account. Defaults to the current user.
 *
 * @param boolean $full [optional]
 *   Whether or not to return a full node object (or nid). Defaults to TRUE.
 *
 * @return mixed
 *   An OG node object or its nid depending on $full, FALSE if an error occured.
 */
function gofast_og_get_user_private_space($account = NULL, $full = TRUE) {
  global $user;

  $account = isset($account->uid) && isset($account->{GOFAST_OG_USER_PRIVATE_SPACE}) ? $account : user_load($user->uid);
  $nid = isset($account->{GOFAST_OG_USER_PRIVATE_SPACE}[LANGUAGE_NONE][0]['target_id']) ? $account->{GOFAST_OG_USER_PRIVATE_SPACE}[LANGUAGE_NONE][0]['target_id'] : FALSE;

  if (!$nid) {
    watchdog('gofast og', 'Failed to load %username\'s private space.', array('%username' => $account->name));
    return FALSE;
  }

  return $full ? node_load($nid) : $nid;
}

/**
 * Preprocessor for Node template.
 *
 * Enrich non-space nodes with the list of spaces that the node belongs to.
 */
function gofast_og_preprocess_node(&$variables) {
  global $user;
  $node = $variables['node'];

  if (gofast_og_is_space($node)) {
    $is_adm = gofast_user_is_adm();
    $is_manager = og_user_access('node', $node->nid, 'administer group');

    $can_access = gofast_og_node_access($node, 'view', $user);

    $membership = og_get_membership('node', $node->nid, 'user', $user->uid);
    $isMember = ($membership != FALSE && $membership->state != OG_STATE_PENDING);

    //check membership from userlist
    if( ! $isMember){
      $isMember = gofast_userlist_og_is_user_member_of_space($node->nid, $user);
    }

    if( ($can_access === NODE_ACCESS_IGNORE && $user->uid !== 1) || $can_access === NODE_ACCESS_ALLOW && $isMember == FALSE){
        // TODO comportement specific here !
        // TAB HOME

        $variables['isMember'] = ($membership != FALSE);
        $groupCanBeJoin = FALSE;
        if( in_array($node->type, array('group', 'extranet'))){
          $groupCanBeJoin= TRUE;
        }
        $variables['groupCanBeJoin'] = $groupCanBeJoin;

        
        $homepage_article_nid = gofast_og_get_article_homepage_from_og($gid);
        if($homepage_article_nid){
            $homepage_article = node_load($homepage_article_nid);
        }
        $node_body_value = !empty($homepage_article->body) ? entity_metadata_wrapper('node', $homepage_article)->{'body'}->value->value() : t('No home page for this space.', array(), array('context' => 'gofast:gofast_og'));
        $variables['node_body'] = $node_body_value ;

        $variables['theme_hook_suggestions'][] = "node__og_space_restrict";

    }else{
      //$variables['node_body'] = $node_body;

      // TAB DOCUMENTS
      $variables['ajaxFileBrowser'] = 'Module AjaxFileBrowser disabled';
    if (module_exists('gofast_ajax_file_browser')) {

      //Required to be able to load ITHIt Desktop browser.
        drupal_add_library('gofast_ajax_file_browser', 'gofast_ajax_file_browser_desktop', FALSE);
        $variables['ajaxFileBrowser'] = theme('ajax_file_browser', array('node' => $node, 'user' => $user));
        $variables['gofast_ajax_file_browser_mobile_enabled'] = FALSE;
    }

    // TAB SPACE MEMBERS
    $variables['space_members'] = gofast_og_space_members_simple_block($node);

      $variables['theme_hook_suggestions'][] = "node__og_space";
    }
  }
}

function gofast_og_space_members_simple_block($node) {
  return "<div class='loader-blog'></div>";
}

function gofast_og_member_filter_form() {

  $form['#attributes'] = array('class' => array('form-inline'));

  $form['title'] = array(
    '#type' => 'item',
    '#title' => t('Filter members', array(), array('context' => 'gofast')),
    '#suffix' => '<br/>',
     '#attributes' => array(
        'class' => array(
          'form_group'
        )
      )
  );

  $form['filter_container'] = array(
      '#type' => 'container',
      '#attributes' => array(
        'class' => array(
          'form_group'
        )
      )
   );

  $form['filter_container']["member_search"] = array(
    '#type' => 'textfield',
   // '#title' => t('Filter members', array(), array('context' => 'gofast')),
    //'#description' => t('Enter the terms you wish to search for.'),
    '#autocomplete_path' => 'gofast_og_user_autocomplete',
    '#default_value' => '',
    '#attributes' => array('title' => t('Enter the terms you wish to search for.', array(), array('context' => 'gofast'))),
  );

  $form['filter_container']['actions'] = array(
      '#type' => 'actions',
      '#prefix' => '&nbsp;',
  );
  $form['filter_container']['actions']['apply_filters'] = array(
      '#type' => 'button',
      '#value' => t('Apply filters', array(), array('context' => 'gofast')),
  );
  $form['filter_container']['actions']['reset_filters'] = array(
      '#type' => 'button',
      '#value' => t('Reset filters', array(), array('context' => 'gofast')),
   );

  return $form;
}

/**
 * Get the space IDs of spaces a user is a pending member of.
 *
 * 'Pending' means the user is subscribed to the space but isn't an active
 * member yet. When a user has this membership state they are considered to
 * be of 'non-member' role.
 *
 * @param $account [optional]
 *   A user object to fetch space memberships for. Defaults to the current user.
 *
 * @return
 *   An array keyed by the OG membership ID and the OG space ID as the value.
 */
function gofast_og_get_user_pending_spaces($account = NULL) {
  $og_pending = og_get_entity_groups('user', $account, array(OG_STATE_PENDING));
  return isset($og_pending['node']) ? $og_pending['node'] : array();
}

/**
 * @todo
 *  - export code that generates paths in Gofast CMIS
 *  - keep only the og visible nodes part here
 *
 * Generates an absolute path for each spaces that are visible for the current user.
 * Exclude from spaces all the private spaces expect the user's private space.
 * Returns all the spaces or spaces that respond to specified bundle (space, organisation...).
 * @global type $user the current user (cannot be null)
 * @param type $bundles empty if we want all spaces for the user, otherwise only the spaces kind of the specified bundle(s)
 * @return type an array of all the spaces, with space id as key and space path as value.
 */
function gofast_og_get_user_visible_spaces($user = NULL, $full = FALSE, $bundles = array(), $exclude_root = FALSE) {
  $spaces_map = array();
  // @TODO : Here we get all the spaces, but we should only return spaces where user can contribute
  $all_og = array();
  if ($user !== NULL) {

    if($full){
      $all_og = gofast_og_get_spaces_by_user($user, TRUE, TRUE);
    }else{
      $all_og_gid = gofast_og_get_spaces_by_user($user, TRUE, FALSE);

      $query_og_info = db_select('node', 'n');
      $query_og_info->fields('n', array('nid', 'title', 'type', 'uid'));
      $query_og_info->condition('n.nid', array_keys($all_og_gid), 'IN');

      $results = $query_og_info->execute();

      if ($results->rowCount() > 0) {
        $all_og = $results->fetchAll();
      }
    }
  }
  else {
    $all_og = gofast_og_get_spaces_by_bundle($bundles);
  }

  $root_spaces_ids = gofast_og_get_root_spaces(FALSE, FALSE);
  // Loop og
  foreach ($all_og as $og) {

    if(!$full) {
      $og_item = $og->nid;
    }else{
      $og_item = $og;
    }

    if($exclude_root && in_array($og_item, $root_spaces_ids) ) {
      continue;
    }
    if ($og->type === 'private_space' && $og->uid !== $user->uid) {
      continue;
    }

    if(!empty($bundles)) {
      if(!in_array($og->type, $bundles)) {
        continue;
      }
    }
    $spaces_map[$og->nid] = $full ? $og : $og->title;
  }
  if(!$full) {
    natcasesort($spaces_map);
  }
  return $spaces_map;
}

/**
 * Implements hook_og_fields_info().
 *
 *  Define OG_USER_INHERITANCE_FIELD as we understand it, wasn't usable with OG
 *  Subgroups module.
 */
function gofast_og_og_fields_info() {
  $items = array();

  $allowed_values = array(
    OG_USER_INHERITANCE_SUBGROUP => t('Subgroups of this group will inherit its users.', array(), array('context' => 'gofast:gofast_og')),
    OG_USER_INHERITANCE_PARENT => t('Parents of this group will inherit its users.', array(), array('context' => 'gofast:gofast_og')),
    OG_USER_INHERITANCE_NONE => t('No user inheritance.', array(), array('context' => 'gofast:gofast_og')),
  );

  $items[OG_USER_INHERITANCE_FIELD] = array(
    'type' => array('group'),
    'description' => t('Determine if the subgroups of a group will inherit its users or if the parents of a group will inherit its users.', array(), array('context' => 'gofast:gofast_og')),
    'entity' => array('node'),
    'field' => array(
      'field_name' => OG_USER_INHERITANCE_FIELD,
      'no_ui' => TRUE,
      'type' => 'list_integer',
      'cardinality' => 1,
      'settings' => array('allowed_values' => $allowed_values, 'allowed_values_function' => ''),
    ),
    'instance' => array(
      'label' => t('Group user inheritance', array(), array('context' => 'gofast:gofast_og')),
      'default_value' => array(0 => array('value' => 1)),
      'required' => FALSE,
      'default_value' => NULL,
      'widget' => array(
        'type' => 'options_buttons',
        'module' => 'options',
      ),
      'view modes' => array(
        'full' => array(
          'label' => 'above',
          'module' => 'options',
          'type' => 'options_buttons',
        ),
        'teaser' => array(
          'label' => 'above',
          'module' => 'options',
         'type' => 'options_buttons',
        ),
      ),
    ),
  );

  return $items;
}

/**
 * Returns whether the given node is a "root space" or not. A root space is a
 * space that cannot have a parent space reference.
 */
function gofast_og_is_root_space($node) {
  $temps_o_debut = microtime(true);

  if (is_scalar($node)) {
    $node = node_load($node);
  }

  if (gofast_og_is_space($node)) {
    if ($dn = gofast_ldap_space_dn($node)) {
      $parent_dn = gofast_ldap_get_parent_dn($dn);
      $space_realm = gofast_ldap_og_get_realm($node->type);
      return $parent_dn === $space_realm;
    }
  }

  $temps_o_fin = microtime(true);
 // watchdog('OG is root space LOADING TIME', round($temps_o_fin - $temps_o_debut, 4));
  return FALSE;
}

/**
 * Returns the root space of a given space node.
 *
 * @param object $node
 *  The node from which to retrieve the root space.
 *
 * @param boolean $full [optional]
 *  Whether or not to load node objects. Defaults to FALSE.
 *
 * @return mixed
 *  A node id or node obecjt, depending on $full, or FALSE if an error occured.
 */
function gofast_og_get_root_space($node, $full = FALSE) {
  if (gofast_og_is_space($node)) {
    $space_realm = gofast_ldap_og_get_realm($node->type);
    $children = gofast_ldap_entry_get_children($space_realm);
    $root_entry = isset($children[0]) ? $children[0] : FALSE;
    if ($root_entry && isset($root_entry['dn'])) {
      $gid = gofast_ldap_gid_from_dn($root_entry['dn']);
      return $gid && $full ? node_load($gid) : $gid;
    }
  }
  return FALSE;
}

/**
 * Returns a list of the actual root spaces.
 *
 * @param boolean $full [optional]
 *  Whether or not to load node objects. Defaults to FALSE.
 *
 * @param boolean $exclude_private [optional]
 *  Whether or not to exclude private spaces.  Defaults to FALSE.
 *
 * @return Array
 *  An array of root spaces keyed by $gid.
 */
function gofast_og_get_root_spaces($full = FALSE, $exclude_private = FALSE) {
  $gids = array();
  $space_types = gofast_og_node_types();
  if ($exclude_private) {
    unset ($space_types['private_space']) ;
  }
  foreach ($space_types as $bundle => $label) {
    $space_realm = gofast_ldap_og_get_realm($bundle);
    $children = gofast_ldap_entry_get_children($space_realm);
    if (!empty($children)) {
      foreach ($children as $key => $child) {
        $root_entry = isset($child) ? $child : FALSE;
        if ($root_entry && isset($root_entry['dn'])) {
          $gid = gofast_ldap_gid_from_dn($root_entry['dn']);
          $gids[$gid] = $gid;
        }
      }
    }
  }
  return $gids && $full ? entity_load('node', $gids) : $gids;
}

/**
 * Given a space node and a user account, returns a list of referenceable space
 * node ids. A "referenceable" space means any node that could be set as parent
 * space of the given node (i.e. same node type, not the given space node nor
 * one of its descendants).
 * The list is based on user memberships and is filtered according to whether
 * he has "administer space" in each space.
 *
 * If no account is passed in, the list is based on all space nodes of the same
 * type. There is no fallback to the current user account.
 *
 * @param object $node
 *  The given space node for which to list parent space candidates.
 *
 * @param object $account [optional]
 *  A user object, defaults to NULL.
 *
 * @return array
 *  A list of referenceable space as an array whose keys are node IDs and values
 *  are OG objects (not full nodes).
 */
function gofast_og_get_referenceable_spaces($node, $account = NULL) {
  $gids = gofast_og_get_spaces_by_bundle(array($node->type));
  if (isset($account) && isset($account->uid)) {
    $managed = gofast_og_get_managed_spaces($account);
    $gids = array_intersect_key($gids, $managed);
  }
  $unref = isset($node->nid) ? array($node->nid => $node->nid) + gofast_og_get_children($node->nid, TRUE, FALSE, TRUE) : array();
  return array_diff_key($gids, $unref);
}

/**
 * Returns a list of orphan nodes (i.e. nodes without any space reference).
 *
 * @param boolean $full
 *  Whether or not to load full node objects., deffaults to FALSE.
 *
 * @return Array
 *  An array of orphan nodes keyed by nid, or an empty array if there is no result set.
 *  $full is FALSE, only node info from the node base table are returned.
 */
function gofast_og_get_orphans($full = FALSE) {
  $content_bundles = gofast_og_content_bundles();

  // Since EntityFieldQuery does not provide a way to match NULL values but for
  // some reason it allows the use of != NULL, first we retrieve the list of non
  // orphans and then we return the "mask" of the result set using db_select().
  // (@see https://www.drupal.org/node/1157006).

  $entities = (new EntityFieldQuery())
          ->addMetaData('account', user_load(1))
          ->entityCondition('entity_type', 'node')
          ->entityCondition('bundle', $content_bundles, 'IN')
          ->fieldCondition(GOFAST_OG_CONTENT_MEMBERSHIP_FIELD, 'target_id', 'NULL', '!=')
          ->addTag('og_membership')
          ->execute();

  $query = db_select('node', 'n')
          ->fields('n')
          ->condition('n.type', $content_bundles, 'IN');

  if (!empty($entities['node'])) {
    $query->condition('n.nid', array_keys($entities['node']), 'NOT IN');
  }

  $orphans = $query->execute()->fetchAllAssoc('nid');

  return $full ? entity_load('node', array_keys($orphans)) : $orphans;
}
/*
 * Function used to get all uids the $account has permission to view
 */
function gofast_og_get_all_uids_user_can_access($account = null){
   if($account == null){
        global $user;
        $account = user_load($user->uid);
   }

   if($account->uid == 1){
       //bypass for admin
       return false;
   }

  $visibility = variable_get('gofast_user_partitioning', GOFAST_USER_PARTITIONING_DEFAULT);
  $admin_visibility = variable_get('gofast_admin_visibility', GOFAST_ADMIN_VISIBILITY_DEFAULT);
  $admin_visibility_condition = ($admin_visibility == GOFAST_ADMIN_VISIBILITY_ON && gofast_user_is_adm($account));

  //business admin always bypass visibility
 if(gofast_user_is_business_admin($account)){
    //false mean there is no visibility restriction
    return false;
  }
  if (($visibility == GOFAST_USER_PARTITIONING_ON && $admin_visibility_condition == FALSE) || ($visibility == GOFAST_USER_PARTITIONING_ON_ONLY_EXTRANET && gofast_user_is_extranet() && $admin_visibility_condition == FALSE)) {

        $base_uid = $account->uid;

        $query = db_select('og_membership', 'ogm')
                ->fields('ogm', array('gid'))
                ->condition('ogm.etid', $base_uid)
                ->condition('ogm.state', array(1),'IN')
                ->condition('ogm.entity_type', array("user"),'IN');

        $query->addJoin('INNER', 'node', NULL, 'node.nid = ogm.gid');
        $query->condition('node.type', array("public", "private_space"),'NOT IN');



        $gids = $query->execute()->fetchAllKeyed(0, 0);
        $ul_account = gofast_userlist_og_get_groups_by_user($account, 'node', FALSE);
        $all_gids = $gids + $ul_account;

        //remove root spaces
        $root = gofast_og_get_root_spaces(FALSE, TRUE);
        $all_gids = array_diff_key($all_gids, $root);


        //$all_gids contain all gids the current user can access directly or not ( userlist )
        //Now we have to retrieve all uids correspondind to all users
        //
        //first get all uids from direct membership
        $string_all_gids = implode(",", $all_gids);
        $array_uids = array();
        $uids_direct_membership = db_query("SELECT etid FROM {og_membership} WHERE entity_type = 'user' AND gid IN ($string_all_gids)")->fetchAll();
        foreach($uids_direct_membership as $myobject){
            $array_uids[$myobject->etid] = intval($myobject->etid);
        }

        //then get all uids from indirect membership ( so all users who are members of all previous gids from userlists )
        $string_all_gids_from_ul = implode(",", $ul_account);
        //get all userslists members of all these gids
        $userlists_membership = db_query("SELECT etid FROM {og_membership} WHERE entity_type = 'userlist' AND gid IN ($string_all_gids)")->fetchAll();

        $array_uids_from_ul = array();
        if(count($userlists_membership) > 0){
            foreach($userlists_membership as $userlist_object){
               $ul_members = gofast_userlist_get_members($userlist_object->etid, FALSE);
               if(count($ul_members) > 0){
                   foreach($ul_members as $key=>$member_object){
                       $array_uids_from_ul[$key] = $key;
                   }
               }
            }
        }

        $final_array_uids = $array_uids + $array_uids_from_ul;

        unset($final_array_uids[1]);

        return $final_array_uids;
  }else{
      //false mean there is no visibility restriction
      return false;
  }
}

/**
 * Returns an array of spaces (OG node IDs) users which $uids are passed in may
 * have in common.
 *
 * @param array $uids
 *  An array of User IDs.
 *
 * @return Array
 *  An array of matched OG node IDs (both key and value), or FALSE if an error
 *  occured.
 */
function gofast_og_get_common_spaces(array $uids) {
  $default_uids = $uids;
  $uids = array_unique($uids);
  $base_uid = array_shift($uids);

  $query = db_select('og_membership', 'ogm')
          ->fields('ogm', array('gid'))
          ->condition('ogm.etid', $base_uid)
          ->condition('ogm.state', array(1),'IN')
          ->condition('ogm.entity_type', array("user"),'IN');

  $query->addJoin('INNER', 'node', NULL, 'node.nid = ogm.gid');
  $query->condition('node.type', array("public", "private_space"),'NOT IN');
  foreach ($uids as $key => $uid) {
    $query->addJoin('INNER', 'og_membership', NULL, '%alias.gid = ogm.gid AND %alias.etid = :uid', array(':uid' => $uid));
    $query->condition('ogm.state', array(1),'IN')
          ->condition('og_membership.entity_type', array("user"),'IN');
  }

  $common = $query->execute()->fetchAllKeyed(0, 0);
  if (!is_array($common)) {
    return FALSE;
  }

  $root = gofast_og_get_root_spaces(FALSE, TRUE);
  $gids = array_diff_key($common, $root);

  if(empty($gids)){
        //if no common spaces, also check memberships including userlists
        $account1 = new stdClass();
        $account1->uid = $default_uids[0];
        $ul_account_1 = gofast_og_get_spaces_by_user($account1,FALSE,FALSE,FALSE,TRUE);
        $account2 = new stdClass();
        $account2->uid = $default_uids[1];
        $ul_account_2 = gofast_og_get_spaces_by_user($account2,FALSE,FALSE,FALSE,TRUE);
        $common_userlists = array_intersect_key($ul_account_1, $ul_account_2);

        $gids = array_diff_key($common_userlists, $root);
  }
  return $gids;
}

/**
 * Helper returning available options/labels for space partitioning (whether or
 * not users can view spaces they are not member of).
 */
function gofast_og_partitioning_options() {
  return array(
    GOFAST_OG_PARTITIONING_OFF => t('Users can see all spaces.', array(), array('context' => 'gofast:gofast_og')),
    GOFAST_OG_PARTITIONING_ON => t('All users cannot see all spaces.', array(), array('context' => 'gofast:gofast_og')),
    GOFAST_OG_PARTITIONING_ON_ONLY_EXTRANET => t('Extranet cannot see all spaces.', array(), array('context' => 'gofast:gofast_og')),
  );
}

/**
 * Implements hook_form_FORM_ID_alter()
 */
function gofast_og_form_gofast_admin_settings_alter(&$form, &$form_state) {
  // Adds space partitioning config to the form.
  $form['visibility']['space_partitioning'] = array(
    '#type' => 'select',
    '#title' => t('Space Visibility', array(), array('context' => 'gofast')),
    '#options' => gofast_og_partitioning_options(),
    '#default_value' => variable_get('gofast_og_partitioning', GOFAST_OG_PARTITIONING_DEFAULT),
    '#description' => t('Choose whether or not to let users view spaces they are not member of.', array(), array('context' => 'gofast:gofast_og'))
  );

  $form['#submit'][] = 'gofast_og_form_gofast_admin_settings_submit';
}

/**
 * Gofast configuration form submit callback.
 */
function gofast_og_form_gofast_admin_settings_submit(&$form, &$form_state) {
  // Update space visibility setting.
  variable_set('gofast_og_partitioning', $form_state['values']['space_partitioning']);
}

/*
 * Generates global spaces view (accessible in Directories menu)
 * @param $space_type
 *    A string containing the type of space to display
 * @return
 *    HTML generated and formated display
 */

function gofast_og_spaces_view($space_type = 'all'){
  $page = "";
  $page .= "<div id='float_crumbs'></div><div style='height: 50px;'></div>"; //Implements the floating crumb path

  switch($space_type){
    case 'group':
      $name = 'Groups';
      break;
    case 'organisation':
      $name = 'Organisations';
      break;
    case 'public':
      $name = 'Public';
      break;
    case 'extranet':
      $name = 'Extranet';
      break;
    case 'all':
      $name = 'all';
      break;
    default:
      drupal_not_found();
      module_invoke_all('exit');
      drupal_exit();
      break;
    }
  if($name != 'all'){
    $gid = gofast_og_get_group_id_from_title($name, 'Sites/_'.$name);
  }
  else{
    $gid = 'all';
  }
  $page .= gofast_og_spaces_view_theme_descendants($gid);
  $page .= '  <div id="panel_ztree_og" class="panel panel-default">';
  $page .= '  <div class="panel-heading">'.t("@type navigation", array('@type' => t($name, array(), array('context' => 'gofast'))), array('context' => 'gofast:og')).'</div>';
  $page .= '    <div class="panel-body">';
  $page .= gofast_og_view_get_ztree($space_type); //Implements ztree
  $page .= '</div></div>';
  return $page;
}

/*
 * Generates themed descendants for the spaces view
 */

function gofast_og_spaces_view_theme_descendants($gid, $activity_filters = false){
  drupal_add_js(drupal_get_path('module', 'gofast_og') . "/gofast_og.js");
  global $user;
  $page = "";
  $roles = array();
  $spaces = array();
  if($gid == 'all'){
    foreach(array('Groups', 'Organisations', 'Public', 'Extranet') as $spaces_names){
      $gid = gofast_og_get_group_id_from_title($spaces_names, 'Sites/_'.$spaces_names);
      $spaces[$gid] = node_load($gid);
    }
  }
  else{
    $spaces = gofast_og_get_children($gid, FALSE, TRUE);
  }
  foreach($spaces as $nid => $node){
    $can_access = gofast_og_node_access($node, 'view', $user);
    if($can_access == NODE_ACCESS_DENY){
        continue;
    }
    $description = "";
    if(isset($node->field_description[LANGUAGE_NONE][0]['value'])){
      $description = $node->field_description[LANGUAGE_NONE][0]['value'];
    }

    $haveChilds = FALSE;
    foreach(gofast_og_get_children($nid, FALSE, FALSE) as $child){
      $child_node = node_load($child);
      $can_access = gofast_og_node_access($child_node, 'view', $user);
      if($can_access !== NODE_ACCESS_DENY){
          $haveChilds = TRUE;
          break;
      }
    }

    $isMember = (og_get_membership('node', $node->nid, 'user', $user->uid) != FALSE);

    //check membership from userlist
    $isMemberFromUserlist = gofast_userlist_og_is_user_member_of_space($node->nid, $user);

    //The individual membership has priority over userlist membership
    if ($isMember || $isMemberFromUserlist ) {
      $roles = gofast_og_get_user_final_roles_for_space('node', $node->nid, $user->uid);
    }


    $isPending = (!isset($roles) || empty($roles)) && ($isMember || $isMemberFromUserlist);

    $isJoinable = in_array($node->type, array('node', 'extranet'));

    $crumbs = gofast_node_get_crumb_path($node);
    unset($crumbs[0][0]);
    $path = "";
    foreach($crumbs[0] as $crumb){
      $path .= $crumb." => ";
    }
    $path = substr($path, 0, -3);
    $members_count = count(gofast_userlist_og_get_node_members($node->nid, array('user', 'userlist'), 'active')); //count(gofast_og_get_members($node, 'active'));
    $contributions_count = count(gofast_og_get_nodes($node));
    $space_attr = array(
      'nid'                   => $nid,
      'type'                  => ucfirst($node->type),
      'title'                 => $node->title,
      'description'           => $description,
      'members_count'         => $members_count,
      'contributions_count'   => $contributions_count,
      'haveChilds'            => $haveChilds,
      'isMember'              => (! $isMember) ? $isMemberFromUserlist : $isMember,
      'roles'                 => $roles,
      'path'                  => $path,
      'isPending'             => $isPending, //Will be set to true if we write a role in the associated theme
      'isJoinable'            => $isJoinable,
    );
    $page .= theme('gofast_og_spaces_view', $space_attr);
  }
  $page = "<div class='og_grid_level'>".$page."</div>";
  return $page;
}

/*
 * Generates a ztree to navigate into the og grid
 * @param $subject
 *  Filter by bundle
 */
function gofast_og_view_get_ztree($bundle = 'all'){
  global $user;
  $account = user_load($user->uid);
  $og_json = gofast_og_view_get_ztree_json($bundle, $account);
  libraries_load('ztree');
  $settings = array('data_tree' => $og_json, "is_document" => "true");
  drupal_add_js(array('gofast_og_tree' => $settings), 'setting');
  return "<div id='ztree_og_grid' class='ztree'></div>";
}

/*
 * Return the JSON used to create the ztree in the og grid
 * @param $subject
 *  Filter by bundle
 * @param $account : if not null, the permissions will be checked
 */
function gofast_og_view_get_ztree_json($bundle = 'all', $account = null, $activity_filters = false){
  global $user;
  if($account == null){
      $account = $user;
  }
  switch($bundle){
    case 'group':
      $name = 'Groups';
      break;
    case 'organisation':
      $name = 'Organisations';
      break;
    case 'public':
      $name = 'Public';
      break;
    case 'extranet':
      $name = 'Extranet';
      break;
    case 'all':
      $name = 'all';
      break;
    default:
      drupal_not_found();
      module_invoke_all('exit');
      drupal_exit();
      break;
    }
  if($name != 'all'){
    $gid = gofast_og_get_group_id_from_title($name, 'Sites/_'.$name);
  }
  else{
    $gid = 'all';
  }

  $og_json = array();
  $spaces = array();
  if($gid == 'all'){
    foreach(array('Groups', 'Organisations', 'Public', 'Extranet') as $spaces_names){
      $gid = gofast_og_get_group_id_from_title($spaces_names, 'Sites/_'.$spaces_names);
      $spaces[$gid] = gofast_og_get_children($gid, TRUE, FALSE, FALSE);
    }
  }
  else{
    $spaces = gofast_og_get_children($gid, TRUE, FALSE, FALSE);
  }

  //Building the JSON content

  $og_json[] = array(
      'id'    => '-1',
      'nId'   => '-1',
      'pId'   => '-1',
      'name'  => t("Spaces", array(), array('context' => 'gofast:og')),
    );
  $user_og_formatted = array();
  if ($account !== null) {
    $user_og = $account->og_user_node[LANGUAGE_NONE];
    foreach ($user_og as $key => $value) {
      $user_og_formatted[$value['target_id']] = $value['target_id'];
    }

    //get membership from user's userlists
    $groups_by_user = gofast_userlist_og_get_groups_by_user($account, 'node');
    foreach ($groups_by_user as $group_id) {
      $user_og_formatted[$group_id] = $group_id;
    }
  }
  //Check partitionning
  $partitioning = variable_get('gofast_og_partitioning', GOFAST_OG_PARTITIONING_DEFAULT);
  $admin_visibility = variable_get('gofast_admin_visibility', GOFAST_ADMIN_VISIBILITY_DEFAULT);

  $partitioning_enabled = FALSE;
  if($partitioning != GOFAST_OG_PARTITIONING_OFF){
      if($partitioning == GOFAST_OG_PARTITIONING_ON_ONLY_EXTRANET){
          //Partitionning applied only on extranet, check if the user is an extranet
          if(gofast_user_is_extranet($account)){
              $partitioning_enabled = TRUE;
          }
      }else{
          //Partitionnong is applied
          $partitioning_enabled = TRUE;
      }

    //business admin always bypass visibility
    if(gofast_user_is_business_admin($account)){
        $partitioning_enabled = FALSE;
     }
  }
  if($activity_filters){
      $partitioning_enabled = TRUE;
  }

  if($partitioning_enabled && ($admin_visibility == GOFAST_ADMIN_VISIBILITY_OFF || !gofast_user_is_adm($account))){
    //Recusivly check all spaces and compare them to flat user og spaces
    $spaces = gofast_og_view_recursive_partitionning_compare($spaces, $user_og_formatted);
  }

  foreach($spaces as $nid => $childs){

    $title = gofast_get_node_title($nid);

    $og_json[] = array(
      'id'    => $nid,
      'nId'   => $nid,
      'pId'   => -1,
      'name'  => $title,
    );
    if(!empty($childs)){
      $ref_og_json = &$og_json;
      gofast_og_view_get_ztree_json_recurse($ref_og_json, $nid, $spaces[$nid]);
    }
  }
  return drupal_json_encode($og_json);
}

/*
 * Recursivly compare a tree array of spaces id with a flat array to remove unwanted spaces
 */
function gofast_og_view_recursive_partitionning_compare($spaces, $user_og_formatted){
    foreach($spaces as $gid => $sub_spaces){
        if(!in_array($gid, $user_og_formatted)){
            unset($spaces[$gid]);
        }else{
            if(!empty($sub_spaces)){
                $spaces[$gid] = gofast_og_view_recursive_partitionning_compare($sub_spaces, $user_og_formatted);
            }
        }
    }

    return $spaces;
}

/*
 * Recursive function to build the ztree in the og grid view
 * @param &$og_json
 *  JSON array passed by reference
 * @param $pid
 *  The childs to recurse in
 */

function gofast_og_view_get_ztree_json_recurse(&$og_json, $pid, $childs){
  foreach($childs as $nid => $child){
    $title = gofast_get_node_title($nid);

    $og_json[] = array(
      'id'    =>  $nid,
      'nId'   => $nid,
      'pId'   => $pid,
      'name'  => $title,
    );
    if(!empty($child)){
      $ref_og_json = &$og_json;
      gofast_og_view_get_ztree_json_recurse($ref_og_json, $nid, $child);
    }
  }
}

/**
 * Replace called group sub spaces with descendants in view
 * @param type $content
 *  Result of page callback
 */
function gofast_og_spaces_view_ajax_theme_descendants($content){
  print $content;
  drupal_add_http_header('Status', '200 OK');
}

/*
 * Subscribe a user to a view in grid spaces view
 */

function gofast_og_spaces_request_action($gid, $action, $request_user = null, $message = null){

  drupal_add_js(drupal_get_path('module', 'gofast_og') . "/gofast_og.js");


  global $user;
  global $base_url;

  if(empty($request_user)){
    $request_user = $user;
  }else{
    $request_user = user_load($request_user);
  }

  switch($action){
    case 'join':
      gofast_user_request_groups(array($gid), $request_user->uid);

      //Prepare a mail for the space admins
      $userbdd = user_load($request_user->uid);
      $admins = get_all_admin_group($gid);
      $space = node_load($gid);
      $space_title = $space->title;
      $siteName = variable_get('site_name');

      $link = $base_url . "/node/" . $space->nid;
      $asking_user = '<img src="' . gofast_get_url_picture_by_id($userbdd->uid). '" alt="Information Icon" width="14" /> <a href="' . $base_url . '/user/' . $userbdd->uid .'" style="color: #337ab7; text-decoration: none;">' . gofast_user_display_name($userbdd) . '</a>';
      $space_link = '<a href="' . $link . '" style="color: #337ab7; text-decoration: none;">'. $space_title . '</a>'; 

      foreach($admins as $uid){
        $to = array();
        $to[] = array(
          'method' => 'to',
          'recpt' => $uid,
        );
        // we don't need to load the full admin object to get the first name and language
        $first_name = db_query("SELECT `ldap_user_givenname_value` FROM `field_revision_ldap_user_givenname` WHERE `entity_id` = :uid", array(':uid' => $uid))->fetchField();
        $language = db_query("SELECT `language` FROM `users` WHERE `uid` = :uid", array(':uid' => $uid))->fetchField();
        $l = array('context' => 'gofast:gofast_og', 'langcode' => $language);
        $subheader_message = t("The user {asking_user} asked to join the space {space_link}", array(), $l);

        $members_tab_link = '<a href="' . $link . '#gofastSpaceMembers" style="color: #337ab7; font-weight: 600; text-decoration: none;">' . t("members tab", array(), $l) . '</a>';
        $action_message = t("You are the administrator of this space, please go to the {members_tab_link} of the space to accept or decline", array(), $l);

        $subject = t('A user asked to join your space on @siteName', array("@siteName" => $siteName), $l);
        $title = t('Join request', array(), $l);
        $footer = t('Message sent from ', array(), $l)." ".$siteName;

        $body = theme('gofast_og_notify_pending', array(
          'l' => $l,
          'first_name' => $first_name,
          'site_name' => $siteName,
          'node_title' => $space_title,
          'node_link' => $link,
          'subheader_message' => $subheader_message,
          'subheader_message_tags' => [$asking_user, $space_link],
          'users' => [$userbdd],
          'action_message' => $action_message,
          'action_message_tags' => [$members_tab_link],
        ));
  
        $mail = array(
          'body' => $body,
          'title' => $title,
          'subject' => $subject,
          'footer' => $footer
        );
        gofast_mail_queue_api_queue_ext($mail,  $to, time());
      }

      //Mail to the user itself
      $to = array();
      $to[] = array(
        'method' => 'to',
        'recpt' => $request_user->uid,
      );

      $first_name = $request_user->ldap_user_givenname['und'][0]['value'];
      $l = array('context' => 'gofast:gofast_og', 'langcode' => $request_user->language);

      $subject = t('You asked to join a space on @siteName', array("@siteName" => $siteName), $l);
      $title = t('Join request', array(), $l);
      $footer = t('Message sent from ', array(), $l)." ".$siteName;
      $subheader_message = t("You asked to join the space {space_link}", array(), $l);
      $body = theme('gofast_og_notify_pending', array(
        'l' => $l,
        'first_name' => $first_name,
        'site_name' => $siteName,
        'node_title' => $space_title,
        'node_link' => $link,
        'subheader_message' => $subheader_message,
        'subheader_message_tags' => [$space_link],
        'skip_body' => TRUE,
      ));

      $mail = array(
        'body' => $body,
        'title' => $title,
        'subject' => $subject,
        'footer' => $footer
      );
      gofast_mail_queue_api_queue_ext($mail,  $to, time());

      break;
    case "join_preadd":
      if(variable_get('preadd_users') == null){
        $preadd_users_array[] = $request_user->uid;
      }else{
        $preadd_users_array = json_decode(variable_get('preadd_users'));
        $preadd_users_array[] = $request_user->uid;
      }

      variable_set('preadd_users', json_encode($preadd_users_array));
      break;
    case "join_preadd_send":
      if (variable_get('preadd_users') == null) {
        $preadd_users_array[] = $request_user->uid;
      } else {
        $preadd_users_array = json_decode(variable_get('preadd_users'));
        $preadd_users_array[] = $request_user->uid;
      }

      $business_admin_name = gofast_user_display_name(user_load($user->uid));
      $business_admin_avatar = gofast_get_url_picture_by_id($user->picture);
      $admins = get_all_admin_group($gid);
      $space = node_load($gid);
      $space_title = $space->title;
      $to = array();
      $siteName = variable_get('site_name');
      $link = $base_url . "/node/" . $space->nid;
      $users = [];
      foreach($preadd_users_array as $preadd_user_uid){
        // send user request
        gofast_user_request_groups(array($gid), $preadd_user_uid);
        $users[] = $preadd_user_uid;
      }

      //Prepare a mail for the space admins
      foreach($admins as $uid){
        $to = array();
        $to[] = array(
          'method' => 'to',
          'recpt' => $uid,
        );
        $first_name = db_query("SELECT `ldap_user_givenname_value` FROM `field_revision_ldap_user_givenname` WHERE `entity_id` = :uid", array(':uid' => $uid))->fetchField();
        $language = db_query("SELECT `language` FROM `users` WHERE `uid` = :uid", array(':uid' => $uid))->fetchField();
        $l = array('context' => 'gofast:gofast_og', 'langcode' => $language);

        $subject = format_plural(count($users), 'Administrator platform adding user request', 'Administrator platform adding users request', array(), $l);
        $title = t('Join request', array(), $l);
        $footer = t('Message sent from ', array(), $l)." ".$siteName;

        $business_support = '<img src="' . $business_admin_avatar . '" alt="Information Icon" width="14" /> <a href="' . $base_url . '/user/' . $user->uid .'" style="color: #337ab7; text-decoration: none;">' . $business_admin_name . '</a>';
        $space_link = '<a href="' . $link . '" style="color: #337ab7; text-decoration: none;">'. $space_title . '</a>'; 
        $subheader_message = format_plural(count($users), "{business_support} in charge of user support, asks you to add a new member in the space {space_link} of which you are an administrator", "{business_support} in charge of user support, asks you to add news members in the space {space_link} of which you are an administrator", array(), $l);
        $message = t("Message: @message", array("@message" => $message), $l);
        $members_tab_link = '<a href="' . $link . '#gofastSpaceMembers" style="color: #337ab7; font-weight: 600; text-decoration: none;">' . t("members tab", array(), $l) . '</a>';
        $members_tab_link = '<a href="' . $link . '#gofastSpaceMembers" style="color: #FFFFFF; font-size: 14px; font-weight: 600; text-decoration: none;" target="_blank">' . t("Manage Pending Members") . '</a>';
        $action_message = t("Please go to the space page {space_link}, on 'Member' tab to accept or refuse the request. It will only take you a few clicks.", array(), $l);
        $body = theme('gofast_og_notify_pending', array(
          'l' => $l,
          'first_name' => $first_name,
          'business_admin_name' => $business_admin_name,
          'site_name' => $siteName,
          'node_title' => $space_title,
          'node_link' => $link,
          'subheader_message' => $subheader_message,
          'subheader_message_tags' => [$business_support, $space_link],
          'message' => $message,
          'users' => user_load_multiple($users),
          'action_message' => $action_message,
          'action_message_tags' => [$space_link],
          'manage_members_tab_link' => $members_tab_link,
        ));

        $mail = array(
          'body' => $body,
          'title' => $title,
          'subject' => $subject,
          'footer' => $footer
        );

        gofast_mail_queue_api_queue_ext($mail,  $to, time());
      }

      break;
    case 'cancel':
      $membership = og_get_membership('node', $gid, 'user', $request_user->uid);
      gofast_og_unsubscribe_user($gid, $request_user->uid);
      //this allow to clear cache, in order to prevent bug if the account is saved before the cache is refreshed. See
      $membership->delete();
      break;
  }

  drupal_get_messages();
  $page= "ok";
  return $page;
}


function gofast_og_preadd_ajax_validation(){

  $nid = $_POST['nid'];
  $action = $_POST['action'];
  $user_id = $_POST['user_to_add'];
  $message = $_POST["message"];
  $user_preadd = user_load($user_id);
  $rid = $_POST['role_id'];

  $isMember = (og_get_membership('node', $nid, 'user', $user_preadd->uid) != FALSE);

  //check membership from userlist
  $isMemberFromUserlist = gofast_userlist_og_is_user_member_of_space($nid, $user_preadd);

  //The individual membership has priority over userlist membership
  if ($isMember || $isMemberFromUserlist) {
    $roles = gofast_og_get_user_final_roles_for_space('node', $nid, $user_preadd->uid);
  }

  $isPending = (!isset($roles) || empty($roles)) && ($isMember || $isMemberFromUserlist);

  if ($isPending == true) {
    $return = [
      "success" => false,
      "uid" => $user_id,
      "message" => t('This user have already a pending request in this space', array(), array('context' => 'gofast'))
    ];
  }else if ($isMember == true) {
    $return = [
      "success" => false,
      "uid" => $user_id,
      "message" => t('This user is already member of this space', array(), array('context' => 'gofast'))
    ];
  }else if ($isMemberFromUserlist == true) {
    $return = [
      "success" => false,
      "uid" => $user_id,
      "message" => t('This user is already member in a userlist of this space', array(), array('context' => 'gofast'))
    ];
  } else{
    gofast_og_spaces_request_action($nid, $action, $user_id, $message);
    //change asked role.
    //og_role_revoke doesn't work while membership is pending, so delete role manually
    $uid = $user_id;
    $bundle = node_load($nid)->type;
    $membership = og_get_membership('node', $nid, 'user', $uid);

    db_query("delete from {og_users_roles} where uid = ".$uid." and gid = ".$nid);
    watchdog("debug role grant", $membership->group_type." | ".$membership->gid." | ".$membership->etid." | ".trim($rid));

    og_role_grant($membership->group_type, $membership->gid, $membership->etid, trim($rid));


    $return = [
      "success" => true,
      "uid" => $user_id,
      "message" => "user pre-add send done, ok"
    ];
  }
  if($action == "join_preadd_send"){
    variable_del("preadd_users");
  }


  echo json_encode($return);
  exit;

}

/**
 * Ajax callback
 */
function gofast_og_spaces_ajax_request_action($content){
  print $content;
  drupal_add_http_header('Status', '200 OK');
}


/*
 * function that indicate if the given node must hide the "member" tab or not on the group page
 */
function gofast_og_is_entity_hide_members_tab($node){
    global $user;
    if($user->uid == 1){
        return false;
    }
    if($node->type == "private_space"){
       return true;
    }

    if(gofast_og_is_root_space($node)){
        return true;
    }

    if($node->type == 'public'){
      return true;
    }

    return false;
}


/**
 *
 * @param type $gid
 * @param type $user
 */
function gofast_og_membership_request($ajax, $gid, $curr_user = NULL){

  global $user;
  if( isset($curr_user)){
    gofast_user_request_groups( array($gid), $curr_user->uid);
  }else{
     gofast_user_request_groups( array($gid), $user->uid);
  }

  if($ajax){
    if (!isset($commands[0])) {
      $commands = array();
      $commands = array_merge($commands, gofast_ajaxification_get_toast_messages());
    }
    ajax_deliver(array('#type' => 'ajax', '#commands' => $commands));
  }else{
    return ;
  }
}

/**
 *
 * @param type $og_memberships
 * @return type
 */
function gofast_og_sendmail_members_groups($og_memberships = array(), $message = null){

  if(variable_get('reset_membership_processing', '0')){
    return;
  }
    $members = array();
    $members_uid = array(); //user
    $members_ulid = array(); //userlist

  if(!is_array($og_memberships)){
    //only one modification
    $group = $og_memberships->gid ;
    if (gofast_og_is_root_space($group)) {
      return;
    }

    $gids = array();
    $gids[] = $group;
    if($og_memberships->entity_type == 'userlist'){
        $members_ulid[] = $og_memberships->etid;
      }else{
        $members_uid[] = $og_memberships->etid;
      }
  }else{
    //several updates
    if(sizeof($og_memberships) ==  0 ){
      return;
    }

    $gids = array();
    foreach( $og_memberships as $og_membership){
      $gids[] = $og_membership->gid ;
      if($og_membership->entity_type == 'userlist'){
        $members_ulid[] = $og_membership->etid;
      }else{
        $members_uid[] = $og_membership->etid;
      }
     }

  }

  $groups = node_load_multiple($gids);
  if(sizeof($members_ulid) > 0){
    foreach($members_ulid as $ulid){
      $userlist_members = gofast_userlist_get_members($ulid);

      foreach($groups as $gid => $node_group){
        foreach($userlist_members as $uid => $theme_user){
          //Check if this User is member in current space
          $account = user_load($uid);
          $check = gofast_og_check_spaces_user($og_memberships->entity_type, $account, $gid);
          if($check){
            unset($userlist_members[$uid]);
          }
        }
      }
      $members = array_merge($members, user_load_multiple(array_keys($userlist_members)));
    }
  }
  $members = array_merge($members, user_load_multiple($members_uid));

  //Send notification to addedd user
  foreach($members as $member){
    gofast_og_sendmail_new_membership_user($member, $groups, $message);
  }

  $all_members['users'] = $members_uid;
  $all_members['userlists'] = $members_ulid;

  //Send notification to space administrator
  foreach($groups as $group){
    // gofast_og_sendmail_new_membership_space_admin($all_members, $group, $message);
  }
}


function gofast_og_sendmail_rejected_membership_user($user, $groups, $message){
  $site_name = variable_get('site_name', 'GoFast');
  $l = array('langcode' => $user->language, 'context' => 'gofast_og');
  $subject = t("Your request to join a space has been rejected", array(), $l); // subject of the message (that is seen before openning the message)
  $title = t("Your request to join a space has been rejected", array(), $l);
  $footer = t('Message sent from ', array(), $l).$site_name;

  $recpt = array();
  $recpt[] = array('recpt' => $user->mail, 'method' => 'to');


  $mess = NULL;
  if($message !== NULL ){
    $mess = $message;
  }

  $grps .= "<ul>";
  foreach ($groups as $group) {
    $item = gofast_cmis_item_get($group->field_folder_reference[LANGUAGE_NONE][0]['value'], TRUE);
    $path = str_replace('/Sites/', '', $item->properties['cmis:path']);
    $grps .= t("<li> !space (!path) </li>", array('!space' => $group->title, '!path' => $path), array('context' => 'gofast_og'));
  }
  $grps .= "</ul>";

  $body = theme('gofast_og_mail_reject_user_space', array(
    'site_name' => $site_name,
    'grps' => $grps,
    'subject' => $subject,
    'mess' => $mess,
    'l' => $l,
  ));

  $mail = array(
    'body' => $body,
    'title' => $title,
    'subject' => $subject,
    'footer' => $footer
  );
  gofast_mail_queue_api_queue_ext($mail,  $recpt, time());
}


/**
 * Send notification to concerned user (who was added to space)
 * @param type $member
 * @param type $groups
 */
function gofast_og_sendmail_new_membership_user($member, $groups, $message){

  $site_name = variable_get('site_name', 'GoFast');
  $l = array('langcode' => $member->language, 'context' => 'gofast_og');
  $subject = t("You have been added in new spaces", array(), $l); // subject of the message (that is seen before openning the message)
  $title = t("You have been added in new spaces", array(), $l);
  $footer = t('Message sent from ', array(), $l).$site_name;

  $recpt = array();
  $recpt[] = array('recpt' => $member->mail, 'method' => 'to');


  $mess = NULL;
  if($message !== NULL ){
    $mess = $message;
  }

  $grps .= "<ul>";
  foreach ($groups as $group) {
    $item = gofast_cmis_item_get($group->field_folder_reference[LANGUAGE_NONE][0]['value'], TRUE);
    $path = str_replace('/Sites/', '', $item->properties['cmis:path']);
    $grps .= t("<li> !space (!path) </li>", array('!space' => $group->title, '!path' => $path), array('context' => 'gofast_og'));
  }
  $grps .= "</ul>";

  $body = theme('gofast_og_mail_add_user_space', array(
    'site_name' => $site_name,
    'grps' => $grps,
    'subject' => $subject,
    'mess' => $mess,
    'l' => $l,
  ));

  $mail = array(
    'body' => $body,
    'title' => $title,
    'subject' => $subject,
    'footer' => $footer
  );
  gofast_mail_queue_api_queue_ext($mail,  $recpt, time());
}

/**
 * Send notification to concerned user (who was deleted from a space)
 * @param type $member
 * @param type $groups
 */
function gofast_og_sendmail_delete_membership_user($member, $groups, $message){

  $site_name = variable_get('site_name', 'GoFast');
  $l = array('langcode' => $member->language, 'context' => 'gofast_og');
  $subject = t("You have been removed from spaces", array(), $l); // subject of the message (that is seen before openning the message)
  $title = t("You have been removed from spaces", array(), $l);
  $footer = t('Message sent from ', array(), $l).$site_name;

  $recpt = array();
  $recpt[] = array('recpt' => $member->mail, 'method' => 'to');


  $mess = NULL;
  if($message !== NULL ){
    $mess = $message;
  }

  $grps .= "<ul>";
  foreach ($groups as $group) {
    $item = gofast_cmis_item_get($group->field_folder_reference[LANGUAGE_NONE][0]['value'], TRUE);
    $path = str_replace('/Sites/', '', $item->properties['cmis:path']);
    $grps .= t("<li> !space (!path) </li>", array('!space' => $group->title, '!path' => $path), array('context' => 'gofast_og'));
  }
  $grps .= "</ul>";

  $body = theme('gofast_og_mail_removed_user_space', array(
    'site_name' => $site_name,
    'grps' => $grps,
    'subject' => $subject,
    'mess' => $mess,
    'l' => $l,
  ));

  $mail = array(
    'body' => $body,
    'title' => $title,
    'subject' => $subject,
    'footer' => $footer
  );
  gofast_mail_queue_api_queue_ext($mail, $recpt, time());
}

/**
 * Send notification to concerned space administrator
 * @param type $group
 * @param type $users
 */
function gofast_og_sendmail_new_membership_space_admin($members, $group, $message){

  global $user;
  $userbdd = user_load($user->uid);
  $author_name = gofast_user_display_name($userbdd);

  $admins = get_all_admin_group($group->nid);

  $arrayMember = array();
  foreach ($members['users'] as $memb){
    array_push($arrayMember, $memb);
  }
  for ($i=0; $i <= count($admins); $i++){
    for ($z=0; $z <= count($arrayMember); $z++){
      if ($admins[$i] == $arrayMember[$z]){
        unset($admins[$i]); // remove the admin who also is the new added user in this group
      }
    }
  }
  foreach ($admins as $uid) {
    $admin = user_load($uid);
    $recptAdmin[] = array('recpt' => $admin->mail, 'method' => 'to');
  }
      $l = array('langcode' => $user->language, 'context' => 'gofast_og');
      $title = t('A user has been added to one of your spaces', array(), $l);
      $subject = $title;
      $footer = t('Message sent from @SiteName', array('@SiteName' => variable_get('site_name')), $l);
      $body = theme('gofast_og_notif_to_admin_when_new_subscription', array(
        'AuthorName' => $author_name,
        'l' => $l,
        'nameSpace' => $group->title,
        'members' => $members,
      ));


    $mail = array(
        'body' => $body,
        'title' => $title,
        'subject' => $subject,
        'footer' => $footer
    );
    gofast_mail_queue_api_queue_ext($mail,  $recptAdmin, time());
}


/**
 * Obsolete (MUST BE DELETED IF NOT USED)
 * @global type $user
 * @param type $og_membership
 * @return type
 */
function gofast_og_sendmail_user_added_group($og_membership){

    trigger_error("Deprecated function called.", E_USER_NOTICE);

//    global $user;
//
//    $group = node_load($og_membership->gid);
//    if(variable_get('reset_membership_processing', '0')){
//      return;
//    }
//    if(gofast_og_is_root_space($group)){
//      return;
//    }
//
//    $subject_user = t("You have been added to a new space", array(), array('context' => 'gofast'));
//    $subject_admin = t("A user has been added on a space", array(), array('context' => 'gofast'));
//
//    $title = t('Membership', array('context' => 'gofast'));
//    $footer = t('Message sent from Gofast Plateform', array(), array('context' => 'gofast'));
//
//    $group_user = user_load($og_membership->etid);
//
//
//    //don't send an email when the user is the group's creator
//    if($group->uid == $og_membership->etid){
//        return;
//    }
//
//    $recpt = array();
//
//    $recpt[] = array('recpt' => $group_user->mail, 'method' => 'to');
//    $item = gofast_cmis_item_get($group->field_folder_reference[LANGUAGE_NONE][0]['value'], TRUE);
//    $path = str_replace('/Sites/', '', $item->properties['cmis:path']);
//    $body = t("You have been added to the space !space (!path)", array('!space' =>  $group->title, '!path' => $path), array('context' => 'gofast'));
//    $body .= "<br \>";
//    $body .= t("Here is the corresponding message : ", array(), array('context' => 'gofast'));
//    $body .= "<p>".$og_membership->og_membership_request[LANGUAGE_NONE][0]["value"]."</p>";
//
//    $ret = gofast_mail_queue_api_send_mail($subject_user, $title, $footer, $body, $recpt);
//
//
//    //we also send an email to all admin of this groups
//    $admins = get_all_admin_group($og_membership->gid);
//    $recpt_admin = array();
//    foreach($admins as $uid){
//        $admin = user_load($uid);
//        $recpt_admin[] = array('recpt' => $admin->mail, 'method' => 'to');
//    }
//
//    $body_admin = t("The user !user has been added to the space !space (!path)", array('!user' => gofast_user_display_name($group_user), '!space' =>  $group->title, '!path' => $path), array('context' => 'gofast'));
//    $body_admin .= "<br \>";
//    if(isset($og_membership->og_membership_request[LANGUAGE_NONE][0]["value"])){
//      $body_admin .= t("Here is the corresponding message : ", array(), array('context' => 'gofast'));
//      $body_admin .= "<p>".$og_membership->og_membership_request[LANGUAGE_NONE][0]["value"]."</p>";
//    }
//    $ret = gofast_mail_queue_api_send_mail($subject_admin, $title, $footer, $body_admin, $recpt_admin);
}

/*
 * Function that return all the uid of administrator members of the given group
 */
function get_all_admin_group($gid) {
      $uids = array();
      $role_admin = array(GOFAST_OG_ROLE_ADMIN);

      $query = db_select('og_users_roles', 'ogur');
      $query->innerJoin('og_role', 'ogr', 'ogur.rid = ogr.rid');

      $rids = $query
          ->fields('ogur', array('uid'))
          ->condition('ogur.gid', $gid, '=')
          ->condition('ogur.uid', 1, '>')
          ->condition('ogr.name', $role_admin, 'IN')
          ->execute();

      foreach ($rids as $item) {
        $uids[] = $item->uid;
      }

      //retreive admin via userlist
      $query2 = db_select('gofast_og_userlists_roles', 'ogur');
      $query2->innerJoin('og_role', 'ogr', 'ogur.rid = ogr.rid');

      $userlist_rids = $query2
          ->fields('ogur', array('ulid'))
          ->condition('ogur.gid', $gid, '=')
          ->condition('ogr.name', $role_admin, 'IN')
          ->execute();

      foreach ($userlist_rids as $item) {
        $uids = array_merge($uids, array_keys(gofast_userlist_get_members($item->ulid)));
      }

      return array_unique($uids);
 }

/*
 * Implements hook_cron
 */
function gofast_og_cron(){
    global $conf;

   //Proceed with variable rebuild.
   $variables = array_map('unserialize', db_query('SELECT name, value FROM {variable}')->fetchAllKeyed());
   cache_set('variables', $variables, 'cache_bootstrap');
   $conf["membership_waiting_build"] = $variables["membership_waiting_build"];
   $conf["user_membership_waiting_build"] = $variables["user_membership_waiting_build"];

  //Acquire membership_waiting_build lock
  lock_wait("membership_waiting_build", 10);
  if(!lock_acquire("membership_waiting_build", 10)){
      watchdog("Lock error", "Unable to lock membership_waiting_build variable");
      return;
  }

  //Retrieve and clear the variable that contains the new nodes that needs to have their memberships rebuilt
  $membership_queue = variable_get('membership_waiting_build', "");
  $membership_queue = json_decode($membership_queue, TRUE);

  //If we have more than GOFAST_OG_MEMBERSHIP_QUEUE_MAX_VALUE elements, we queue again some elements for the next cron
  if(is_array($membership_queue) && count($membership_queue)>GOFAST_OG_MEMBERSHIP_QUEUE_MAX_VALUE){
    $membership_next_queue = array_slice($membership_queue, GOFAST_OG_MEMBERSHIP_QUEUE_MAX_VALUE);
    $membership_next_queue = json_encode($membership_next_queue);
    variable_set('membership_waiting_build', $membership_next_queue);
    $membership_queue = array_slice($membership_queue, 0, GOFAST_OG_MEMBERSHIP_QUEUE_MAX_VALUE);
  }
  else{
    variable_set('block_membership_queue', 0);
    variable_set('membership_waiting_build', "");
  }

  //Release membership_waiting_build lock
  lock_release("membership_waiting_build");

  if($membership_queue != ""){
    foreach($membership_queue as $nid){
      watchdog("Reset Membership", $nid);
      gofast_og_reset_membership(node_load($nid));
    }
  }

  //Acquire user_membership_waiting_build lock
  lock_wait("user_membership_waiting_build", 10);
  if(!lock_acquire("user_membership_waiting_build", 10)){
      drupal_set_message("Unable to lock membership_waiting_build variable", "error");
      return;
  }

  //Retrieve and clear the variable that contains the users that needs to have their memberships rebuilt
  $user_queue = variable_get('user_membership_waiting_build', "");
  $user_queue = json_decode($user_queue, TRUE);

  //If we have more than GOFAST_OG_MEMBERSHIP_QUEUE_MAX_VALUE elements, we queue again some elements for the next cron
  if(is_array($user_queue) && count($user_queue)>GOFAST_OG_MEMBERSHIP_QUEUE_MAX_VALUE){
    $user_next_queue = array_slice($user_queue, GOFAST_OG_MEMBERSHIP_QUEUE_MAX_VALUE);
    $user_next_queue = json_encode($user_next_queue);
    variable_set('user_membership_waiting_build', $user_next_queue);
    $user_queue = array_slice($user_queue, 0, GOFAST_OG_MEMBERSHIP_QUEUE_MAX_VALUE);
  }
  else{
    variable_set('user_membership_waiting_build', "");
  }

  //Release user_membership_waiting_build lock
  lock_release("user_membership_waiting_build");

  if($user_queue != ""){
    foreach($user_queue as $uid){
      gofast_og_user_rebuild_base_memberships(user_load($uid));
    }
  }

  //check if some users must be promoted or unpromoted manager
  $gofast_users_to_unpromote_manager = variable_get("gofast_users_to_unpromote_manager", array());
  if(count($gofast_users_to_unpromote_manager) > 0){
     $role = user_role_load_by_name(GOFAST_ROLE_MANAGER);
      foreach($gofast_users_to_unpromote_manager as $uid){
           user_multiple_role_edit(array($uid), 'remove_role', $role->rid);
      }
  }
  variable_del("gofast_users_to_unpromote_manager");
    //check if some users must be promoted or unpromoted manager
  $gofast_users_to_promote_manager = variable_get("gofast_users_to_promote_manager", array());
  if(count($gofast_users_to_promote_manager) > 0){
     $role = user_role_load_by_name(GOFAST_ROLE_MANAGER);
      foreach($gofast_users_to_promote_manager as $uid){
          user_multiple_role_edit(array($uid), 'add_role', $role->rid);
      }
  }
  variable_del("gofast_users_to_promote_manager");

  //background spaces integrity check
  //at 01:00AM => Organisations
  //at 01:30AM => Groups
  //at 02:00AM => Extranet
  //at 02:30AM => Public
   $hour = date("G");
   $minute = date("i");
   if($hour == 01 || $hour == 02){
       if($minute == 00 || $minute == 30){
            if($hour == 01 && $minute == 00){
                $bundle = "organisation";
            }elseif($hour == 01 && $minute == 30){
                 $bundle = "group";
            }elseif($hour == 02 && $minute == 00){
                $bundle = "extranet";
            }else{
                $bundle = "public";
            }
            $start_timer = time();
            $query = new EntityFieldQuery();
              $result = $query->entityCondition('entity_type', 'node')
                ->entityCondition('bundle', $bundle)
                ->execute();
              $nodes = node_load_multiple(array_keys($result['node']));

            foreach($nodes as $node){
               gofast_resynchro_ldap_membership_one_space($node);
            }

            $end_timer = time()-$start_timer;
            watchdog("GoFAST DEBUG", 'END: synchronize '.count($nodes).' '.$bundle.' : '.$end_timer.' sec was needed.');

            gofast_cmis_webservice_force_alfresco_ldap_synch(true);
       }
   }


}

/*
 * Reset the memberships of the given space.
 * Warning : May be use in a cron due to possible performance leaks
 * @param $node
 *    The targeted space
 * @return true if the operation was completed, false otherwise
 */
function gofast_og_reset_membership($node = NULL){
  if(is_numeric($node)){
    $node = node_load($node);
  }
  variable_set('reset_membership_processing', '1');
  if($node == NULL){
    variable_set('reset_membership_processing', '0');
    return false;
  }
  $nid = $node->nid;
  $bundle = $node->type;
  $creator = $node->uid;

  if(!gofast_og_is_space($node) || $bundle == 'private_space'){
    variable_set('reset_membership_processing', '0');
    return false;
  }

  //Delete all space's memberships
  foreach(gofast_og_get_members($node) as $uid){
    gofast_og_unsubscribe_user($nid, $uid);
  }
  $roles_query = og_roles('node', $bundle, $nid, FALSE, FALSE);
  foreach($roles_query as $rkey => $roles){
    if($roles == GOFAST_OG_ROLE_ADMIN){
      $admin_rid = $rkey;
    }
    if($roles == GOFAST_OG_ROLE_READ_ONLY){
      $readonly_rid = $rkey;
    }
    if($roles == GOFAST_OG_ROLE_STANDARD){
      $contributor_rid = $rkey;
    }
  }

  //Retrieve saved spaces configuration
  $space_defaults = gofast_admin_get_space_defaults();

  $public_contributions = $spaces_defaults['public_contrib'];
  if(gofast_og_is_root_space($node) || $node->type == 'public'){

    $users = array_diff(gofast_user_load_all(FALSE), array(0,1));
    foreach($users as $uid){
      if(!gofast_user_is_extranet(user_load($uid))){
        gofast_og_subscribe_user($nid, $uid);
        og_role_revoke('node', $nid, $uid, $readonly_rid);
        og_role_revoke('node', $nid, $uid, $contributor_rid);
        og_role_revoke('node', $nid, $uid, $admin_rid);
        if($public_contributions && !gofast_og_is_root_space($node)){
          og_role_grant('node', $nid, $uid, $contributor_rid);
        }
        else{
          og_role_grant('node', $nid, $uid, $readonly_rid);
        }
      }
    }

     if(gofast_og_is_root_space($node) && $node->type !== 'public'){
        $plateform_admins = gofast_user_load_multiple_by_roles(GOFAST_ROLE_ADMIN, 'name', FALSE);
            foreach($plateform_admins as $uid){
              gofast_og_subscribe_user($nid, $uid);
              og_role_revoke('node', $nid, $uid, $readonly_rid);
              og_role_revoke('node', $nid, $uid, $contributor_rid);
              og_role_revoke('node', $nid, $uid, $admin_rid);
              og_role_grant('node', $nid, $uid, $admin_rid);
            }
    }
  }
  else{
    gofast_og_subscribe_user($nid, $creator);
    og_role_revoke('node', $nid, $creator, $readonly_rid);
    og_role_revoke('node', $nid, $creator, $contributor_rid);
    og_role_revoke('node', $nid, $creator, $admin_rid);
    og_role_grant('node', $nid, $creator, $admin_rid);
  }

  if($node->type == "public"){
      $pnid = variable_get("public_userlist", NULL);

      if($pnid){
          $userlist = node_load($pnid);
          $ulid = $userlist->field_userlist_ulid[LANGUAGE_NONE][0]['value'];

          gofast_userlist_og_add_membership($nid, $ulid, $admin_rid);
      }
  }

  variable_set('reset_membership_processing', '0');
  return true;
 }

 /*
 * Reset the memberships of all spaces in the given bundle.
 * Warning: Never use this function in a thread that needs the client to wait.
 * @param $bundle
 *    The targeted bundle
 * @return true if the operation was completed, false otherwise
 */
function gofast_og_reset_memberships_by_bundle($bundle = NULL){
  if($bundle == NULL){ //We could reset all memberships of all nodes in this case but it's too dangerous.
    return false;
  }

  foreach(gofast_og_get_root_spaces(TRUE, TRUE) as $root){
    if($root->type == $bundle){
      gofast_og_reset_membership(node_load($root->nid));
      $space_ids = gofast_og_get_children($root->nid, TRUE, FALSE, TRUE);
    }
  }
  foreach($space_ids as $space){
    gofast_og_reset_membership(node_load($space));
  }
  return true;
 }

 /**
 * Returns all gids of a document
 */
function gofast_og_get_item_spaces($gid, $entity_type = 'node') {
  $ids = array();
  $query = db_select('og_membership', 'ogm')
    ->fields('ogm')
    ->condition('ogm.etid', $gid, '=')
    ->condition('ogm.group_type', $entity_type, '=');
  $result = $query->execute()->fetchAll();
  foreach ($result as $key => $value) {
    $ids[] = $value;
  }
  return $ids;
}

function gofast_og_can_delete_space($account, $space){
    if(!is_object($account)){
      global $user;
      $account = $user;
    }
    if(!is_object($space)){
     if(!empty(db_query("SELECT nid FROM node WHERE nid=:space", array(":space" => $space))->fetchAll())){
        $space = node_load($space);
      }else{
        return true;
      }
    }
    if($account->uid == 1){
        return true;
    }
    //first we check if the space has children
    $children = gofast_og_get_children($space->nid);
    if(count($children) > 0){
        return false;
    }

    //then we check if the user is admin of the space
    if (in_array('administrator member', gofast_og_get_user_final_roles_for_space('node', $space->nid, $account->uid), true)) {
        return true;
    }else{
        return false;
    }

  }

/* Function checks if a user already belongs to a given space
 * @params: Entity type, $account or $user, id space
 * @return $check : TRUE -> user is member, FALSE -> user not yet member
 */
function  gofast_og_check_spaces_user( $entity_type, $account, $space_id ){

    $check = FALSE;
    if( $entity_type == 'user' ){
        $userlists = gofast_userlist_get_userlists_by_user($account);
        foreach( $userlists as $userlist){
            $groups_userlist = gofast_userlist_og_get_groups_by_userlist( $userlist->ulid );
            foreach ($groups_userlist['node'] as $group_id) {
                if( $group_id == $space_id ){
                    $check = TRUE;
                    break;
                }
            }
        }
    }elseif($entity_type == 'userlist'){

      // Check if members is still member of the space
      $space_members = gofast_og_get_members(node_load($space_id));
      if(in_array($account->uid, $space_members)){
        $check = TRUE;
      }
    }

    return $check;
}



function gofast_og_modal_add_member_submit($form, &$form_state) {

  module_load_include('inc', 'gofast_og', 'gofast_og.admin');
  //temporary disactivate membership propagation to prevent random bugs

  global $must_propagate;
  $must_propagate = false;

  $space_id = $form_state['values']['gid'];
  $node = node_load($space_id);
  $role_id = null;
  $role_name = null;
  $default_role_name = '';

  //retrieve right role for the group
  foreach ($form_state['values']['roles'] as $key => $role) {
    if (is_string($role)){
      $role_name = $role;
      
    } else if(is_numeric($role) && $role != 0){
      $role_id = $role;
      $role_name = isset($role_id) ? og_role_load($role_id)->name : FALSE;
    }
  }

   if(isset($_SESSION["gids_bulk_actions"])){
       $gids =$_SESSION["gids_bulk_actions"];
   }else{
       $gids = array($space_id);
   }

  $json_user_userlist =   json_decode($form_state['input']['ac-list-tags-field-user-userlist']);

  foreach($gids as $gid){
    $space_id = $gid;

    //Get the right rid corresponding to node-type and given role-name
    $role_for_space = gofast_og_space_admin_get_node_role('node', $gid, $role_name);
    $role_id = array_key_first($role_for_space);

    foreach($json_user_userlist as $user_userlist){
      // --------------------  User Traitment --------------------//
      if($user_userlist->type == 'user'){
          $account = user_load_by_name($user_userlist->name);
          $default_role_name = gofast_og_get_user_default_role($account);
          $default_role_rid = array_key_first(gofast_og_space_admin_get_node_role('node', $space_id, $default_role_name));

          //Check if this User is member by userlist in current space
          $check = gofast_og_check_spaces_user($user_userlist->type, $account, $space_id );

          //before to add or edit the membership for this space and this user,
          $inherited = gofast_og_get_inherited_spaces($space_id, true);

          foreach ($inherited as $nid => $space) {
            $membership = og_get_membership('node', $nid, 'user', $account->uid);
            if (!$membership) {
              //if is root space and user role != UserSupport, only allow "readonly" as role
             if(gofast_og_is_root_space($nid) && ! gofast_user_is_business_admin(NULL, $account->uid)){
               $default_role_name = GOFAST_OG_ROLE_READ_ONLY;
               $ro_role_rid = array_key_first(gofast_og_space_admin_get_node_role('node', $nid, $default_role_name));
               gofast_og_space_admin_add_membership($nid, $account->uid, $ro_role_rid);
             }else{
               gofast_og_space_admin_add_membership($nid, $account->uid, $role_id ?: $default_role_rid);
             }             
           }
          }

          $membership = og_get_membership('node', $space_id, 'user', $account->uid);
          if (!$membership) {
            gofast_og_space_admin_add_membership($space_id, $account->uid, $role_id ?: $default_role_rid);

            $membership_data = array(
                'membership_action' => 'NMEM', // New Member
                'membership_type' => 'user',
                'membership_id' => $account->uid,
                'membership_name' => gofast_user_get_display_name_sql($account->uid)
            );


            // ----------------- ADD AUDIT FOR USER HERE -------------------
            //
            //
            //
            //
            //

            gofast_message_ext_create_og_membership_entity($node, $membership_data);

            //Send notifications
            $membership = og_get_membership('node', $space_id, 'user', $account->uid);
            $message = $form_state['values']['membership_fields']['og_membership_request'][LANGUAGE_NONE][0]['value'];

            if ($check == FALSE){
                gofast_og_sendmail_members_groups($membership, $message);
            }
          }
          else {
            gofast_og_space_admin_update_membership($space_id, $account->uid, $role_name ?: $default_role_name);
          }

      } else if($user_userlist->type == 'userlist'){
        // --------------------  UserList Traitment --------------------//

        $userlist = entity_load_single('userlist', $user_userlist->ulvalue);

        $default_role_name = GOFAST_OG_ROLE_READ_ONLY;
        $default_role_rid = array_key_first(gofast_og_space_admin_get_node_role('node', $space_id, $default_role_name));
        
        //before to add or edit the membership for this space and this userlist,
        $inherited = gofast_og_get_inherited_spaces($space_id, true);

        foreach ($inherited as $nid => $space) {
          $membership = og_get_membership('node', $nid, 'userlist', $userlist->ulid);
          if (!$membership) {
              gofast_userlist_og_add_membership($nid, $userlist->ulid, $default_role_rid);
          }
        }

        $membership = og_get_membership('node', $space_id, 'userlist', $userlist->ulid);
        if (!$membership) {
          gofast_userlist_og_add_membership($space_id, $userlist->ulid, $role_id ?: $default_role_rid);

          //Send notifications => TODO
          $membership = og_get_membership('node', $space_id, 'userlist', $userlist->ulid);
          $message = $form_state['values']['membership_fields']['og_membership_request'][LANGUAGE_NONE][0]['value'];


          $membership_data = array(
            'membership_action' => 'NMEM', // New Member
            'membership_type' => 'userlist',
            'membership_id' => $userlist->ulid,
            'membership_name' => $userlist->name
          );
          gofast_message_ext_create_og_membership_entity($node, $membership_data);

          //Log into audit
          gofast_userlist_audit_membership($node, $membership_data);

          gofast_og_sendmail_members_groups($membership, $message);
        } else {
          gofast_userlist_og_update_membership($space_id, $userlist->ulid, $role_name ?: $default_role_name);
        }
      }
    }
  }

  $must_propagate = true;
}

function gofast_og_modal_edit_member_submit($form, &$form_state){
  module_load_include('inc', 'gofast_og', 'gofast_og.admin');

  //temporary disactivate membership propagation to prevent random bugs
  global $must_propagate;
  $must_propagate = false;

  $space_id = $form_state['values']['gid'];
  $node = node_load($space_id);
  $current_membership = og_membership_load($form_state['values']['id']);

   //retrieve right role for the group
    foreach($form_state['values']['roles'] as $key=>$role){
       if(is_string($role)){
           $role_id = $role;
           $role_name = og_role_load($role_id)->name;
       }
    }

    if(isset($role_name)){
        gofast_og_space_admin_update_membership($space_id, $current_membership->etid, $role_name);
        $must_propagate = true;
    }else{

         $member_uid = $current_membership->etid;
         $group = node_load($current_membership->gid);
         gofast_og_space_admin_delete_membership($space_id, $current_membership->etid);

         gofast_og_sendmail_delete_membership_user(user_load($member_uid), array($group), NULL);

         $membership_data = array(
          'membership_action' => 'DMEM', // Remove Member
          'membership_type' => 'user',
          'membership_id' => $member_uid,
          'membership_name' => gofast_user_get_display_name_sql($member_uid)
        );
        gofast_message_ext_create_og_membership_entity($node, $membership_data);
    }

}

/*
 * Delete a space
 * @param $gid : Group ID
 */
function gofast_og_delete_space($gid){
  $commands = array();
  $render = "";

  ctools_include('modal');
  ctools_include('ajax');

  $render .= theme("gofast_og_delete_space", array('gid' => $gid));

  $commands[] = ctools_modal_command_display(t("Delete this space"), $render);

  print ajax_render($commands);
  exit;
}

function gofast_og_delete_space_process($gid, $action = NULL, $api = FALSE){
  $_POST['technically_save'] = TRUE;
  if(!isset($action) || !isset($gid)){
    return;
  }

  switch($action){
    case 'unmultifile_documents' :
      //This variable set to true means that we need to call this function multiple times to prevent timeout and overload
      $multiple = FALSE;

      //First, we need to find out all multifiled documents
      $multifiled = array_keys(gofast_cmis_get_all_multifilled_documents_from_gid($gid));

      if(count($multifiled) > 5){
        //We need to call this function multiple times to prevent timeout and overload
        $remaining = (count($multifiled)-5);
        $multifiled = array_slice($multifiled, 0, 5);
        $multiple = TRUE;
      }

      //We get the path of the space we want to delete
      $path = gofast_cmis_space_get_webdav_path($gid);

      //Then, we remove the multifiling of these documents
      foreach($multifiled as $nid){
        $node = node_load($nid);

        if($node->type == 'alfresco_item' || $node->type == 'article'){ //This is a document
          //We edit the list of locations of these items to remove their multifiling
          $parent = gofast_cmis_item_get_parent($node->{GOFAST_CMIS_REFERENCE_FIELD}[LANGUAGE_NONE][0]['value']);
          $parents_formatted = array();
          foreach($parent->objectList as $myparent){
            if(strpos($myparent->properties["cmis:path"], $path) === FALSE){
              $parents_formatted[] = $myparent->properties["cmis:path"];
            }
          }

          //Once done, we can apply the modifications
          unset($_POST);
          $_POST["value"] = $parents_formatted;
          $_POST["pk"] = $nid;
          $_POST["name"] = "field_emplacement";
          gofast_update_node_field();

          //Then, we retrieve once again the locations to check if everything is ok
          gofast_cmis_static_cache(node_load($nid, NULL, true)->{GOFAST_CMIS_REFERENCE_FIELD}[LANGUAGE_NONE][0]['value'] . '_parents', TRUE);
          $new_parent = gofast_cmis_item_get_parent(node_load($nid)->{GOFAST_CMIS_REFERENCE_FIELD}[LANGUAGE_NONE][0]['value']);
          $new_parents_formatted = array();
          foreach($new_parent->objectList as $myparent){
            $new_parents_formatted[] = $myparent->properties["cmis:path"];
          }

          if(!empty(array_diff($parents_formatted, $new_parents_formatted)) || !empty(array_diff($new_parents_formatted, $parents_formatted))){
            if($api === FALSE){
              print t('Unable to delete the location of ', array(), array('context' => 'gofast')) . $nid . '/' . node_load($nid)->title;
              exit;
            }else{
              return 500;
            }
          }
        }else{ //This is not a document
          $old_gids = array();
          $new_gids = array();

          //Unmultifile element
          gofast_og_unsubscribe_node($gid, $nid);
          foreach($node->og_group_content_ref[LANGUAGE_NONE] as $key=>$group){
              if($group["target_id"] == $gid){
                  unset($node->og_group_content_ref[LANGUAGE_NONE][$key]);
              }else{
                $old_gids[] = $group["target_id"];
              }
          }

          //Technically save the node
          $node = gofast_prepare_node_save_technically($node);
          $ruid = $node->revision_uid;
          node_save($node);
          db_update('node_revision')
            ->fields(array('uid' => $ruid))
            ->condition('nid', $node->nid)
            ->execute();

          //Check if the operation was successfull
          $node = node_load($nid, NULL, true);
          foreach($node->og_group_content_ref[LANGUAGE_NONE] as $key=>$group){
              $new_gids[] = $group["target_id"];
          }

          if(!empty(array_diff($new_gids, $old_gids)) || !empty(array_diff($old_gids, $new_gids))){
            if($api === FALSE){
              print t('Unable to delete the location of ', array(), array('context' => 'gofast')) . $nid . '/' . node_load($nid)->title;
              exit;
            }else{
              return 500;
            }
          }
        }
      }
      if($multiple == TRUE){
        if($api === FALSE){
          print $remaining;
        exit;
        }else{
          return $remaining;
        }
      }else{
        if($api === FALSE){
          print "OK";
        exit;
        }else{
          return "OK";
        }
      }
      break;
    case 'delete_documents':
      //This variable set to true means that we need to call this function multiple times to prevent timeout and overload
      $multiple = FALSE;

      //We retrieve all space content
      $content = gofast_og_get_content($gid, FALSE, TRUE);
      if(count($content)>10){
        //We need to call this function multiple times to prevent timeout and overload
        $remaining = (count($content)-10);
        $content = array_slice($content, 0, 10);
        $multiple = TRUE;
      }

      foreach($content as $nid){
        $_GET['nid'] = $nid;
        gofast_ajax_node_unpublish(null, null, FALSE, TRUE);
      }
       if($multiple == TRUE){
        if($api === FALSE){
          print $remaining;
        exit;
        }else{
          return $remaining;
        }
      }else{
        if($api === FALSE){
          print "OK";
        exit;
        }else{
          return "OK";
        }
      }
      break;
    case 'delete_folder':
      $repo_id = node_load($gid)->{GOFAST_CMIS_FOLDER_REFERENCE_FIELD}[LANGUAGE_NONE][0]['value'];
      gofast_cmis_item_remove_folder($repo_id, TRUE);
      if(gofast_cmis_item_get($repo_id, TRUE) == FALSE){
        if($api === false){
          echo "OK";
        }else{
          return "OK";
        }
      }else{
        if($api === false){
         echo t("Can't delete the folder", array(), array('context' => 'gofast:og'));
        }else{
          return 500;
        }
      }
      exit;
      break;
    case 'delete_drupal':
      variable_set('deleting_space_'.$gid, TRUE);
      if($api === false){
        echo "PROGRESS";
        fastcgi_finish_request();
       }

      set_time_limit(0);

      $space = node_load($gid);
      node_delete($gid);
      variable_del('deleting_space_'.$gid);
      global $user;

      $last_event_unserialized["mod_timestamp"] = time();
      $last_event_unserialized["mod_author"] = $user->uid;

      $last_event_serialized["mod_timestamp"] = time();
      $last_event_serialized["mod_author"] = $user->uid;
      $last_event_serialized["ruid"]["value"] = $user->uid;
      $last_event_serialized["nid"]['value'] = $gid;
      $last_event_serialized["status"]["from"] = 1;
      $last_event_serialized["status"]["to"] = 0;
      $last_event_serialized["mod_title"] = $space->title;
      $last_event_serialized = rawurlencode(serialize($last_event_serialized));

      gofast_audit_insert_line_audit($gid, "delete_space", $last_event_serialized, $last_event_unserialized);
      if($api === false){
        exit;
      }else{
        return "PROGRESS";
      }
      break;
    case 'delete_drupal_progression':
      if(variable_get('deleting_space_'.$gid, NULL) !== TRUE){
        if($api === false){
          echo "OK";
        exit;
          }else{
            return "OK";
          }
      }else{
        if($api === false){
          echo "PROGRESS";
         exit;
        }else{
          return "PROGRESS";
        }
      }
      break;
  }
}

/*
 * Implements gofast_api_RESSOURCE_ACTION
 * @ressource space
 * @action space
 */
function gofast_api_space_space($params){
    switch($params['method']){
        case 'GET':
            gofast_api_get_space_space($params);
          break;
        case 'PUT':
            gofast_api_put_space_space($params);
            break;
        case 'PATCH':
            gofast_api_patch_space_space($params);
          break;
        case 'DELETE':
            gofast_api_delete_space_space($params);
          break;
        default:
            gofast_api_not_implemented("This method");
            break;
    }
}

/*
 * Implements gofast_api_RESSOURCE_ACTION
 * @ressource space
 * @action member
 */
function gofast_api_space_member($params)
{
  switch ($params['method']) {
    case 'PUT':
      gofast_api_put_space_member($params);
      break;
     case 'PATCH':
      gofast_api_patch_space_member($params);
      break;
    case 'DELETE':
      gofast_api_delete_space_member($params);
      break;
    default:
      gofast_api_not_implemented("This method");
      break;
  }
}

function gofast_api_get_space_space($params){
  //Check content type
  if (strpos($params['Content-Type'], "application/json") === FALSE) {
    return gofast_api_not_implemented("This Content-Type");
  }

  //Check authentication
  global $user;
  if ($user->uid == 0) {
    gofast_api_not_authorized("Unavailable ressource for anonymous user");
  }

  //Check if we have a gid param
  if (isset($params['gid'])) {
    $gid = $params['gid'];
    if(!is_numeric($gid)){
      gofast_api_mandatory_parameter("gid must be numeric");
    }
  } else {
    gofast_api_mandatory_parameter("gid");
  }

  $space = node_load($gid);

  //Check if we retrieved a node
  if ($space == null || !in_array($space->type, array('group', 'organisation', 'extranet', 'public'), true)) {
    gofast_api_internal_server_error("Unable to load a space with gid : " . $gid);
  }

  // Get groupe data and groupe users data (role + uid) in the same array
  $members = gofast_og_get_members($space,'active');
  $result_members = array();
  foreach($members as $member){
    $role = gofast_og_get_user_roles($gid, $member);
    $result_members[] = array('uid'=> $member,
    'role_id'=> key($role),
    'role_name' => array_shift(array_values($role))
    );
  }

  $userlist = array();
  $userlists_ulid = gofast_userlist_og_get_group_members_properties($space, array(),null, 'node', array('userlist'));
    foreach($userlists_ulid['userlist'] as $key => $ulid ){
    $role_userlist = gofast_userlist_og_get_userlist_roles('node',$space->nid,$ulid,FALSE, TRUE);
    $userlist[] = array('ulid'=> $ulid,
    'role_id'=> key($role_userlist),
    'role_name' => array_shift(array_values($role_userlist))
    );
  }

  $result = array(
    'title' =>    $space->title,
    'type' =>    $space->type,
    'members' =>    $result_members,
    'userlist' => $userlist
    );

  gofast_api_success($result);
}

function gofast_api_patch_space_space($params){
  //Check content type
  if (strpos($params['Content-Type'], "application/json") === FALSE) {
    return gofast_api_not_implemented("This Content-Type");
  }

  //Check authentication
  global $user;
  if ($user->uid == 0) {
    gofast_api_not_authorized("Unavailable ressource for anonymous user");
  }

  //Check if we have a gid param
  if (isset($params['gid'])) {
    $gid = $params['gid'];
    if(!is_numeric($gid)){
      gofast_api_mandatory_parameter("gid must be numeric");
    }
  } else {
    gofast_api_mandatory_parameter("gid");
  }

  $space = node_load($gid);

  //Check if we retrieved a node
  if ($space == null || !in_array($space->type, array('group', 'organisation', 'extranet', 'public'), true)) {
    gofast_api_internal_server_error("Unable to load a space with gid : " . $gid);
  }

  //Check node access
  if (!node_access('update', $space)) {
    gofast_api_forbidden("You don't have the permission to update this space");
  }

  //The list of allowed fields
  $allowed_fields = array(
    'title',
    'body'
  );

  //Get edited fields
  $edited_fields = array();

  foreach ($params as $key => $param) {
    if (in_array($key, $allowed_fields, TRUE)) {
      //This is a requested change, check integrity of the provided values - only string allowed
      if (is_string($param)) {
        //Integrity verified, register for change
        $edited_fields[$key] = $param;
        continue;
      }else{
        gofast_api_mandatory_parameter("Bad format for field " . $key);
      }

      //Integrity verified, register for change
      $edited_fields[$key] = $param;
    }
  }

  //Check if we do have a field to edit
  if (count($edited_fields) < 1) {
    gofast_api_mandatory_parameter('field_XXX');
  }

  $output = array();

 foreach($edited_fields as $field_name => $field_data){
    $space->{$field_name} = $field_data;
    $output['new_'. $field_name] = $field_data;
  }

  // save changes
  node_save($space);
  $output['status'] = 'OK';
  gofast_api_success($output);
}

function gofast_api_put_space_space($params){
  //Check content type
  if (strpos($params['Content-Type'], "application/json") === FALSE) {
    return gofast_api_not_implemented("This Content-Type");
  }

  //Check authentication
  global $user;
  if ($user->uid == 0) {
    gofast_api_not_authorized("Unavailable ressource for anonymous user");
  }

  //Check if we have a gid param
  if (isset($params['gid'])) {
    $gid = $params['gid'];
    if(!is_numeric($gid)){
      gofast_api_mandatory_parameter("gid must be numeric");
    }
  } else {
    gofast_api_mandatory_parameter("gid");
  }

  //Check if we have a title param
  if (isset($params['title'])) {
    $title = $params['title'];
  } else {
    gofast_api_mandatory_parameter("title");
  }

  //Check if we have a body param
  if (isset($params['body'])) {
    $body = $params['body'];
  }

  $parent_space = node_load($gid);

  //Check if we retrieved a node
  if ($parent_space == null || !in_array($parent_space->type, array('group', 'organisation', 'extranet', 'public'), true)) {
    gofast_api_internal_server_error("Unable to load a space with gid : " . $gid);
  }

  //Check node access
  if (!in_array('administrator member', gofast_og_get_user_final_roles_for_space('node', $parent_space->nid, $user->uid), true)) {
    gofast_api_forbidden("You don't have the permission to create a space under " . $parent_space->title);
  }

    $options = array(
      'parent' => $parent_space->nid,
      'description' => 'Created from GoFAST API',
      'body' => $body,
      'author' => $user->uid
    );

    gofast_og_create($title, $parent_space->type, $options);

  gofast_api_success(array('gid' => $_POST['new_space_nid']));
}

function  gofast_api_delete_space_space($params){
  //Check content type
  if (strpos($params['Content-Type'], "application/json") === FALSE) {
    return gofast_api_not_implemented("This Content-Type");
  }

  //Check authentication
  global $user;
  if ($user->uid == 0) {
    gofast_api_not_authorized("Unavailable ressource for anonymous user");
  }

  //Check if we have a gid param
  if (isset($params['gid'])) {
    $gid = $params['gid'];
    if(!is_numeric($gid)){
      gofast_api_mandatory_parameter("gid must be numeric");
    }
  } else {
    gofast_api_mandatory_parameter("gid");
  }

  $space = node_load($gid);

  //Check if we retrieved a node
  if ($space == null || !in_array($space->type, array('group', 'organisation', 'extranet', 'public'), true)) {
    gofast_api_internal_server_error("Unable to load a space with gid : " . $gid);
  }

  //Check node access
  if (!node_access('delete',$space)) {
    gofast_api_forbidden("You don't have the permission to delete this space");
  }

  $result['status'] = "OK";
  $result['message'] = "Deleting Space Done !";

      echo json_encode($result);
      drupal_add_http_header('Content-Type', 'application/json');
      fastcgi_finish_request();

  $response_unmultifile_documents = gofast_og_delete_space_process($space->nid,'unmultifile_documents',TRUE);
  while($response_unmultifile_documents !== "OK"){
    $response_unmultifile_documents = gofast_og_delete_space_process($space->nid,'unmultifile_documents',TRUE);
  }

   $response_delete_documents = gofast_og_delete_space_process($space->nid,'delete_documents',TRUE);
  while($response_delete_documents !== "OK"){
    $response_delete_documents = gofast_og_delete_space_process($space->nid,'delete_documents',TRUE);
  }

   $response_delete_folder = gofast_og_delete_space_process($space->nid,'delete_folder',TRUE);
  while($response_delete_folder !== "OK"){
    $response_delete_folder = gofast_og_delete_space_process($space->nid,'delete_folder',TRUE);
  }

    gofast_og_delete_space_process($space->nid,'delete_drupal',TRUE);

   $response_delete_drupal_progression = gofast_og_delete_space_process($space->nid,'delete_drupal_progression',TRUE);
  while($response_delete_drupal_progression !== "OK"){
    $response_delete_drupal_progression = gofast_og_delete_space_process($space->nid,'delete_drupal_progression',TRUE);
  }

  //gofast_api_success($response,"200 OK","application/json",null,FALSE);
}


function gofast_api_put_space_member($params)
{
  //Check content type
  if (strpos($params['Content-Type'], "application/json") === FALSE) {
    return gofast_api_not_implemented("This Content-Type");
  }

  //Check authentication
  global $user;
  if ($user->uid == 0) {
    gofast_api_not_authorized("Unavailable ressource for anonymous user");
  }

  //Check if we have a gid param
  if (isset($params['gid'])) {
    $gid = $params['gid'];
    if (!is_numeric($gid)) {
      gofast_api_mandatory_parameter("gid must be numeric");
    }
  } else {
    gofast_api_mandatory_parameter("gid");
  }

  //Check if we have a uid or userlist node id  param
  if (isset($params['uid']) && !isset($params['ul_node_id'])) {
    $uid = $params['uid'];
    if (!is_numeric($uid)) {
      gofast_api_mandatory_parameter("uid must be numeric");
    }
  }else if(!isset($params['uid']) && isset($params['ul_node_id'])){
    $ul_node_id = $params['ul_node_id'];
    if (!is_numeric($ul_node_id)) {
      gofast_api_mandatory_parameter("ul_node_id must be numeric");
    }
  } else if (isset($params['uid']) && isset($params['ul_node_id'])) {
      gofast_api_mandatory_parameter("uid or ul_node_id only one param is accepted");
  }else {
    gofast_api_mandatory_parameter("uid or ul_node_id");
  }

  //Check if we have a role param
  if (isset($params['role'])) {
    $role = $params['role'];
  } else {
    gofast_api_mandatory_parameter("role");
  }

  if ($role != GOFAST_OG_ROLE_ADMIN && $role != GOFAST_OG_ROLE_STANDARD && $role != GOFAST_OG_ROLE_READ_ONLY) {
    gofast_api_mandatory_parameter("wrong data for field role");
  }

  $space = node_load($gid);

  //Check node access
  if (!node_access('update', $space)) {
    gofast_api_forbidden("You don't have the permission to modify members on this space");
  }

  //Check if we retrieved a node
  if ($space == null || !in_array($space->type, array('group', 'organisation', 'extranet', 'public'), true)) {
    gofast_api_internal_server_error("Unable to load a space with gid : " . $gid);
  }

  $members = gofast_userlist_og_get_group_members_properties($space, array(), null, 'node', array('user','userlist'));

  $roles_query = og_roles('node', $space->type, 0, FALSE, FALSE); //We get roles ID
  foreach ($roles_query as $rkey => $roles) {
    if ($roles == $role) {
      $rid = $rkey;
    }
    if ($roles == $role) {
      $rid = $rkey;
    }
    if ($roles == $role) {
      $rid = $rkey;
    }
  }


    if(isset($uid)){
    //user
    $node = user_load($uid);
       if ($node !== false) {
                if (!in_array($uid, $members["user"], true)) {
                    gofast_og_space_admin_add_membership($gid, $uid, $rid);
                    $output['type'] = 'user';
                    $output['status'] = 'OK';
                    gofast_api_success($output);
                } else {
        gofast_api_internal_server_error("User already exist in the indicate groupe");
                }
        }else{
      gofast_api_internal_server_error("Unable to load a user with id : " . $uid);
        }
    }else if(isset($ul_node_id)){
      //userlist
      $node = node_load($ul_node_id);
      $ulid = $node->field_userlist_ulid[LANGUAGE_NONE][0]['value'];
        if ($node !== false && $ulid !== null) {
                if (!in_array($ulid, $members["userlist"], true)) {
                  gofast_userlist_og_add_membership($gid, $ulid, $rid);
                  $output['type'] = 'userlist';
                  $output['status'] = 'OK';
                  gofast_api_success($output);
                } else {
        gofast_api_internal_server_error("Userlist already exist in the indicate groupe");
                }
         } else {
      gofast_api_internal_server_error("Unable to load a userlist with node id : " . $ul_node_id);
         }
    }
}

function gofast_api_patch_space_member($params){
  //Check content type
  if (strpos($params['Content-Type'], "application/json") === FALSE) {
    return gofast_api_not_implemented("This Content-Type");
  }

  //Check authentication
  global $user;
  if ($user->uid == 0) {
    gofast_api_not_authorized("Unavailable ressource for anonymous user");
  }

  //Check if we have a gid param
  if (isset($params['gid'])) {
    $gid = $params['gid'];
    if(!is_numeric($gid)){
      gofast_api_mandatory_parameter("gid must be numeric");
    }
  } else {
    gofast_api_mandatory_parameter("gid");
  }

  //Check if we have a uid or userlist node id  param
  if (isset($params['uid']) && !isset($params['ul_node_id'])
  ) {
    $uid = $params['uid'];
    if (!is_numeric($uid)) {
      gofast_api_mandatory_parameter("uid must be numeric");
    }
  } else if (!isset($params['uid']) && isset($params['ul_node_id'])) {
    $ul_node_id = $params['ul_node_id'];
    if (!is_numeric($ul_node_id)) {
      gofast_api_mandatory_parameter("ul_node_id must be numeric");
    }
  } else if (isset($params['uid']) && isset($params['ul_node_id'])) {
    gofast_api_mandatory_parameter("uid or ul_node_id only one param is accepted");
  } else {
    gofast_api_mandatory_parameter("uid or ul_node_id");
  }

      //Check if we have a new_rid param
  if (isset($params['new_role'])) {
    $new_role = $params['new_role'];
  } else{
    gofast_api_mandatory_parameter("new_role");
  }

  if($new_role != GOFAST_OG_ROLE_ADMIN && $new_role != GOFAST_OG_ROLE_STANDARD && $new_role != GOFAST_OG_ROLE_READ_ONLY){
    gofast_api_mandatory_parameter("wrong data for field new_role");
  }

  // control new role
  $space = node_load($gid);
  $members = gofast_og_get_members($space);



  //Check if we retrieved a node
  if ($space == null || !in_array($space->type, array('group', 'organisation', 'extranet', 'public'), true)) {
    gofast_api_internal_server_error("Unable to load a space with gid : " . $gid);
  }

  //Check node access
  if (!node_access('update', $space)) {
    gofast_api_forbidden("You don't have the permission to modify members on this space");
  }

  if (isset($uid)) {
    $node = user_load($uid);
    if ($node !== false) {
         $id = $uid ; // set id to user ID
    } else {
      gofast_api_internal_server_error("Unable to load a user with id : " . $uid);
    }

  }else if ($ul_node_id){
    $node = node_load($ul_node_id);
    $ulid = $node->field_userlist_ulid[LANGUAGE_NONE][0]['value'];
    if ($node !== false && $ulid !== null) {
      $id = $ulid; // set id to userlist ID
    } else {
      gofast_api_internal_server_error("Unable to load a userlist with node id : " . $ul_node_id);
    }
  }

    //Check cound of administrators in this space
    $users_admins = gofast_userlist_og_get_node_members_by_role($space->nid, array(OG_STATE_ACTIVE), "administrator member");

    if(count($users_admins) < 2 && $id == $users_admins[0]->etid){
    gofast_api_internal_server_error("You can't edit role of the last administrator of a space");
    }


   $userlists_ulid = gofast_userlist_og_get_group_members_properties($space, array(),null, 'node', array('userlist'));

    $roles_query = og_roles('node', $space->type, 0, FALSE, FALSE);//We get all roles IDs
    foreach($roles_query as $rkey => $roles){
      if($roles == $new_role){
        $new_rid = $rkey;
      }
      if($roles == $new_role ){
        $new_rid = $rkey;
      }
      if($roles == $new_role){
        $new_rid = $rkey;
      }
    }

  if(in_array($id, $members,true)){
     // Assign roles.
      $og_roles = og_get_user_roles("node", $gid, $id, FALSE);

      // deleting role from current user
      foreach (array_keys($og_roles) as $old_rid) {
        if (!in_array($old_rid, $new_rid)) {
          og_role_revoke("node", $gid, $id, $old_rid);
        }
      }
      og_role_grant('node', $gid, $id, $new_rid); // assign new role
      $output['type'] = 'user';
      $output['role'] = $new_role;
      $output['status'] = 'OK';
      gofast_api_success($output);
  }else if(isset($userlists_ulid["userlist"]) && in_array($id, $userlists_ulid["userlist"],true)){
    $role_userlist = gofast_userlist_og_get_userlist_roles('node',$space->nid,$id,FALSE, TRUE);
     // deleting role from current user
      foreach (array_keys($role_userlist) as $old_ulid) {
        if (!in_array($old_ulid, $new_rid)) {
            gofast_userlist_og_role_revoke_userlist('node', $gid, $id, $old_ulid);
        }
      }
    gofast_userlist_og_role_grant_userlist('node', $gid, $id, $new_rid);
      $output['type'] = 'userlist';
      $output['role'] = $new_role;
      $output['status'] = 'OK';
      gofast_api_success($output);
  }else{
    if (isset($uid)) {
      gofast_api_internal_server_error("User dose not exist in the indicate groupe");
    } else if ($ul_node_id) {
      gofast_api_internal_server_error("Userlist dose not exist in the indicate groupe");
    }
  }
}

function gofast_api_delete_space_member($params){

  //Check content type
  if (strpos($params['Content-Type'], "application/json") === FALSE) {
    return gofast_api_not_implemented("This Content-Type");
  }

  //Check authentication
  global $user;
  if ($user->uid == 0) {
    gofast_api_not_authorized("Unavailable ressource for anonymous user");
  }

  //Check if we have a gid param
  if (isset($params['gid'])) {
    $gid = $params['gid'];
    if(!is_numeric($gid)){
      gofast_api_mandatory_parameter("gid must be numeric");
    }
  } else {
    gofast_api_mandatory_parameter("gid");
  }

    //Check if we have a uid or userlist node id  param
    if (isset($params['uid']) && !isset($params['ul_node_id'])) {
      $uid = $params['uid'];
      if (!is_numeric($uid)) {
      gofast_api_mandatory_parameter("uid must be numeric");
      }
    } else if (!isset($params['uid']) && isset($params['ul_node_id'])) {
      $ul_node_id = $params['ul_node_id'];
      if (!is_numeric($ul_node_id)) {
        gofast_api_mandatory_parameter("ul_node_id must be numeric");
      }
    } else if (isset($params['uid']) && isset($params['ul_node_id'])) {
      gofast_api_mandatory_parameter("uid or ul_node_id only one param is accepted");
    } else {
      gofast_api_mandatory_parameter("uid or ul_node_id");
    }


  // control new role
  $space = node_load($gid);
  $members = gofast_og_get_members($space);

  //Check if we retrieved a node
  if ($space == null || !in_array($space->type, array('group', 'organisation', 'extranet', 'public'), true)) {
    gofast_api_internal_server_error("Unable to load a space with gid : " . $gid);
  }

  //Check node access
  if (!node_access('update', $space )) {
    gofast_api_forbidden("You don't have the permission to delete members on this space");
  }

    if (isset($uid)) {
    $node = user_load($uid);
    if ($node !== false) {
         $id = $uid ; // set id to user ID
    } else {
      gofast_api_internal_server_error("Unable to load a user with id : " . $uid);
    }

  }else if ($ul_node_id){
    $node = node_load($ul_node_id);
    $ulid = $node->field_userlist_ulid[LANGUAGE_NONE][0]['value'];
    if ($node !== false && $ulid !== null) {
      $id = $ulid; // set id to userlist ID
    } else {
      gofast_api_internal_server_error("Unable to load a userlist with node id : " . $ul_node_id);
    }
  }


   //Check cound of administrators in this space
        $users_admins = gofast_userlist_og_get_node_members_by_role($space->nid, array(OG_STATE_ACTIVE), "administrator member");
        if(count($users_admins) < 2 && $id == $users_admins[0]->etid){
    gofast_api_internal_server_error("You can't remove the last administrator of a space");
        }

   $userlists_ulid = gofast_userlist_og_get_group_members_properties($space, array(),null, 'node', array('userlist'));

  if(in_array($id, $members,true)){

   $membership = og_get_membership('node', $space->nid, 'user', $id);
     if($membership != false){
    $membership->delete();
     }else{
      gofast_api_internal_server_error("User already deleted");
     }
      $output['type'] = 'user';
  }else if(isset($userlists_ulid["userlist"]) && in_array($id, $userlists_ulid["userlist"],true)){
   $membership = og_get_membership('node', $space->nid, 'userlist', $id);
     if( $membership != false){
      $membership->delete();
     }else{
      gofast_api_internal_server_error("Userlist already deleted");
     }
      $output['type'] = 'userlist';
  }else{
    if (isset($uid)) {
      gofast_api_internal_server_error("User dose not exist in the indicate groupe");
    } else if ($ul_node_id) {
      gofast_api_internal_server_error("Userlist dose not exist in the indicate groupe");
    }
  }
      $output['message'] = 'The membership was removed.';
      $output['status'] = 'OK';
  gofast_api_success($output);
}


/**
 * Return the higher role for the given space
 * This function take into account both individual membership and userlist membership
 * @param type $group_type
 * @param type $gid
 * @param type $uid
 * @param type $include
 * @param type $check_active
 *
 * @return array of role.
 */
function gofast_og_get_user_final_roles_for_space($group_type, $gid, $uid = NULL, $include = TRUE, $check_active = TRUE) {

  $rids = array();
  $final_rids = array();

  //get user indidual roles anyway
  $rids = gofast_og_get_user_roles($gid, $uid);


  if (!module_exists('gofast_userlist')) {
    $final_rids = $rids;
  }
  else { //if userlist enable, get userlist's roles
    if ($uid != NULL && is_numeric($uid)) {
      $account = user_load($uid);
    }
    else {
      global $user;
      $account = $user;
    }

    //Get user userlists
    $userlists = gofast_userlist_og_get_node_members($gid, array('userlist'));

    foreach ($userlists as $userlist) {
      if (gofast_userlist_is_member_of($userlist->etid, $account->uid) == TRUE) {
        $rids = gofast_userlist_og_get_userlist_roles($group_type, $gid, $userlist->etid) + $rids;
      }
    }

    //Get the higher roles
    if(($key = array_search('administrator member', $rids) )  !== FALSE){
      $final_rids = array($key => $rids[$key]);
    }else if(($key = array_search('group contributor', $rids) )  !== FALSE){
      $final_rids = array($key => $rids[$key]);
    }else if (($key = array_search('read only member', $rids) )  !== FALSE){
      $final_rids = array($key => $rids[$key]);
    }
  }

  return $final_rids;
}

/**
 * Promote user to the role Manager if not already done
 * @param type $user
 */
function gofast_og_user_promote_to_manager($account) {
  $role_manager = user_role_load_by_name(GOFAST_ROLE_MANAGER);
  if (!gofast_user_is_manager($account)) {
    db_query("INSERT IGNORE INTO {users_roles} (rid, uid) VALUES ('" . $role_manager->rid . "','" . $account->uid . "')");
  }
}

/**
 * Unpromote user form Manager role if needed
 * @param type $account
 * @param type $gid
 * @return type
 */
function gofast_og_user_unpromote_from_manager($account, $gid) {

  // Check if the user has still access to administration tasks in at least one
  // of its space (excluding its private space and the current one).
  $spaces = gofast_og_get_spaces_by_user($account);
  $private_id = gofast_og_get_user_private_space($account, FALSE);

  foreach ($spaces as $_gid) {
    if ($gid == $_gid || $_gid == $private_id)
      continue;
    if (og_user_access('node', $_gid, 'administer group', $account)) {
      // User has still an administer access, do nothing.
      return;
    }
  }

  // User lost all OG privileges, safely remove its manager role.
  //$role = user_role_load_by_name(GOFAST_ROLE_MANAGER);
  //user_multiple_role_edit(array($uid), 'remove_role', $role->rid);
  $gofast_users_to_unpromote_manager = variable_get("gofast_users_to_unpromote_manager", array());
  $gofast_users_to_unpromote_manager[$account->uid] = $account->uid;
  variable_set('gofast_users_to_unpromote_manager', $gofast_users_to_unpromote_manager);

}

function gofast_api_space_members($params){
    //Check content type
    if(strpos($params['Content-Type'], "application/json") === FALSE){
        gofast_api_not_implemented("This Content-Type");
    }

    //Check method
    if($params['method'] !== 'GET'){
        gofast_api_not_implemented("This method");
    }

    //Check authentication
    global $user;
    if($user->uid == 0){
       gofast_api_not_authorized("Unavailable ressource for anonymous user");
    }

    //Check if we have a nid param
    if(isset($params['nid'])){
        $nid = $params['nid'];
    }else if (isset($params['path'])){
        $path = $params['path'];
        $nid = gofast_ajax_file_browser_get_nid_from_href($path);
    }else{
        gofast_api_mandatory_parameter("nid or path");
    }

    //Chech space integrity
    $node = node_load($nid);
    if($node == null || !in_array($node->type, array('group', 'organisation', 'public', 'extranet'))){
        gofast_api_internal_server_error("Bad node parameter provided");
    }

    $users = gofast_og_get_members_userlist_included(node_load($nid),'active');
//    print_r($users); exit;
    $output = array();
    foreach($users as $user_member){
        $user_member_load = user_load($user_member);
        if($user_member_load->status == 1){
            $role_name = array_shift(gofast_og_get_user_final_roles_for_space('node',$nid,$user_member));
            $output[$role_name][]['uid'] = $user_member;
            $output[$role_name][]['name'] = $user_member_load->name;
        }
    }
    gofast_api_success($output);
}



/**
 * Retreive the roles for the given users on the given space
 * @param type $group_type
 * @param type $gid
 * @param type $uids : array of users uid
 */
function gofast_og_get_users_roles($group_type, $gid, $uids = array()){

  if (count($uids) == 0) {
    global $user;
    $uids = array($user->uid);
  }

  $rids = array();
  // Get the bundle of the group.
  $group = entity_load_single($group_type, $gid);
  list(,, $bundle) = entity_extract_ids($group_type, $group);

// Check if roles are overriden for the group.
  $query_gid = og_is_group_default_access($group_type, $gid) ? 0 : $gid;

  $query = db_select('og_users_roles', 'ogur');
  $query->innerJoin('og_role', 'ogr', 'ogur.rid = ogr.rid');

  $results = $query
      ->fields('ogur', array('rid', 'uid'))
      ->fields('ogr', array('name'))
      ->condition('ogr.group_type', $group_type, '=')
      ->condition('ogr.group_bundle', $bundle, '=')
      ->condition('ogr.gid', $query_gid, '=')
      ->condition('ogur.uid', $uids, 'IN')
      ->condition('ogur.gid', $gid, '=')
      ->orderBy('rid')
      ->execute()
      ->fetchAll();

  //Format result
  foreach($results as $result){
    $rids[$result->uid] = $result;
  }

  return $rids;

}

/**
 * @return importance is 0 for admin, 1 for contributor, 2 for readonly
 */
function gofast_mapOGRidToImportance(int $rid) : int {
  if (in_array($rid, [13, 16, 17, 20, 23, 26, 28])) {
    return 0;
  }
  if (in_array($rid, [1, 3, 5, 7, 9, 12, 14, 18, 22, 25, 27, 29])) {
    return 1;
  }
  if (in_array($rid, [2, 4, 6, 8, 10, 11, 15, 19, 21, 24, 30])) {
    return 2;
  }
  return 2;
}

function get_gofast_og_space_pending_members_actions($nid, $uid) {
  $array_actions[]['themed'] = theme('gofast_link_generic', array(
    'icon_class' => "fas fa-check",
    'href' => "/spaces/nojs/node/" . $nid . "/admin/people/grant-membership/" . $uid,
    'link_class' => 'ctools-use-modal',
    'text' => t('Grant membership', array(), array('context' => 'gofast:gofast_og'))
  ));
  $array_actions[]['themed'] = theme('gofast_link_generic', array(
    'icon_class' => "fas fa-times",
    'href' => "/spaces/nojs/node/" . $nid . "/admin/people/deny-membership/" . $uid,
    'link_class' => 'ctools-use-modal',
    'text' => t('Deny membership', array(), array('context' => 'gofast:gofast_og'))
  ));
  return $array_actions;
}

function get_gofast_og_space_members_actions($nid, $uid, $roles, $type = "user") {
  $string_type = $type == "user" ? "people" : $type;
  foreach ($roles as $rid => $role) {
    $array_actions[]['themed'] = theme('gofast_link_generic', array(
      'icon_class' => "fas fa-cog",
      'href' => "/spaces/nojs/node/" . $nid . "/admin/$string_type/instant-edit-membership/" . $uid . "/" . $rid,
      'link_class' => 'ctools-use-modal',
      'text' => t('Change to @role', array("@role" => t($role)), array('context' => 'gofast:gofast_og'))
    ));
  }
  $array_actions[]['themed'] = theme('gofast_link_generic', array(
    'icon_class' => "fas fa-times",
    'href' => "/spaces/nojs/node/" . $nid . "/admin/$string_type/delete-membership/" . $uid,
    'link_class' => 'ctools-use-modal',
    'text' => t('Remove membership', array("@role" => t($role)), array('context' => 'gofast:gofast_og'))
  ));
  return $array_actions;
}

function gofast_og_space_members_async($nid){
  global $user;
  $all_admins_space = get_all_admin_group($nid);
  $usersMembers = gofast_getUserMembersByNodeId($nid, $_GET['query']);

  $members = [];
  $roles_query = og_roles('node', gofast_get_node_type($nid), $nid, FALSE, FALSE);
  foreach($usersMembers as $data){
    if($data->etid > 1 || $data->entity_type == 'userlist' ){
         
      //check if we are admin of current space
      $is_admin = in_array($user->uid, $all_admins_space);

      $user_contextual_actions = [];

      if ($is_admin) {
        $array_actions = $data->state == 2 ? get_gofast_og_space_pending_members_actions($nid, $data->id, $data->entity_type) : get_gofast_og_space_members_actions($nid, $data->id, $roles_query, $data->entity_type);
        $user_contextual_actions[] = array(
          'id' => 'account-dropdown',
          'title' => 'Contextual actions',
          'button-text' => '',
          'icon-class' => 'fa fa-bars',
          'children' => $array_actions
        );
      }

      $member = [
        'uid' => $data->etid,
        'gname' => $data->gname,
        'sname' => $data->sname,
        'rid' => $data->rid,
        'rname' =>  $data->state == 2 ? '0' : $roles_query[$data->rid] ,
        'created' => $data->created,
        'type' => $data->entity_type,
        'membership_id' => $data->id,
        'membership_state' => $data->state,
        'membership_can_manage' => $is_admin,
        'importance' => gofast_mapOGRidToImportance((int) $data->rid),
        'actions' => empty($user_contextual_actions) ? "-" : theme('contextual_links', array('buttons' => $user_contextual_actions))
      ];

      if($data->entity_type == 'user'){
        $additional_data_query = db_query("SELECT
          `u`.`uid` AS `uid`,
          GROUP_CONCAT(`ur`.`rid` SEPARATOR ',') AS `role_id`,
          `frluo`.`ldap_user_o_value` AS `entity`
          FROM `users` `u`
          LEFT JOIN `users_roles` `ur` ON
              `u`.`uid` = `ur`.`uid`
          LEFT JOIN `field_revision_ldap_user_o` `frluo` ON
              `frluo`.`entity_id` = `u`.`uid`
          WHERE
              `u`.`uid` = {$data->etid}
          GROUP BY
            `u`.`uid`");
        $additional_data = $additional_data_query->fetchAssoc();

        $member['image'] = file_load(gofast_getUserImageById($data->etid))->filename;
        $member['href'] = '/user/'. $data->etid ;
        $member['status'] = $data->status;
        if ($additional_data['entity']) {
          $member['entity'] = $additional_data['entity'];
        }
        $member['profile'] = gofast_getUserRoleNameByImplodedRoleIds(explode(",", $additional_data['role_id']));
      } else {
        $member['gname'] = '';
        $member['href'] = '/userlist/'. $data->etid ;

      }

      $members[] = $member;
    }
  }

  usort($members, function($a, $b) {
    return $a['importance'] <=> $b['importance'];
  });
  print json_encode($members);
}

function gofast_og_home_async($nid){
    //We load the current space to recover the associated article
    $node = node_load($nid);

    // Get article node which is supposed to be og home page
    $article_nid = gofast_og_get_article_homepage_from_og($nid);
    $article_node = node_load($article_nid);

    //If we have an article (should always be), put it in its templating, otherwise we do the older version with an xeditable field
    if(isset($article_node) && $article_node->type == 'article' && $article_node->status == 1) {
      $article_node_content = theme("gofast_node_article_content", [
        'node' => $article_node,
        'only_article' => TRUE
      ]);
      $node_body = theme('gofast_og_home', array('gid' => $nid, 'content' => $article_node_content, 'space_name' => $node->title, 'custom_logo' => $node->field_logo_uri[LANGUAGE_NONE][0]['value'] ?? NULL));
          
    } else {



      $article_node_content = '<div class="gofastArticleContent p-4 bg-secondary rounded shadow-sm" style="">'.  
                                 t('No home page found for this space', array(), array('context' => 'gofast'))
                              .'</div>';
      $node_body = theme('gofast_og_home', array('gid' => $nid, 'content' => $article_node_content, 'space_name' => $node->title, 'custom_logo' => $node->field_logo_uri[LANGUAGE_NONE][0]['value'] ?? NULL));
    }

    print $node_body; exit;
}

function gofast_og_space_activity_async($nid){
  $display = theme('gofast_og_space_activity_async', array('nid'=> $nid));
  print $display; exit;
}

function gofast_og_change_space_type($space, $new_type, $new_parent_id){
    //before doing anything, check all mandatory informations are available
    if(!isset($space->nid)){
        return;
    }

    //Todo public ?
    if($new_type != "group" && $new_type != "organisation" && $new_type != "extranet"){
        return;
    }

    if(!isset(node_load($new_parent_id)->nid)){
        return;
    }

    //todo other checks ?

   //get current space path ( use cmis to be sure it is correct )
   $repository_id = gofast_cmis_get_repository();
   $cmis_current_space =  cmisapi_getObject($repository_id, gofast_cmis_get_raw_item_id($space->field_folder_reference[LANGUAGE_NONE][0]["value"]));
   if(!isset($cmis_current_space->id)){
       return;
   }

   //get current parent node
   $old_parent_node = node_load($space->og_group_ref[LANGUAGE_NONE][0]["target_id"]);
   $new_parent_node = node_load($new_parent_id);
   //move folder
    gofast_cmis_node_edit_item_move($space_node, $old_parent_node, $new_parent_node, TRUE);


    //update some node fields
    $space->type = $new_type;
    //TODO $space->field_format[LANGUAGE_NONE][0]["tid"] = "";
    $space->og_group_ref[LANGUAGE_NONE][0]["target_id"] = $new_parent_id;

    node_save($space);

    return $space;
    //print_r("<pre>");print_r($cmis_current_space);
}

function gofast_og_get_parents_gids($nid){

  $node = node_load($nid);
  $parents = gofast_og_get_parent($node);

  print json_encode($parents);
  exit;
}

/*
 * [GOFAST-6199]
 */
function gofast_og_get_parent_space_path($nid){
    $node = node_load($nid);
    $parent_node = node_load($node->og_group_ref['und'][0]['target_id']);
    $drupal_path = gofast_cmis_space_get_drupal_path($parent_node->nid);
    $new_path = str_replace("/", "/_", $drupal_path);
    $path = "node/" . $parent_node->nid . "*" . $new_path;
    print $path;
}


// QUERIES

function gofast_getUserImageById($id){

  $query = db_select('users', 'u');
  $query->fields('u', ['picture']);
  $query->condition('u.uid', $id);

  $result = $query->execute();
  $image = $result->fetchAll();

return $image[0]->picture;

}


function gofast_getAllRolesByNodeId($id){
  $query = "SELECT users.uid, users.picture, og.id, urole.rid, og.state
            FROM users, og_membership AS og, og_users_roles AS urole, og_role AS orole
            WHERE og.gid=:id
            AND users.uid=og.etid
            AND urole.uid=users.uid
            AND og.gid=urole.gid
            AND orole.rid=urole.rid
            AND og.entity_type='user'";
  $result = db_query($query, [':id' => $id])->fetchAll();
}

function gofast_getUserMembersByNodeId($nid, $filtres = []){
  // User members
  $query = db_select('og_membership', 'og');
  $query->fields('og', array('id', 'etid', 'entity_type', 'created', 'state'));
  $query->condition('og.gid', $nid , '=');
  $query->condition('og.entity_type', ['node', 'userlist'], 'NOT IN');

  // Get last name
  $query->leftJoin('field_data_ldap_user_sn', 'fusn', 'fusn.entity_id=og.etid' );
  $query->addField('fusn', 'ldap_user_sn_value', 'sname');

  // Get first name
  $query->leftJoin('field_data_ldap_user_givenname', 'fugn', 'fugn.entity_id=og.etid' );
  $query->addField('fugn', 'ldap_user_givenname_value', 'gname');

  // Get user role
  $query->leftJoin('og_users_roles', 'ur', 'ur.uid = og.etid AND ur.gid = og.gid');
  $query->addField('ur', 'rid');

  // Get user State
  $query->leftJoin('users', 'us', 'us.uid = og.etid');
  $query->addField('us', 'status');

  // Userlist members
  $userlist = db_select('og_membership', 'og');
  $userlist->fields('og', array('id', 'etid', 'entity_type', 'created', 'state'));
  $userlist->condition('og.gid', $nid , '=');
  $userlist->condition('og.entity_type', ['node', 'user'], 'NOT IN');

  //Get userlist name
  $userlist->leftJoin('gofast_userlists', 'gul', 'gul.ulid = og.etid');
  $userlist->addField('gul', 'name', 'sname');
  $userlist->addField('gul', 'nid', 'gname');

  // Get userlist role
  $userlist->leftJoin('gofast_og_userlists_roles', 'ulr', 'ulr.ulid = og.etid AND ulr.gid = og.gid');
  $userlist->addField('ulr', 'rid');


  // Get userlist state
  $userlist->addExpression('1', 'extra');
  // Filters
  if(isset($filtres['rid'])){
    
    if($filtres['rid'] == "0"){
      // Filter by pending users/userlists
      $query->condition('og.state', 2, '=');
      $userlist->condition('og.state', 2, '=');
    }else{
      $query->condition('ur.rid', $filtres['rid']);
      $userlist->condition('ulr.rid', $filtres['rid']);
    }
  }
  if(isset($filtres['type']) ){
    $query->condition('og.entity_type', $filtres['type']);
    $userlist->condition('og.entity_type', $filtres['type']);
  }
  if(isset($filtres['status'])){
    $query->condition('us.status', $filtres['status']);
  }
  if(isset($filtres['generalSearch'])){
    $or = db_or();
    $or->condition('fusn.ldap_user_sn_value', '%'.$filtres['generalSearch'].'%', 'LIKE');
    $or->condition('fugn.ldap_user_givenname_value', '%'.$filtres['generalSearch'].'%', 'LIKE');
    $query->condition($or);
    $userlist->condition('gul.name', '%'.$filtres['generalSearch'].'%', 'LIKE');
  }
  if(!isset($filtres['status'])){
    $query->union($userlist, 'UNION ALL');
  }

  $result = $query->execute();


  return $result->fetchAll();
}

function gofast_og_get_number_of_content_by_gid($gid, $types_content) {

    // SELECT nid FROM node INNER JOIN og_membership ON node.nid = og_membership.etid
    //  AND og_membership.gid = 9 AND node.type = IN ('alfresco_item', 'article', 'webform', 'forum')
    //   WHERE og_membership.field_name = 'og_group_content_ref';

    //TODO les droits sur les contenu ?
    $result = db_query("SELECT nid FROM node INNER JOIN og_membership ON node.nid = og_membership.etid AND og_membership.gid = " . $gid .  " AND node.type IN ('" . implode("', '", $types_content) . "') WHERE og_membership.field_name = 'og_group_content_ref'");

    return count($result->fetchAll());
}

function gofast_og_get_space_popup($nid=0) {
    $output = "";

    if($nid == 0) {
        return $output;
    }

    $node = node_load($nid);
    $output = theme('gofast_og_popup', ['node' => $node]);

    return $output;
}

function gofast_og_form_group_node_form_alter(&$form, &$form_state, $form_id){

  $form['#attributes']['class'][] = 'GofastForm__Group';

}
function gofast_og_form_public_node_form_alter(&$form, &$form_state, $form_id){

  $form['#attributes']['class'][] = 'GofastForm__Public';

}
function gofast_og_form_organisation_node_form_alter(&$form, &$form_state, $form_id){

  $form['#attributes']['class'][] = 'GofastForm__Organisation';

}
function gofast_og_form_extranet_node_form_alter(&$form, &$form_state, $form_id){

  $form['#title'] = t('Create Space Extranet', array(), array('context' => 'gofast:gofast_og'));
  $form['#attributes']['class'][] = 'GofastForm__Extranet';

}

function gofast_og_contact_admins($node){
  $form_id = 'gofast_og_contactform_admins_form';
  $form = drupal_get_form($form_id, $node->nid);
  $return = drupal_render($form);
  return $return;
}

function gofast_og_modal_og_contact_admins($js, $node){
  $form_id = 'gofast_og_contactform_admins_form';
  if (!$js) {
    drupal_goto("og/$node->nid/contact/admins");
  }
  ctools_include('modal');
  ctools_include('ajax');


  $form_state = array(
    'build_info' => array(
      'args' => array(
        $node->nid,
      ),
    ),
    'title' => t('Contact administrators', array(), array('context' => 'gofast')),
    'ajax' => TRUE,
    're_render' => FALSE,
    'no_redirect' => TRUE,
  );

  $commands = ctools_modal_form_wrapper($form_id, $form_state);

  if ($commands[0]["command"] !== "modal_display") {
    $commands[] = ctools_modal_command_dismiss();
    $commands[] = gofast_command_toast_message(t('The message has been sent', array(), array('context' => 'gofast:gofast_og')));

  }


  print ajax_render($commands);
}



/**
 * Implements hook_form_FORM_ID_alter()
 *
 * @param type $form
 * @param type $form_state
 * @param type $nid    nid can be nid of space or document
 */
function gofast_og_contactform_admins_form($form, &$form_state, $nid) {

  $node = node_load($nid);
  if(!isset($node->nid)){
    return;
  }

  $is_space = array_key_exists($node->type, gofast_og_node_types());
  $is_space_content = !$is_space && in_array($node->type, gofast_og_content_bundles());


  $admin_html = "";
  if($is_space){
    $admins = get_all_admin_group($nid);
    if(count($admins) > 0){
      foreach($admins as $uid){
        $admin_user = user_load($uid);
        $admin_html .= $admin_user->ldap_user_givenname[LANGUAGE_NONE][0]["value"]. " " . $admin_user->ldap_user_sn[LANGUAGE_NONE][0]["value"]." , ";
      }
    }
  }elseif($is_space_content){
    //TODO
  }


  $form['admins_markup'] = array(
    '#type' => 'markup',
    '#title' => t('Administrators', array(), array('context' => 'gofast')),
    '#markup' => $admin_html,

  );

  $form['nid'] = array(
    '#type' => 'hidden',
    '#value' => $nid
  );

  $form['message'] = array(
    '#title' => t('Message', array(), array('context' => 'gofast')),
    '#type' => 'textarea',
    '#size' => 62,
  );

  $form['submit'] = array(
    '#type' => 'submit',
    '#value' => t('Contact administrators', array(), array('context' => 'gofast')),
    '#attributes' => array('class' => array('btn', 'btn-success', 'btn-sm')),
  );

  return $form;
}

/**
 *
 * @param type $form
 * @param type $form_state
 */
function gofast_og_contactform_admins_form_validate($form, &$form_state) {
  //TODO validate fields

}

function gofast_og_contactform_admins_form_submit($form,&$form_state){


  $nid = $form_state["values"]["nid"];
  $node = node_load($nid);
  if(!isset($node->nid)){
    return;
  }

  $is_space = array_key_exists($node->type, gofast_og_node_types());
  $is_space_content = !$is_space && in_array($node->type, gofast_og_content_bundles());


  $recpt = array();

  if($is_space){
    $admins = get_all_admin_group($nid);
    if(count($admins) > 0){
      foreach($admins as $uid){
        $admin = user_load($uid);
        $recpt[] = array('recpt' => $admin->mail, 'method' => 'to');
      }
    }
  }elseif($is_space_content){
    //TODO
  }


  $site_name = variable_get('site_name', 'GoFast');
  $l = array('langcode' => $member->language, 'context' => 'gofast_og');
  $subject = t("A @role sent you a message", array("@role" => t(strtolower(GOFAST_ROLE_BUSINESS_ADMIN_VALUE), array(), array("context" => "gofast"))), $l); // subject of the message (that is seen before openning the message)
  $title = t("A @role sent you a message", array("@role" => t(strtolower(GOFAST_ROLE_BUSINESS_ADMIN_VALUE), array(), array("context" => "gofast"))), $l);
  $footer = t('Message sent from ', array(), $l).$site_name;


  $message = $form_state["values"]["message"];

  global $user;
  global $base_url;

  $name = gofast_user_display_name($user);
  $avatar = $user->picture->uri == null ? $base_url . '/sites/all/themes/bootstrap-keen/keenv2/assets/media/users/blank.png' : file_create_url($user->picture->uri);
  $author .=  "<a href='".$base_url."/user/".$user->uid."' ><img typeof='foaf:Image' src='" . $avatar . "' width='24' height='24' alt='user picture'>  " . $name ."</a>";


  $body = theme('gofast_og_notify_admins_contactform', array(
    'site_name' => $site_name,
    'author' => $author,
    'node_link' => $base_url . "/node/".$node->nid,
    'node_title' => $node->title,
    'subject' => $subject,
    'message' => $message,
    'l' => $l,
  ));

  $mail = array(
    'body' => $body,
    'title' => $title,
    'subject' => $subject,
    'footer' => $footer
  );
  gofast_mail_queue_api_queue_ext($mail,  $recpt, time());

}


function gofast_og_ask_join_space_form($form, &$form_state){

  $form['comment_join'] = array(
    '#type' => 'textarea',
    '#title' => t('Why do you want to join this space?'),
    '#required' => FALSE,
  );

   $form['default_role'] = array(
    '#type' => 'radios',
    '#options' => array(
        '1' => t("Contributor", array(), array('gofast:gofast_user')),
        '2' => t("Read Only", array(), array('gofast:gofast_user'))
    ),
    '#required' => true,
    '#default_value' => 2,
    '#title' => t("Which role do you ask on this space ?", array(), array('context' => 'gofast')),
  );

  $form['actions']['join'] = array(
    '#type' => 'submit',
    '#value' => t('Ask to join this space', array(), array('context' => 'gofast')),
    '#weight' => 15,
  );
  return $form;
}

function gofast_og_ask_join_space_form_submit($form, &$form_state){
  $gid = $form_state['build_info']['args'][0];
  $comment = $form_state['values']['comment_input'];

   if(isset($_SESSION["gids_bulk_actions"])){   
       $gids =$_SESSION["gids_bulk_actions"];
   }else{    
       $gids = array($gid);
   }

  foreach($gids as $gid){
  //if(!empty($gid)){
    gofast_og_spaces_request_action($gid, 'join', NULL, $comment);
    //change asked role.
    //og_role_revoke doesn't work while membership is pending, so delete role manually
    global $user;
    $nid = $gid;
    $uid = $user->uid;
    $bundle = node_load($nid)->type;
    $membership = og_get_membership('node', $nid, 'user', $uid);

    $roles_query = og_roles('node', $bundle, $nid, FALSE, FALSE);
    foreach($roles_query as $rkey => $roles){
      if($roles == GOFAST_OG_ROLE_ADMIN){
        $admin_rid = $rkey;
      }
      if($roles == GOFAST_OG_ROLE_READ_ONLY){
        $readonly_rid = $rkey;
      }
      if($roles == GOFAST_OG_ROLE_STANDARD){
        $contributor_rid = $rkey;
      }
    }
    db_query("delete from {og_users_roles} where uid = ".$uid." and gid = ".$nid);
    og_role_grant($membership ->group_type, $membership ->gid, $membership ->etid, $form_state["values"]["default_role"]);

  }
}

function gofast_og_get_article_homepage_from_og($gid){
  //$query = new EntityFieldQuery();
  //$query->entityCondition("entity_type", "node")
  //->entityCondition('bundle', 'article')
  //->fieldCondition('field_is_homepage', 'value', 1)
  //->fieldCondition('og_group_content_ref', 'og_group_content_ref_target_id', $gid);

  $result = db_query("select nid from og_membership INNER JOIN node ON nid=etid INNER JOIN field_data_field_is_homepage ON etid=entity_id WHERE gid= :gid and node.type='article' and node.status=1;", array(":gid" => $gid))->fetchAll();

  if(count($result) > 0){
      $array_node = $result[0]->nid;
      return $array_node;
  }else{
      return false;
  }
}

/** @param $node_locations_paths array of GOFAST_CMIS_LOCATIONS_FIELD values */
function gofast_og_has_extranet_location($node_location_paths) {
  $has_extranet_location = false;
  foreach ($node_location_paths as $node_location_path) {
    if (strpos($node_location_path, "/Sites/" . GOFAST_CMIS_LOCATIONS_FIELD_EXTRANET_VALUE) !== FALSE) {
      $has_extranet_location = true;
      break;
    }
  }
  return $has_extranet_location;
}

function gofast_og_edit_space_logo($space_node) {
  global $user;
  if (!og_user_access('node', $space_node->nid, 'administer group', $user)) {
    drupal_json_output(array('success' => FALSE, 'error' => t('You are not allowed to edit this space.', array(), array("context" => "gofast:gofast_og"))));
    exit();
  }
  $destination = 'public://space_logos/';
  file_prepare_directory($destination, FILE_CREATE_DIRECTORY);
  // $_FILES superglobal variable has to be structured the way Drupal expects it to be structured
  foreach($_FILES['image'] as $key => &$value) {
    if ($key == "error" && $value == 0) continue;
    $_FILES['files'][$key]['image'] = $value;
  }
  $parts = pathinfo($_FILES['files']['name']['image']);
  // a predictable filename facilitates direct retrieve of file info from db
  $_FILES['files']['name']['image'] = $space_node->title . '.' . $parts['extension'];
  $previous_logo_uri = $space_node->field_logo_uri[LANGUAGE_NONE][0]['value'];

  $validators['file_validate_extensions'] = array('png jpg jpeg webp');
  // actual upload
  if ($file = file_save_upload('image', $validators, $destination, FILE_EXISTS_REPLACE)) {
    $file->status = FILE_STATUS_PERMANENT;
    file_save($file);
    $space_node->field_logo_uri[LANGUAGE_NONE][0]['value'] = $file->uri;
    node_save($space_node);
    // delete previous logo if needed
    if ($file->uri != $previous_logo_uri) {
      file_unmanaged_delete($previous_logo_uri);
    }
    // riot sync
    if (isset($space_node->field_riot_identifier)) {
      $room_avatar_url = file_create_url($space_node->field_logo_uri[LANGUAGE_NONE][0]['value']);
      $room_avatar_upload_response = gofast_riot_api_upload_file($room_avatar_url);
      gofast_riot_api_change_room_avatar($space_node->field_riot_identifier[LANGUAGE_NONE][0]['value'], $room_avatar_upload_response['content_uri']);
    }
    drupal_json_output(array('success' => TRUE));
    exit();
  } else {
    $messages = drupal_get_messages();
    drupal_json_output(array('success' => FALSE, 'error' => str_replace("\n", "", strip_tags($messages['error'][0]))));
    exit();
  }
}function gofast_og_check_replication_delete_space($gid){
  $results = db_query("SELECT aid from {alfresco_replication} WHERE gid = :gid", array(":gid" => $gid))->fetchAll();
  if(count($results) == 0){
    return TRUE;
  }else{
    return FALSE;
  }
  
}
