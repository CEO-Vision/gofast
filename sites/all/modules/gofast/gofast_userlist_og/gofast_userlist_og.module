<?php

require_once 'include/gofast_userlist_og.membership.form.inc';
require_once 'include/gofast_userlist_og.search.inc';

/**
 * Define field name for userlist's space memberships. This field is attached to
 * userlist bundle and store OG node ids (references Gofast spaces bundles).
 */
define('GOFAST_OG_USERLIST_MEMBERSHIP_FIELD', 'og_userlist_node');


/*
 * Implements hook_init
 */
function gofast_userlist_og_init(){
  global $user;
  global $userlists_member_of;
  $userlists_member_of = gofast_userlist_get_userlists_by_user($user);
}

/*
 * Implements hook_menu
 */
function gofast_userlist_og_menu(){
  $items = array();

  $items['gofast_userlist_og_autocomplete'] = array(
    'page callback' => 'gofast_userlist_og_autocomplete',
    'access arguments' => array('access content'),
    'access callback' => 'user_access',
    'type' => MENU_CALLBACK,
  );


  // Edit a single membership.
  $items['spaces/%ctools_js/%/%/admin/userlist/edit-membership/%og_membership'] = array(
    'title callback' => 'og_ui_menu_title_callback',
    'title arguments' => array('Edit membership in space @group', 2, 3),
    'type' => MENU_CALLBACK,
    'page callback' => 'gofast_og_edit_membership',
    'page arguments' => array(1, 2, 3, 7),
    'access callback' => 'og_ui_user_access_group',
    'access arguments' => array('manage members', 2, 3),
  );

  // Delete a single membership.
  $items['spaces/%ctools_js/%/%/admin/userlist/delete-membership/%og_membership'] = array(
    'title callback' => 'og_ui_menu_title_callback',
    'title arguments' => array('Remove member from space @group', 2, 3),
    'type' => MENU_CALLBACK,
    'page callback' => 'gofast_userlist_og_modal_delete_membership',
    'page arguments' => array(1, 2, 3, 7),
    'access callback' => 'og_ui_user_access_group',
    'access arguments' => array('manage members', 2, 3),
  );

  $items['userlist/%node/sync'] = array(
    'type' => MENU_CALLBACK,
    'page callback' => 'gofast_userlist_og_synchronize',
    'page arguments' => array(1, TRUE),
    'access callback' => 'node_access',
    'access arguments' => array('update', 1),
  );

  return $items;
}

/*
 * Implements hook_theme
 */
function gofast_userlist_og_theme(){
    $themes = array();
    $themes['gofast_userlist_autocomplete_view'] = array(
            'template' => 'tpl/gofast-userlist-name', // template file called theme/gofast-download-link.tpl.php
            'arguments' => array(
              'userlist' => NULL
            ),
        );

    $themes['gofast_userlist_picture'] = array(
           'template' => 'tpl/gofast-userlist-picture', // template file called theme/gofast-download-link.tpl.php
           'arguments' => array(
             'userlist' => NULL
           ),
       );
    return $themes;
}

/**
 * Implements hook_entity_info_alter().
 * @param array $entity_info
 */
function gofast_userlist_og_entity_info_alter(&$entity_info){
  $entity_info['userlist']['views controller class'] = 'GofastUserlistOgMembershipViewsController' ; //'EntityDefaultViewsController',
}

/**
 * Implements hook_og_membership_insert().
 */
function gofast_userlist_og_og_membership_insert(OgMembership $og_membership) {

  global $must_propagate;
  $timer_start = microtime(true);
  watchdog('gofast_userlist_og', '%name() START ', array('%name' => __FUNCTION__), WATCHDOG_INFO);
  
  if ($og_membership->entity_type != 'userlist') {
    return;
  }
  
  if (module_exists('gofast_ldap')) {

    // Register userlist membership into the corresponding ldap entry.
    $LdapServer = gofast_ldap_server_load(GOFAST_LDAP_INT_SERVER);

    $space = node_load($og_membership->gid);
    $dn = gofast_ldap_space_dn($space);
    $userlist = entity_load_single('userlist', $og_membership->etid);
    $member = array('dn' => array(UserListEntity::getDn($userlist)));
    $LdapServer->groupAddMember($dn, $member);
  }
  
  //add defautl role if no role set yet
  $old_og_role = gofast_userlist_og_get_userlist_roles('node', $og_membership->gid, $og_membership->etid, FALSE, TRUE);
  $old_rid = key($old_og_role);
  
  if( empty($old_rid) ){ // no role already affected
    
    $default_role_name = GOFAST_OG_ROLE_READ_ONLY;
    $default_role_rid = array_key_first(gofast_og_space_admin_get_node_role('node', $og_membership->gid, $default_role_name));
    gofast_userlist_og_role_grant_userlist('node', $og_membership->gid, $og_membership->etid, $default_role_rid);
  }
  

  if($must_propagate == true){
    gofast_og_membership_propagate($og_membership);
  }

  $timer_stop = microtime(true);
  watchdog('gofast_userlist_og', '%name() END - [execution time = %time s]', array('%name' => __FUNCTION__, '%time' => ($timer_stop - $timer_start)), WATCHDOG_INFO);
}

/**
 * Implements hook_og_membership_delete().
 */
function gofast_userlist_og_og_membership_delete(OgMembership $og_membership) {

  $timer_start = microtime(true);
  watchdog('gofast_userlist_og', '%name() START ', array('%name' => __FUNCTION__), WATCHDOG_INFO);

  if ($og_membership->entity_type != 'userlist') {
    return;
  }

  if (module_exists('gofast_ldap')) {
    // Remove userlist membership into the corresponding ldap entry.
    $LdapServer = gofast_ldap_server_load(GOFAST_LDAP_INT_SERVER);

    $space = node_load($og_membership->gid);
    $dn = gofast_ldap_space_dn($space);
    $cn = gofast_ldap_space_cn($space);
    $userlist = entity_load_single('userlist', $og_membership->etid);
    $member = array('dn' => array(UserListEntity::getDn($userlist)));
    $LdapServer->groupRemoveMember($dn, $member);

    // Space dn and relative dn are needed to specify which space role entry is
    // going to be provisioned.
    $LdapServer->groupRemoveMember("cn={$cn}_ADMIN,{$dn}", $member);
    $LdapServer->groupRemoveMember("cn={$cn}_STANDARD,{$dn}", $member);
  }

  //GOFAST-5287 In some case, we could have some users that are in the subspaces as a user (not as a userlist)
  //But that are no more in the current space. In this case, we need to remove the user from children spaces
  $users_to_remove = array();
  $userlist_members = array_keys(gofast_userlist_get_members($og_membership->etid));
  foreach($userlist_members as $userlist_member){
      $isMember = (og_get_membership('node', $og_membership->gid, 'user', $userlist_member) != FALSE);

      if ($isMember) {
        $roles = gofast_og_get_user_final_roles_for_space('node', $og_membership->gid, $userlist_member);
      }

      $isPending = (!isset($roles) || empty($roles)) && ($isMember);
      if(!$isMember || $isPending){
          $users_to_remove[] = $userlist_member;
          //Let gofast_chat know that we need to remove the user from space rooms
          if(!module_exists('gofast_community')){
            //gofast_chat_remove_user_from_room($userlist_member, $og_membership->gid);
          }
      }
  }

  // The userlist has just been removed from a group. We must check if he is member of children. if yes, we have to remove him from it
  $children = gofast_og_get_children($og_membership->gid, true, false, true);
  if (count($children) > 0) {
    foreach ($children as $key => $nid) {
      $membership = og_get_membership('node', $nid, 'userlist', $og_membership->etid);
      if ($membership !== FALSE) {
        //also removed roles
        gofast_userlist_og_role_revoke_userlist('node', $nid, $og_membership->etid, 'ALL');
        og_membership_delete($membership->id);
        
      }

      foreach($users_to_remove as $user_to_remove){

          // Check if user is owner of sub_space and set admin as new owner
          gofast_og_set_admin_as_owner($nid, $user_to_remove);

          $membership = og_get_membership('node', $nid, 'user', $user_to_remove);
          if ($membership !== FALSE) {
            og_membership_delete($membership->id);
          }
       }
    }
  }

  foreach($users_to_remove as $user_to_remove){
      // Check if user is owner of space and set admin as new owner
      gofast_og_set_admin_as_owner($og_membership->gid, $user_to_remove);
  }

  $timer_stop = microtime(true);
  watchdog('gofast_userlist_og', '%name() END - [execution time = %time s]', array('%name' => __FUNCTION__, '%time' => ($timer_stop - $timer_start)), WATCHDOG_INFO);
}

/**
 * Get all roles of a userlist in a certain group.
 *
 * @param $group_type
 *   The entity type of the group.
 * @param $gid
 *   The group ID.
 * @param $ulid
 *   (optional) Integer specifying the userlist ID.
 * @param $include
 *   (optional) If TRUE also anonymous or authenticated role ID will be
 *   returned. Defaults to TRUE.
 * @param $check_active
 *   (optional) If TRUE, and the userlist is pending, only anonymous role will be
 *   returned. If blocked, no role will be returned.
 *
 * @return
 *   Array with the role IDs of the userlist as the key, and the role name as
 *   the value.
 */
function gofast_userlist_og_get_userlist_roles($group_type, $gid, $ulid = NULL, $include = TRUE, $check_active = TRUE) {
  $roles = &drupal_static(__FUNCTION__, array());

  // $userlist = entity_load_single('userlist', $ulid);

  $identifier = implode(':', array($group_type, $gid, $ulid, $include));
  if (isset($roles[$identifier])) {
    return $roles[$identifier];
  }

  $is_member = og_is_member($group_type, $gid, 'userlist', $ulid);

  $rids = array();
  $group = entity_load_single($group_type, $gid);

  //Get the bundle of the group
  list(,, $bundle) = entity_extract_ids($group_type, $group);

  //Check if roles are overriden for the group.
  $query_gid = og_is_group_default_access($group_type, $gid) ? 0 : $gid;

  if (!$check_active || $is_member) {
    $query = db_select('gofast_og_userlists_roles', 'g');
    $query->innerJoin('og_role', 'r', 'g.rid = r.rid');

    $rids = $query
        ->fields('g', array('rid'))
        ->fields('r', array('name'))
        ->condition('r.group_type', $group_type, '=')
        ->condition('r.group_bundle', $bundle, '=')
        ->condition('r.gid', $query_gid, '=')
        ->condition('g.ulid', $ulid, '=')
        ->condition('g.gid', $gid, '=')
        ->orderBy('rid')
        ->execute()
        ->fetchAllKeyed();
  }

  if ($include) {
    $role_name = $is_member ? OG_AUTHENTICATED_ROLE : OG_ANONYMOUS_ROLE;

    $rids = db_select('og_role', 'ogr')
            ->fields('ogr', array('rid', 'name'))
            ->condition('group_type', $group_type, '=')
            ->condition('group_bundle', $bundle, '=')
            ->condition('gid', $query_gid, '=')
            ->condition('name', $role_name, '=')
            ->execute()
            ->fetchAllkeyed() + $rids;
  }

  $roles[$identifier] = $rids;
  return $rids;
}

/**
 * Grant a group role to a userlist.
 *
 * @param $group_type
 *   The entity type of the group.
 * @param $gid
 *   The group ID.
 * @param $ulid
 *   The userlist ID.
 * @param $rid
 *   The role ID.
 */
function gofast_userlist_og_role_grant_userlist($group_type, $gid, $ulid, $rid ) {

  // Make sure the role is valid.
  $group = entity_load_single($group_type, $gid, $ulid);
  list(,, $bundle) = entity_extract_ids($group_type, $group);
  $og_roles = og_roles($group_type, $bundle, $gid, FALSE, FALSE);
  if (empty($og_roles[$rid])) {
    // Role isn't valid.
    return;
  }

  // Get the existing userlist roles.
  $userlist_roles = gofast_userlist_og_get_userlist_roles($group_type, $gid, $ulid);
  if (empty($userlist_roles[$rid])) {
    $role = new stdClass();
    $role->ulid = $ulid;
    $role->rid = $rid;
    $role->group_type = $group_type;
    $role->gid = $gid;
    
    //IMPORTANT : Force reset of static gofast_userlist_og_get_userlist_roles !
    drupal_static_reset('gofast_userlist_og_get_userlist_roles');
    
    //check if role not already affected
    if (! isset( gofast_userlist_og_get_userlist_roles($group_type, $gid, $ulid, FALSE, FALSE)[$rid])){
      drupal_write_record('gofast_og_userlists_roles', $role);
      gofast_userlist_og_invalidate_cache();
    }
    
    $roles = og_get_user_roles_name($rid);
    $role = reset($roles);

    if (module_exists('gofast_ldap')) {
      if ($group_type == 'node') {
        $space = node_load($gid);
        $LdapServer = gofast_ldap_server_load(GOFAST_LDAP_INT_SERVER);

        // Space dn and relative dn are needed to specify which space role entry is
        // going to be provisioned.
        $cn = gofast_ldap_space_cn($space);
        $dn = gofast_ldap_space_dn($space);

        $member = array('dn' => array(UserListEntity::getDn($ulid)));

        // Add role membership in ldap only if the role gives more privileges than
        // the 'minimal' membership (i.e. if the userlist is more than a 'member').
        $membership = og_get_membership('node', $gid, 'userlist', $ulid);
        if ($membership->state == 1) {
          if ($role_suffix = gofast_ldap_og_roles_map($role)) {
            $LdapServer->groupAddMember("cn={$cn}_{$role_suffix},{$dn}", $member);
          }
        }
      }
    }

    //If granted role is ADMINISTRATOR apply role Manager to all member of this space
    if ($role == OG_ADMINISTRATOR_ROLE) {
      $members = gofast_userlist_get_members($ulid);
      foreach ($members as $uid => $member) {
        $account = user_load($uid);
        gofast_og_user_promote_to_manager($account);
      }
    }

    //uncomment if we decide to create a special Hook
    module_invoke_all('userlist_og_role_grant', $group_type, $gid, $ulid, $rid);
    // uncomment if we decide to link this module to rules
//    if (module_exists('rules'))  {
//      rules_invoke_event('og_role_grant', og_get_membership($group_type, $gid, 'user', $uid), entity_metadata_wrapper('user', $uid), $rid);
//    }
  }
}

/**
 * Revoke a group role from a userlist.
 *
 * @param $group_type
 *   The entity type of the group.
 * @param $gid
 *   The group ID.
 * @param $ulid
 *   The userlist ID.
 * @param $rid
 *   The role ID.
 */
function gofast_userlist_og_role_revoke_userlist($group_type, $gid, $ulid, $rid='ALL') {


  $og_roles = gofast_userlist_og_get_userlist_roles($group_type, $gid, $ulid);
  
  //og_get_user_roles($group_type, $gid, $uid);
  if (!empty($og_roles[$rid]) || ($rid == 'ALL' && !empty($og_roles))) {
    
    
    // cas rid not provided
    if($rid !== 'ALL'){
      db_delete('gofast_og_userlists_roles')
      ->condition('ulid', $ulid)
      ->condition('rid', $rid)
      ->condition('group_type', $group_type)
      ->condition('gid', $gid)
      ->execute();
    }else{
      db_delete('gofast_og_userlists_roles')
      ->condition('ulid', $ulid)
      ->condition('group_type', $group_type)
      ->condition('gid', $gid)
      ->execute();
    }
     

    gofast_userlist_og_invalidate_cache();

    $roles = og_get_user_roles_name($rid);
    $role = reset($roles);

    if (module_exists('gofast_ldap')) {
      if ($group_type == 'node') {

        $space = node_load($gid);
        $LdapServer = gofast_ldap_server_load(GOFAST_LDAP_INT_SERVER);

        // Space dn and relative dn are needed to specify which space role entry is
        // going to be provisioned.
        $cn = gofast_ldap_space_cn($space);
        $dn = gofast_ldap_space_dn($space);

        $member = array('dn' => array(UserListEntity::getDn($ulid)));

        // Remove role membership from the corresponding ldap entry.
        if ($role === GOFAST_OG_ROLE_ADMIN) {
          $LdapServer->groupRemoveMember("cn={$cn}_ADMIN,{$dn}", $member);
        }
        elseif ($role === GOFAST_OG_ROLE_STANDARD) {
          $LdapServer->groupRemoveMember("cn={$cn}_STANDARD,{$dn}", $member);
        }
      }
    }

    //If granted role is ADMINISTRATOR revoke role Manager to member of this space with no other ADMINISTRATOR membership
    if ($role == GOFAST_OG_ROLE_ADMIN) {
      $members = gofast_userlist_get_members($ulid);
      foreach ($members as $uid => $member) {

        $account = user_load($uid);
        //gofast_og_user_unpromote_from_manager($account);

      }
    }


    //uncomment if we decide to create a special Hook
    module_invoke_all('userlist_og_role_revoke', $group_type, $gid, $ulid, $rid);
    // uncomment if we decide to link this module to rules
//    if (module_exists('rules'))  {
//      rules_invoke_event('og_role_revoke', og_get_membership($group_type, $gid, 'userlist', $ulid), entity_metadata_wrapper('userlist', $ulid), $rid);
//    }
  }
}

/**
 * Implement hook_og_invalidate_cache()
 * Invalidate cache.
 *
 * @param $gids
 *   Array with group IDs that their cache should be invalidated.
 */
function gofast_userlist_og_invalidate_cache($gids = array()) {
  // Reset static cache.
  $caches = array(
    'gofast_userlist_og_get_userlist_roles',
  );

  foreach ($caches as $cache) {
    drupal_static_reset($cache);
  }
}

/**
 * Implements HOOK_override_og_permissions_node_access()
 */
function gofast_userlist_og_override_og_permissions_node_access($node, $op, $account = NULL) {

//  watchdog('gofast_userlist_og', '%name() START ', array('%name' => __FUNCTION__, '%node'), WATCHDOG_INFO);

  $type = is_string($node) ? $node : (is_array($node) ? $node['type'] : $node->type);

  //do not override permission for node type.
  if(is_string($node)){
    return NODE_ACCESS_IGNORE;
  }

  if (!isset($account)) {
    global $user;
    $account = $user;
  }

/*
  watchdog('gofast_userlist_og',
          '%name() PARAMS [node = %node, op = %op, account = %account]',
          array(
            '%name' => __FUNCTION__,
            '%node' => $node->nid,
            '%op' => $op,
            '%account' => $account->uid
          ),
          WATCHDOG_INFO);
  */

  //Give view access to userlist item for all
  if ($type == 'userlist' && $op == 'view') {
   // return NODE_ACCESS_ALLOW;

  } else {

    $is_space = array_key_exists($type, gofast_og_node_types());
    $is_space_content = !$is_space && in_array($type, gofast_og_content_bundles());

    if($is_space_content && $type == 'alfresco_item'){ //override other permission only for alfresco item

      $nid =  (is_array($node) ? $node['nid'] : $node->nid);
      $node = node_load($nid);

      //Check if we already cached the user spaces
      if(!empty($_POST['gofast_userlist_cache_spaces_by_user'])){
          $user_gids = $_POST['gofast_userlist_cache_spaces_by_user'];
      }else{
        $user_gids = gofast_og_get_spaces_by_user($account, TRUE, FALSE);
        $_POST['gofast_userlist_cache_spaces_by_user'] = $user_gids;
      }
      $node_gids = _gofast_og_content_get_parents($node, FALSE);
      $intersect = array_intersect_key($user_gids, $node_gids);

      foreach($intersect as $space_gid){
        $roles = gofast_og_get_user_final_roles_for_space('node', $space_gid, $account->uid);
        $role = reset($roles);

        if($op == 'update'){
          if($role == OG_ADMINISTRATOR_ROLE || $role == GOFAST_OG_ROLE_STANDARD){
            return NODE_ACCESS_ALLOW;
          }
        }else if($op == 'delete'){
          if($role == OG_ADMINISTRATOR_ROLE){
            return NODE_ACCESS_ALLOW;
          }
        }
      }
    }
  }
  return NODE_ACCESS_IGNORE;
}


/**
 * Implements hook_node_grants_alter().
 */
function gofast_userlist_og_node_grants_alter(&$grants, $account, $op) {
  if ($op != 'view') {
    return;
  }

  // Check visibility (partitionning)
  $visibility = variable_get('gofast_user_partitioning', GOFAST_USER_PARTITIONING_DEFAULT);
  $admin_visibility = variable_get('gofast_admin_visibility', GOFAST_ADMIN_VISIBILITY_DEFAULT);
  $admin_visibility_condition = ($admin_visibility == GOFAST_ADMIN_VISIBILITY_ON && gofast_user_is_adm($account));
  $userlists = array();
  
  if (($visibility == GOFAST_USER_PARTITIONING_ON && $admin_visibility_condition == FALSE) || ($visibility == GOFAST_USER_PARTITIONING_ON_ONLY_EXTRANET && gofast_user_is_extranet() && $admin_visibility_condition == FALSE)) {
    // Get only userlist we have access (paying attention of partionning)
    $query = db_query('SELECT ul.ulid, ul.nid FROM gofast_userlists ul LEFT JOIN field_data_field_userlist_members m on ul.ulid = m.entity_id WHERE field_userlist_members_value=:uid', array(':uid' => $account->uid));
    $userlists = $query->fetchAll();
    
    $string_root_spaces = implode(",",gofast_og_get_root_spaces(FALSE,TRUE));
    $query_common_spaces = db_query('SELECT DISTINCT etid as ulid FROM og_membership WHERE entity_type = \'userlist\' AND gid IN (SELECT gid FROM og_membership WHERE entity_type = \'user\' AND etid =:uid ) AND gid NOT IN ('.$string_root_spaces.')', array(':uid' => $account->uid));
    $userlists_comm = $query_common_spaces ->fetchAll();
   
    $userlists = array_merge($userlists_comm, $userlists );
   
  }else{
    // Get all userlist
    $query = db_select('gofast_userlists', 'ul');
    $query->addField('ul', 'ulid');
    $query->addField('ul', 'nid');
    $userlists = $query->execute()->fetchAll();
  }
  
  $root_spaces = gofast_og_get_root_spaces(FALSE,TRUE);
 global $userlists_member_of;
  foreach($userlists as $userlist){
    //add this userlist to the grants to be able to search it even if we are not admin of it
    if(isset($userlist->nid)){
      $grants[OG_ACCESS_REALM . ':node'][] = $userlist->nid;
    }
    
    $is_member = isset($userlists_member_of[$userlist->ulid]);
    if ($is_member && $groups = og_get_entity_groups('userlist', $userlist->ulid)) {
      foreach ($groups as $group_type => $gids) {
        foreach ($gids as $gid) {
          $realm = OG_ACCESS_REALM . ':' . $group_type;
          if( ! isset($grants[$realm]) || ! in_array($gid, $grants[$realm] )){
            if(array_search($gid,$root_spaces) === false)
             $grants[$realm][] = $gid;       
          }
        }
      }
    }
  }
  
  return !empty($grants) ? $grants : array();
}


/**
 * Return the members of a group
 *
 * @param type $gid : group id
 * @param type $entity_type array of type
 * @param type $state
 */
function gofast_userlist_og_get_node_members($gid, $entity_type = array('user', 'userlist'), $state = array(OG_STATE_ACTIVE)) {

  $query = db_select("og_membership", "ogm");
  $query->condition("ogm.gid", $gid, "=");
  $query->condition("ogm.group_type", "node", "=");
  $query->condition("ogm.entity_type", $entity_type, "IN");
  $query->fields("ogm", array("entity_type", "etid"));
  $results = $query->execute();

  return $results->fetchAll();
}

/**
 * Return the members of a group with a role filter
 *
 * @param type $gid : group id
 * @param type $state
 * @param type $role
 */
function gofast_userlist_og_get_node_members_by_role($gid, $state = array(OG_STATE_ACTIVE), $role = "group contributor") {

  //Users
  $query = db_select("og_membership", "ogm");
  $query->innerJoin("og_users_roles", "ogr", "ogm.etid=ogr.uid");
  $query->innerJoin("og_role", "oro", "ogr.rid=oro.rid");
  $query->condition("ogm.gid", $gid, "=");
  $query->condition("ogr.gid", $gid, "=");
  $query->condition("ogm.group_type", "node", "=");
  $query->condition("ogm.entity_type", "user", "=");
  $query->condition("oro.name", $role, "=");
  $query->fields("ogm", array("entity_type", "etid"));
  $query->fields("ogr", array("rid"));
  $query->fields("oro", array("name"));
  $results = $query->execute()->fetchAll();

  //Userlists
  $query = db_select("og_membership", "ogm");
  $query->innerJoin("gofast_og_userlists_roles", "ogr", "ogm.etid=ogr.ulid");
  $query->innerJoin("og_role", "oro", "ogr.rid=oro.rid");
  $query->condition("ogm.gid", $gid, "=");
  $query->condition("ogr.gid", $gid, "=");
  $query->condition("ogm.group_type", "node", "=");
  $query->condition("ogm.entity_type", "userlist", "=");
  $query->condition("oro.name", $role, "=");
  $query->fields("ogm", array("entity_type", "etid"));
  $query->fields("ogr", array("rid"));
  $query->fields("oro", array("name"));
  $results = array_merge($results, $query->execute()->fetchAll());

  return $results;
}

/**
 * Get all group IDs for a user coming from its userlists)
 *
 * @param type $account
 * @param type $group_type
 * @return array
 */
function gofast_userlist_og_get_groups_by_user($account = NULL, $group_type = NULL, $include_public_userlist = TRUE) {

  if (empty($account)) {
    global $user;
    $account = $user;
  }

  $gids = array();
  $userlist_gids = array();
  
  //Get user userlists
  $userlists = gofast_userlist_get_userlists_by_user($account);
  
  //Get public userlist to eventually exclude it
  $pu_nid = variable_get("public_userlist");
  if($pu_nid){
      $pu_ulid = node_load($pu_nid)->field_userlist_ulid[LANGUAGE_NONE][0]['value'];
  }
  
  foreach ($userlists as $userlist) {
    if(!$include_public_userlist && $userlist->ulid == $pu_ulid){
        continue;
    }
    //Get all active OG membership that belong to the userlist the user is member of
    $userlist_gids = gofast_userlist_og_get_groups_by_userlist($userlist->ulid, $group_type);
    
    if($group_type == NULL){
      if(is_array($userlist_gids)){
         $gids += $userlist_gids['node'];
      }
    }else{
      if(is_array($userlist_gids)){
        $gids += $userlist_gids;
      }
    }

  }
  $gids = array_unique($gids);

  $result = array();
  if($group_type == NULL){
    $result['node']= $gids;
  }else{
    $result = $gids;
  }
  


  return $result;
}

/**
 * Get the groups ID of all the group a userslit is an approved member of.
 *
 * @param type $userlist
 *    The userlist entity to fetch group memberships for.
 * @param type $group_type
 *   (optional) The entity type of the groups to fetch. By default all group
 *   types will be fetched.
 * @return
 *    An array with the group IDs or an empty array.
 */
function gofast_userlist_og_get_groups_by_userlist($userlist, $group_type = NULL, $exclude_root_space = FALSE) {
  $gids = array();

  if(is_numeric($userlist)){
    $userlist = entity_load_single('userlist', $userlist);
  }

  $wrapper = entity_metadata_wrapper('userlist', $userlist->ulid);
  $og_memberships = $wrapper->{'og_membership__' . OG_STATE_ACTIVE}->value();

  if (!$og_memberships) {
    return;
  }

  foreach ($og_memberships as $og_membership) {
    if (!empty($og_membership)) {
      if($exclude_root_space === FALSE){
        $gids[$og_membership->group_type][$og_membership->gid] = $og_membership->gid;

      }else if($exclude_root_space === TRUE && !gofast_og_is_root_space(node_load($og_membership->gid))){
        $gids[$og_membership->group_type][$og_membership->gid] = $og_membership->gid;
      }
    }
  }

  if (empty($group_type)) {
    return $gids;
  }
  elseif (!empty($gids[$group_type])) {
    return $gids[$group_type];
  }
}

/**
 * Return TRUE if the given user is member of the space by its userlists
 *
 * @param type $nid
 * @param type $account
 */
function gofast_userlist_og_is_user_member_of_space($nid, $account = NULL){

  if($account == NULL){
    global $user;
    $account = $user;
  }

  $userlists = gofast_userlist_get_userlists_by_user($account);
  foreach($userlists as $userlist){
    if( og_is_member('node', $nid, 'userlist', $userlist->ulid) == TRUE){
      return TRUE;
    }
  }
  return FALSE;
}

  /**
 * Return TRUE if the given user is admin of the space by its userlists
 *
 * @param type $gid
 * @param type $account
 */
function gofast_userlist_og_is_user_admin_of_space($gid, $account = NULL){
  if($account == NULL){
    global $user;
    $account = $user;
  }

  if (is_numeric($account)) {
    $uid = $account;
  } else {
    $uid = $account->uid;
  }

  $nids = db_select("og_membership", "ogm");
  $nids->leftJoin("node", "n", "n.nid = ogm.gid");
  $nids = $nids->fields("ogm", array("gid"))
      ->condition("entity_type", "user")
      ->condition("etid", $uid)
      ->condition("field_name", "og_user_node")
      ->condition("n.type", "userlist")
      ->execute()->fetchCol();
  foreach($nids as $nid){
    $ulid = reset(gofast_userlist_get_ulid_by_nid($nid));
    if(og_get_membership('node', $gid, 'userlist', $ulid) != FALSE) {
      return TRUE;
    }
  }
  return FALSE;
}

function gofast_userlist_get_ulid_by_nid($nid) {
  return db_select("gofast_userlists", "ul")
    ->fields("ul", array("ulid"))
    ->condition("nid", $nid)
    ->execute()->fetchCol();
}

/**
 * Return userlists formated to be used by autocomplete widget
 * @param type $str
 */
function gofast_userlist_og_autocomplete($str) {
  $str = trim((string) $str);

  if (empty($str) || strlen($str) < 2) {
    // This prevents returning irrelevant results, though it should be handled
    // clientside in order to avoid useless requests.
    drupal_json_output(array());
    exit;
  }

  $options_ac_user = array(
    'format_key_callback' => 'gofast_og_ac_format_key',
    'format_value_callback' => 'gofast_og_ac_format_value'
  );

 $options_ac_userlist = array(
   'format_value_callback' => 'gofast_userlist_og_format_ac_value'
 );

  $matches = array_merge(gofast_ac_query($str, 'user', $options_ac_user), gofast_ac_query($str, 'userlist', $options_ac_userlist));


  // Highlighting string matches.
  foreach ($matches as $key => &$value) {
    $value = preg_replace(array('/[\n\r]+/', '/(<[^<>]*>)([^<>]*?)(' . preg_quote($str, '/') . ')/i'), array('', '$1$2<b>$3</b>'), $value);
  }

  drupal_json_output($matches);
  exit;
}


/**
 * Create a new membership and grant userlist a role for the given group
 * @global boolean $must_propagate
 * @param type $gid ID of the group
 * @param type $ulid ID of the userlist entity
 * @param type $rid RID of the role to be granted
 */
function gofast_userlist_og_add_membership($gid, $ulid, $rid){
  global $must_propagate;
  $must_propagate = true;

  $og_membership = og_membership_create('node', $gid, 'userlist', $ulid, GOFAST_OG_USERLIST_MEMBERSHIP_FIELD, array());
  $og_membership->state = 1;
  $og_membership->save();
  
  $old_og_role = gofast_userlist_og_get_userlist_roles('node', $gid, $ulid, FALSE, TRUE);
  $old_rid = key($old_og_role);
  if(isset($old_rid)){
    gofast_userlist_og_role_revoke_userlist('node', $gid, $ulid, $old_rid);
  }
  gofast_userlist_og_role_grant_userlist('node', $gid, $ulid, $rid);
}

/**
 * Update a memberhip (ie role granted) for a userlist on the given space
 * @param type $gid
 * @param type $ulid
 * @param type $role
 */
function gofast_userlist_og_update_membership($gid, $ulid, $role){

  $new_og_role = gofast_og_space_admin_get_node_role('node', $gid, $role);
  
  $new_rid = key($new_og_role);
  $old_og_role = gofast_userlist_og_get_userlist_roles('node', $gid, $ulid, FALSE, TRUE);
  $old_rid = key($old_og_role);
  if(isset($old_rid)){
     gofast_userlist_og_role_revoke_userlist('node', $gid, $ulid, $old_rid);
  }
  gofast_userlist_og_role_grant_userlist('node', $gid, $ulid, $new_rid);
}

/**
 * Delete membership and revoke_role
 * @param type $gid
 * @param type $ulid
 */
function gofast_userlist_og_delete_membership($gid, $ulid){

  $role =  gofast_userlist_og_get_userlist_roles('node', $gid, $ulid, FALSE, TRUE);
  $rid = key($role);
  if(isset($rid)){
    gofast_userlist_og_role_revoke_userlist('node', $gid, $ulid, $rid);
  }else{
    gofast_userlist_og_role_revoke_userlist('node', $gid, $ulid, 'ALL');
  }
  $membership = og_get_membership('node', $gid, 'userlist', $ulid);
  if($membership) $membership->delete();

  //force reset of drupal variable
  drupal_static_reset('og_get_group_members_properties');
}

/**
 * Return Userlist themed for autocomplete
 */
function gofast_userlist_og_format_ac_value($entity_type, $entity, $key, $value, $options){
  if ($entity_type === 'userlist') {
    $metadata = '<span class="labelize-metadata gofast_display_none" '
            . 'data-type="' . $entity_type . '" '
            . 'data-name="' . $entity->name . '" '
            . 'data-id="' . $entity->ulid . '"/></span>';
    $item = $metadata . theme('gofast_userlist_autocomplete_view', array('link' => FALSE, 'userlist' => $entity, 'popup' => FALSE));
  }
  return $item;
}


/**
 * Return Userlist value themed for send mail autocomplete widget
 */
function gofast_userlist_og_format_email_ac_value($entity_type, $entity, $key, $value, $options){
  if ($entity_type === 'userlist') {

    $metadata = '<span class="labelize-metadata gofast_display_none" '
            . 'data-type="' . $entity_type . '" '
            . 'data-name="' . $entity->name . '" '
            . 'data-id="' . $entity->ulid . '"/></span>';
    $item = $metadata . theme('gofast_userlist_autocomplete_view', array( 'userlist' => $entity)). " &lt;members&gt;";
  }
  return $item;
}

/**
 * Return Userlist key themed for send mail autocomplete widget
 */
function gofast_userlist_og_format_email_ac_key($entity_type, $entity, $key, $value, $options){
  if ($entity_type === 'userlist') {
    //  $item = theme('gofast_userlist_autocomplete_view', array('link' => FALSE, 'userlist' => $entity, 'popup' => FALSE)). " &lt;members&gt;";
    $item = "{$entity->name}";
  }
  return $item;
}

/**
 * Delete single OG membership - modal callback.
 */
function gofast_userlist_og_modal_delete_membership($js, $group_type, $gid, $og_membership) {
  ctools_include('og_ui/og_ui.admin', 'og', '');

  $args = func_get_args();
  array_shift($args);

  if (!$js){
    return drupal_get_form('gofast_userlist_og_form_og_ui_delete_membership', $group_type, $gid, $og_membership);
  }

  ctools_include('modal');
  ctools_include('ajax');

  $form_state = array(
    'ajax' => TRUE,
    'title' => t('Delete membership', array(), array('context' => 'gofast:gofast_og')),
    'build_info' => array(
      'args' => $args
    )
  );

  $commands = ctools_modal_form_wrapper('gofast_userlist_og_form_og_ui_delete_membership', $form_state);

  if($form_state['last_admin']){
    form_get_errors();
    $commands = array(
      ctools_modal_command_dismiss(),
      gofast_command_toast_message(t("You can't remove the last administrator of a space", array(), array('context' => "gofast:gofast_og")), "error")
    );
  }else if ($form_state['submitted']) {
    $commands = array(
      ctools_modal_command_dismiss(),
      gofast_command_processAjax("/node/{$gid}" . "#ogmembers")
    );
  }

  print ajax_render($commands);
}

/**
 * Override og_get_group_members_properties() to be able to retreive userlsit members as well
 * @param type $entity
 * @param array $options
 * @param type $name
 * @param type $type is group_type
 * @param type $member_type is entity_type , by default = array('user', 'userlist')
 * @return type
 */
function gofast_userlist_og_get_group_members_properties($entity, array $options, $name, $type, $member_type = array('user', 'userlist')) {
  $args = explode('__', (string) $name);
  $state = !empty($args[1]) ? $args[1] : FALSE;
  list($id) = entity_extract_ids($type, $entity);

  $cache = &drupal_static(__FUNCTION__, array());
  if (isset($cache[$type][$id][$state])) {
    // Return the cached result.
    return $cache[$type][$id][$state];
  }
  $cache[$type][$id][$state] = array();

  $query = new EntityFieldQuery();
  $query
    ->entityCondition('entity_type', 'og_membership')
    ->propertyCondition('group_type', $type, '=')
    ->propertyCondition('gid', $id, '=')
    ->propertyCondition('entity_type', $member_type, 'IN');

  if ($state) {
    $query->propertyCondition('state', $state, '=');
  }

  $result = $query->execute();
  if (!empty($result['og_membership'])) {
    $og_memberships = og_membership_load_multiple(array_keys($result['og_membership']));
    foreach ($og_memberships as $og_membership) {
      $cache[$type][$id][$state][$og_membership->entity_type][] = $og_membership->etid;

    }
  }
  return $cache[$type][$id][$state];
}

/**
 * Implements hook_userlist_insert()
 */
function gofast_userlist_og_entity_insert($entity, $type){

  if($type == 'userlist'){

    //Create first membership on Organisation : required to  for solr search
    $root_spaces = gofast_og_get_root_spaces(FALSE, TRUE);

    foreach($root_spaces as $nid){ //We fetch into the root spaces (excluding private spaces)
      $node = node_load($nid);
      $bundle = $node->type;

      //We add the membership only to Organisation
      if($bundle == 'organisation'){

        $roles_query = og_roles('node', $bundle, $nid, FALSE, FALSE);
        foreach ($roles_query as $rkey => $roles) { //We get the role IDs associated to the space
          if ($roles == GOFAST_OG_ROLE_READ_ONLY) {
            $readonly_rid = $rkey;
          }
        }
        gofast_userlist_og_add_membership($nid, $entity->ulid,  $readonly_rid);
      }
    }
  }
}

/**
 * Implementation of hook_views_query_alter().
 *
 * Switch INNER to LEFT
 */
function gofast_userlist_og_views_query_alter(&$view, &$query) {
// Only for my_view_name view
  if ( $view->name == 'gofast_og_members_page' ) {
    foreach($query->table_queue as $table => $settings) {
      if (!empty($settings['join']->type) && $settings['join']->type=='INNER') {
        $query->table_queue[$table]['join']->type = 'LEFT';
      }
    }
  }
}

/**
 * Implements hook_og_user_access_alter().
 *
 * Add a permission to take userlist membership into account
 */
function gofast_userlist_og_og_user_access_alter(&$temp_perm, &$context){

  $group_type = $context['group_type'];
  $group = $context['group'];
  $account = $context['account'];

  list($id) = entity_extract_ids($group_type, $group);

  $perms = array();
  if($roles = gofast_og_get_user_final_roles_for_space($group_type, $id, $account->uid)){

    // Member might not have roles if they are blocked.
    // A pending member is treated as a non-member.
    $role_permissions = og_role_permissions($roles);

    foreach ($role_permissions as $one_role) {
      $perms += $one_role;

      //if can unsubscribe (ie. user is a member via userlist) => unset subscribe permission
      if(isset($one_role['unsubscribe'])){
        unset($temp_perm['subscribe']);
      }

    }
  }
  $temp_perm += $perms;

}


/**
 * Implements hook_form_BASE_FORM_ID_alter().
 */

function gofast_userlist_og_node_form_alter(&$form, &$form_state, $form_id) {

  $node = $form['#node'];
  $space_types = gofast_og_node_types(FALSE);

  $form_type = in_array($node->type, gofast_og_content_bundles($space_types)) ? 'space content' :
          (in_array($node->type, array_keys($space_types)) ? 'space' : NULL);

  switch ($form_type) {
    case 'space content':
      $wrapper = entity_metadata_wrapper('node', $node);
      // Content visibility.
      $value = $wrapper->{GOFAST_OG_CONTENT_VISIBILITY}->value();
      array_unshift($form['#submit'], 'gofast_og_content_visibility_submit');

      // OG membership.
      $og_field = &$form[GOFAST_OG_CONTENT_MEMBERSHIP_FIELD];
      if (!empty($og_field[LANGUAGE_NONE][0]['default']['#options'])) {
        $og_options = &$og_field[LANGUAGE_NONE][0]['default']['#options'];
      }

      $groups = gofast_userlist_og_get_groups_by_user($account);
      $groups_by_type = array();

      foreach($groups['node'] as $gid){
        $curr_group = node_load($gid);
        $group_type = ucfirst($curr_group->type);
        $groups_by_type[$group_type][$gid] = $curr_group->title;
      }
      $og_options = array_replace_recursive((array) $og_options, $groups_by_type);
      break;

    case 'space':
      break;
  }



}

function gofast_userlist_og_user_form_alter(&$form, &$form_state){

  //add group form userlist to the field (used by ztree as well)
  $og_field = &$form[GOFAST_OG_USER_MEMBERSHIP_FIELD];

  $managed_spaces = gofast_og_get_managed_spaces();
  $space_type = gofast_og_node_types();

  foreach($managed_spaces as $gid){
    $group = node_load($gid);
    $group_type = ucfirst($group->type);
    if($group_type != 'Userlist'){
      $og_field[LANGUAGE_NONE][0]['default']['#options'][$group_type][$gid] = $group->title;
    }

  }

}


/*
 * Implements hook_cron
 * Synchronize Userlists with LDAP/AD
 */
function gofast_userlist_og_cron(){
    $userlists_sync_state = variable_get('userlists_sync_state', array(
        'sync_in_progress' => FALSE,
        'last_sync' => 0,
        'userlists_to_synchronize' => array(),
        'userlists_to_gofast_synchronize' => array()
    ));
    //Starts a sync each 3 hours
    //if(time() > $userlists_sync_state['last_sync'] + 10800){
      //if(!$userlists_sync_state['sync_in_progress']){
        //Start a new synchronization
        watchdog('gofast_userlist_og', "Starting a new Userlists synchronization");
        $userlists_sync_state['sync_in_progress'] = TRUE;
        
        //Retrieve userlists to synchronize
        $userlists = array_keys(db_query("select entity_id from field_data_field_is_ldap_sync WHERE field_is_ldap_sync_value=1")->fetchAllAssoc("entity_id"));
        $userlists_sync_state['userlists_to_synchronize'] = $userlists;
        
        //Retrieve userlists to synchronize
        $userlists_gofast_sync = array_keys(db_query("select entity_id from field_data_field_is_gofast_sync WHERE field_is_gofast_sync_value=1")->fetchAllAssoc("entity_id"));
        $userlists_sync_state['userlists_to_gofast_synchronize'] = $userlists_gofast_sync;
        
      //}
      
      $start_time = time();
      foreach($userlists_sync_state['userlists_to_synchronize'] as $key => $nid){
        //Start sync
        gofast_userlist_og_ldap_synchronize($nid);
        unset($userlists_sync_state['userlists_to_synchronize'][$key]);
        
        //Prevent sync to take more than ~45 sec
        if(time() > ($start_time+35)){
          break;
            }
        }

        $start_time = time();
        foreach($userlists_sync_state['userlists_to_gofast_synchronize'] as $key => $nid){
          //Start sync
          gofast_userlist_og_gofast_synchronize($nid);
          unset($userlists_sync_state['userlists_to_gofast_synchronize'][$key]);
          
          //Prevent sync to take more than ~45 sec
          if(time() > ($start_time+35)){
            break;
          }
        }
        
        
        
        if(count($userlists_sync_state['userlists_to_synchronize']) == 0 &&  count($userlists_sync_state['userlists_to_gofast_synchronize'])){
          //End of synchronization
          watchdog('gofast_userlist_og', "All userlists have been synchronized successfully");
          $userlists_sync_state['sync_in_progress'] = FALSE;
          $userlists_sync_state['last_sync'] = time();
        }else{
          watchdog('gofast_userlist_og', "Breaking sync, wait for next cron");
        }
        //    }
        
        variable_set('userlists_sync_state', $userlists_sync_state);
      }
      
      
function gofast_userlist_og_synchronize($nid, $output = FALSE){
  if(is_object($nid)){
    $node = $nid;
  }else{
    $node = node_load($nid);
  }
  
  if($node->field_is_ldap_sync[LANGUAGE_NONE][0]['value']){
    gofast_userlist_og_ldap_synchronize($nid, $output);
  }else{
    gofast_userlist_og_gofast_synchronize($nid, $output);
  }
}
      
      /*
 * @params $nid : The userlist node ID
 * Synchronize a userlist with LDAP
 */
function gofast_userlist_og_ldap_synchronize($nid, $output = FALSE) {
  if(is_object($nid)){
        $nid = $nid->nid;
      }
      
   //Load this userlist node
   $node = node_load($nid);
   
   if($node->field_is_ldap_sync[LANGUAGE_NONE][0]["value"] == 0){
    $commands = array();
    $commands[] = gofast_command_toast_message(t("Synchronisation is not enabled", array(), array('gofast:gofast_userlist')), "success");
    $commands[] = gofast_command_callback("Gofast.processAjax", "/node/" . $nid);
    print ajax_render($commands);
    exit;
   }

      //Inhibit sending mails
      $_POST['inhibit_send_mail'] = TRUE;
      
    if($output){
        //Release the request immediatly
        $commands = array();
        $commands[] = gofast_command_toast_message(t("This userlist will be synchronized in a few seconds...", array(), array('gofast:gofast_userlist')), "success");
        $commands[] = gofast_command_callback("Gofast.processAjax", "/node/" . $nid);
        print ajax_render($commands);
        fastcgi_finish_request();
    }

    //Parse DNs and filters
    $base_dns = $node->field_base_dns[LANGUAGE_NONE][0]['value'];
    $filters = $node->field_filters[LANGUAGE_NONE][0]['value'];

    $base_dns = explode("\n", $base_dns);
    $parsed_dns = array();
    //Parse selected dns
    foreach ($base_dns as &$dns) {
        if (!empty($dns)) {
            $dns = str_replace("\n", "", $dns);
            $dns = str_replace("\r", "", $dns);
            $dns = str_replace("\t", "", $dns);
            $parsed_dns[] = $dns;
        }
    }

    $filters = explode("\n", $filters);
    $parsed_filters = array();
    //Parse selected filters
    foreach ($filters as &$filter) {
        if (!empty($filter)) {
            $filter = str_replace("\n", "", $filter);
            $filter = str_replace("\r", "", $filter);
            $filter = str_replace("\t", "", $filter);
            $filter = explode("=", $filter);
            if(count($filter) > 1){
                $filter[0] = strtolower($filter[0]);
                $parsed_filters[] = array(
                    array_shift($filter),
                    implode("=", $filter)
                );
            }
        }
    }

    //Search for users to synchronize
    if(count($parsed_dns) > 0){
        module_load_include('inc', 'gofast_ldap', 'gofast_ldap.settings');
        module_load_include('inc', 'gofast_ldap', 'gofast_ldap.admin');
        module_load_include('inc', 'gofast_ldap', 'gofast_ldap.sync');

        $sid = GOFAST_LDAP_EXT_SERVER;
        $server = gofast_ldap_server_load($sid);

        //Load used params
        $opt_key = __FUNCTION__ . '_search_options';
        $options = isset($form_state[$opt_key]) ? $form_state[$opt_key] : gofast_ldap_admin_options_default($sid);
        $attributes = gofast_ldap_server_attributes($sid, TRUE, TRUE);

        //Set filters
        if(!empty($parsed_filters)){
            unset($options['filters']);

            foreach($parsed_filters as $filter){
                $options['filters'][] = array(
                    "attr" => $filter[0],
                    "value" => $filter[1]
                );
            }
        }

        //Set DNs
        $server->basedn = $parsed_dns;

        // Execute LDAP search query.
        $results = gofast_ldap_admin_query($server, $options);

        if($results == false){
          watchdog('Directory Synchronization', "Remote directory is unavailable", array(), WATCHDOG_ERROR);
          return;
        }

        $userlist_entity = entity_load_single('userlist', $node->field_userlist_ulid['und'][0]['value']);

        $new_userlist_members = array();
        foreach($results as $result){
          if(!empty($result['uid'])){
              $name = $result['uid'][0];
          }else if(!empty($result['samaccountname'])){
              $name = $result['samaccountname'][0];
          }else{
              continue;
          }

          $uid = array_keys(db_query("select uid from users where name='" . $name . "'")->fetchAllAssoc("uid"))[0];

          if(is_numeric($uid) && $uid > 1){
            $new_userlist_members[]['value'] = "$uid";
          }
        }

        $userlist_entity->field_userlist_members['und'] = $new_userlist_members;
        $userlist_entity->save();
    }

    //Inhibit sending mails
    $_POST['inhibit_send_mail'] = TRUE;
}

/*
 * @params $nid : The userlist node ID
 * Synchronize a userlist with GoFAST
 */
function gofast_userlist_og_gofast_synchronize($nid, $output = FALSE){
  if (is_object($nid)) {
    $nid = $nid->nid;
  }

  //Inhibit sending mails
  $_POST['inhibit_send_mail'] = TRUE;

  if ($output) {
    //Release the request immediatly
    $commands = array();
    $commands[] = gofast_command_toast_message(t("This userlist will be synchronized in a few seconds...", array(), array('gofast:gofast_userlist')), "success");
    $commands[] = gofast_command_callback("Gofast.processAjax", "/node/" . $nid);
    print ajax_render($commands);
    fastcgi_finish_request();
  }
  
   //Load this userlist node
   $node = node_load($nid);

  //Parse filters
  $gofast_filters = $node->field_gofast_filters[LANGUAGE_NONE][0]['value'];
  $gofast_filters = explode("\n", $gofast_filters);
  $parsed_filters = array();
  //Parse selected filters
  foreach ($gofast_filters as &$filter) {
    if (!empty($filter)) {
      $filter = str_replace("\n", "", $filter);
      $filter = str_replace("\r", "", $filter);
      $filter = str_replace("\t", "", $filter);
      $filter = explode("=", $filter);
      if (count($filter) > 1) {
        $filter[0] = strtolower($filter[0]);
        $parsed_filters[] = array(
          array_shift($filter),
          implode("=", $filter)
        );
      }
    }
  }
  
  //Set filters
  if (!empty($parsed_filters)) {
    unset($options['filters']);

    foreach ($parsed_filters as $filter) {
      $options['filters'][] = array(
        "attr" => $filter[0],
        "value" => $filter[1]
      );
    }
  }
  
  foreach($options['filters'] as $key => $filter){
    $query = db_select('users', 'u');
    $query->fields('u', array('uid'));
    $query->innerJoin("field_data_" . $filter['attr'], "fd", 'u.uid=fd.entity_id');
    $query->condition("fd." . $filter['attr'] . "_value" , $filter['value'], "=");
    $results = $query->execute()->fetchAllAssoc('uid');
  }
  
  $userlist_entity = entity_load_single('userlist', $node->field_userlist_ulid['und'][0]['value']);
  
  foreach($results as $result){
    if(!empty($result->uid)){
        $uid = $result->uid;
    }else{
        continue;
    }

    if(is_numeric($uid) && $uid > 1){
      $new_userlist_members[]['value'] = $uid;
    }
  }

  $userlist_entity->field_userlist_members['und'] = $new_userlist_members;
  $userlist_entity->save();
  
}

/*
 * Implements hook_form_alter
 */
function gofast_userlist_og_form_userlist_node_form_alter(&$form, &$form_state){
    //Form translations
    $form['field_is_ldap_sync'][LANGUAGE_NONE]['#title'] = t($form['field_is_ldap_sync'][LANGUAGE_NONE]['#title'], array(), array('context' => 'gofast:gofast_userlist'));
    $form['field_base_dns'][LANGUAGE_NONE][0]['value']['#title'] = t($form['field_base_dns'][LANGUAGE_NONE][0]['value']['#title'], array(), array('context' => 'gofast:gofast_userlist'));
    $form['field_filters'][LANGUAGE_NONE][0]['value']['#title'] = t($form['field_filters'][LANGUAGE_NONE][0]['value']['#title'], array(), array('context' => 'gofast:gofast_userlist'));
    $form['field_base_dns'][LANGUAGE_NONE][0]['value']['#description'] = t($form['field_base_dns'][LANGUAGE_NONE][0]['value']['#description'], array(), array('context' => 'gofast:gofast_userlist'));
    $form['field_filters'][LANGUAGE_NONE][0]['value']['#description'] = html_entity_decode(t(htmlentities($form['field_filters'][LANGUAGE_NONE][0]['value']['#description']), array(), array('context' => 'gofast:gofast_userlist')));
    $form['field_gofast_filters'][LANGUAGE_NONE][0]['value']['#title'] = t($form['field_gofast_filters'][LANGUAGE_NONE][0]['value']['#title']);
    $form['field_gofast_filters'][LANGUAGE_NONE][0]['value']['#description'] = html_entity_decode(t(htmlentities($form['field_gofast_filters'][LANGUAGE_NONE][0]['value']['#description']), array(), array('context' => 'gofast:gofast_userlist')));
    $form['field_is_gofast_sync'][LANGUAGE_NONE]['#title'] = t($form['field_is_gofast_sync'][LANGUAGE_NONE]['#title']);
    $form['field_is_gofast_sync'][LANGUAGE_NONE]['#description'] = t($form['field_is_gofast_sync'][LANGUAGE_NONE]['#description']);
    $form['#groups']['group_gofast_sync']->format_settings["instance_settings"]['description'] = html_entity_decode(t(htmlentities($form['#groups']['group_gofast_sync']->format_settings["instance_settings"]['description'])));
    $form['#groups']['group_ldap_sync']->format_settings["instance_settings"]['description'] = html_entity_decode(t(htmlentities($form['#groups']['group_ldap_sync']->format_settings["instance_settings"]['description'])));
    $form['#attributes']['class'][] = 'GofastForm__Userlist';
  }

/*
 * Implements gofast_api_RESSOURCE_ACTION
 * @ressource userlist
 * @action members
 */
function gofast_api_userlist_members($params){
    switch($params['method']){
        case 'GET':
            gofast_api_get_userlist_members($params);
            break;
        case 'PUT':
            gofast_api_put_userlist_members($params);
            break;
        case 'DELETE':
            gofast_api_delete_userlist_members($params);
          break;
        default:
            gofast_api_not_implemented("This method");
            break;
    }
}

function gofast_api_get_userlist_members($params){
//Check content type
  if (strpos($params['Content-Type'], "application/json") === FALSE) {
    return gofast_api_not_implemented("This Content-Type");
  }

  //Check authentication
  global $user;
  if ($user->uid == 0) {
    gofast_api_not_authorized("Unavailable ressource for anonymous user");
  }

    //Check if we have a nulid param
  if (isset($params['nulid'])) {
     $userlist_node_id = $params['nulid'];
    if(!is_numeric($userlist_node_id)){
      gofast_api_internal_server_error("nulid must be numeric");
    }
  } else {
    gofast_api_mandatory_parameter("nulid");
  }

    $userlist_node = node_load($userlist_node_id);
    $ulid = $userlist_node->field_userlist_ulid[LANGUAGE_NONE][0]["value"];

  //Check if we retrieved a node
  if ($userlist_node == null || $userlist_node->type != 'userlist') {
    gofast_api_internal_server_error("Unable to load a userlist with gid : " . $userlist_node_id);
  }

    $output = gofast_userlist_get_members($ulid, FALSE);

    gofast_api_success($output);
}

function  gofast_api_put_userlist_members($params){

 //Check content type
  if (strpos($params['Content-Type'], "application/json") === FALSE) {
    return gofast_api_not_implemented("This Content-Type");
  }

  //Check authentication
  global $user;
  if ($user->uid == 0) {
    gofast_api_not_authorized("Unavailable ressource for anonymous user");
  }

    //Check if we have a nulid param
  if (isset($params['nulid'])) {
     $userlist_node_id = $params['nulid'];
    if(!is_numeric($userlist_node_id)){
      gofast_api_internal_server_error("nulid must be numeric");
    }
  } else {
    gofast_api_mandatory_parameter("nulid");
  }

      //Check if we have a nulid param
  if (isset($params['uid'])) {
    $uid = $params['uid'];
    if(!is_numeric($uid)){
      gofast_api_internal_server_error("uid must be numeric");
    }
  } else {
    gofast_api_mandatory_parameter("uid");
  }

  //Check if user exist
  if (user_load($uid) == FALSE) {
    gofast_api_forbidden("Unable to load a user with uid ". $uid);
  }

    $userlist_node = node_load($userlist_node_id);
    $ulid = $userlist_node->field_userlist_ulid[LANGUAGE_NONE][0]["value"];

  //Check if we retrieved a node
  if ($userlist_node == null || $userlist_node->type != 'userlist') {
    gofast_api_internal_server_error("Unable to load a userlist with gid : " . $userlist_node_id);
  }

  //Check node access
  if (!node_access('update',$userlist_node)) {
    gofast_api_forbidden("You don't have the permission to modify this userlist user's");
  }


  $users =  gofast_userlist_get_members($ulid,FALSE);
  foreach ($users as $id_user => $user_userlist) {
    if($id_user ==  $uid){
        gofast_api_forbidden("User does already exist in this userlist");
    }
  }

  //add user role to the userlist
  $userlist_entity = entity_load_single('userlist', $userlist_node->field_userlist_ulid['und'][0]['value']);
  $userlist_entity->field_userlist_members['und'][] = array('value' => $uid);
  gofast_mail_add_user_to_userlist($uid, $userlist_node_id, NULL, "MEM");
  $userlist_entity->save();
  gofast_api_success(['status'=>"OK",'message'=>'user with uid = '.$uid.' is now an member of the userlist with nulid = '.$userlist_node_id ]);
}

function  gofast_api_delete_userlist_members($params){
 //Check content type
  if (strpos($params['Content-Type'], "application/json") === FALSE) {
    return gofast_api_not_implemented("This Content-Type");
  }

  //Check authentication
  global $user;
  if ($user->uid == 0) {
    gofast_api_not_authorized("Unavailable ressource for anonymous user");
  }

    //Check if we have a nulid param
  if (isset($params['nulid'])) {
     $userlist_node_id = $params['nulid'];
    if(!is_numeric($userlist_node_id)){
      gofast_api_internal_server_error("nulid must be numeric");
    }
  } else {
    gofast_api_mandatory_parameter("nulid");
  }

      //Check if we have a nulid param
  if (isset($params['uid'])) {
    $uid = $params['uid'];
    if(!is_numeric($uid)){
      gofast_api_internal_server_error("uid must be numeric");
    }
  } else {
    gofast_api_mandatory_parameter("uid");
  }

  //Check if user exist
  if (user_load($uid) == FALSE) {
    gofast_api_forbidden("Unable to load a user with uid ". $uid);
  }

    $userlist_node = node_load($userlist_node_id);
    $ulid = $userlist_node->field_userlist_ulid[LANGUAGE_NONE][0]["value"];

  //Check if we retrieved a node
  if ($userlist_node == null || $userlist_node->type != 'userlist') {
    gofast_api_internal_server_error("Unable to load a userlist with gid : " . $userlist_node_id);
  }

  //Check node access
  if (!node_access('update',$userlist_node)) {
    gofast_api_forbidden("You don't have the permission to modify this userlist user's");
  }


  $users =  gofast_userlist_get_members($ulid,FALSE);

  foreach ($users as $id_user => $user_usrlist) {
    if($id_user ==  $uid){
          // delete user role from the userlist
          $userlist_entity = entity_load_single('userlist', $userlist_node->field_userlist_ulid['und'][0]['value']);
          $members =  $userlist_entity->field_userlist_members['und'];
            foreach($members as $key => $member){
              if ($member['value'] == $uid) {
                unset($userlist_entity->field_userlist_members['und'][$key]);
                $userlist_entity->save();
                gofast_mail_remove_user_from_userlist( $uid, $userlist_node_id, NULL,"MEM");
                gofast_api_success(['status'=>"OK",'message'=>'user with uid = '.$uid.' is removed from members of the userlist with nulid = '.$userlist_node_id ]);
              }
            }
    }
  }

 gofast_api_forbidden("User dose not exist in the member's userlist");
}


/** 
 * 
 * Checks if a user is a member of a userlist if user is not provided it will use the current user
 *
 * @param mixed $node
 * @param null $user
 *
 * @return bool
 */
function gofast_userlist_og_is_member_in_userlist(mixed $node, $user = NULL): bool {
  if($user == NULL){
    global $user;
  }
  $ulid = $node->field_userlist_ulid[LANGUAGE_NONE][0]["value"];
  $members = gofast_userlist_get_members($ulid);
  
  if (array_key_exists($user->uid, $members)) {
    return TRUE;
  }
  return FALSE;
}

/**
 * Checks if a user can preadd a user to a user list
 * A user can only preadd a user to a user list if he has the 'business 
 * administrator' role
 */
function gofast_userlist_og_can_preadd_user_to_userlist(): bool|String {
  global $user;
  if (isset($user->roles)) {
    if (in_array('business administrator', $user->roles)) {
      return TRUE;
    }
  }
  return t('Only business administrators can preadd users to user lists', array(), array('context' => 'gofast:gofast_userlist'));
}
